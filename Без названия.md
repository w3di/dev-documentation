## Javascript
Переменные и константы: let, const, var и их отличия

Примитивные типы: string, number, boolean, null, undefined, symbol, bigint и их методы

Ссылочные типы: object, array, function

Область видимости и Lexical Scope, Lexical Environment

Hoisting (подъём переменных и функций)

Функции: обычные, стрелочные, анонимные, колбэки и их отличия

Контекст this в разных ситуациях

Методы bind, call, apply

Замыкания (Closures)

IIFE (Immediately Invoked Function Expression)

Деструктуризация

Rest и Spread операторы

Операторы nullish coalescing (??) и optional chaining (?.)

Циклы: for, while, do...while

Циклы по коллекциям: for...in, for...of

Циклы по объектам: for...in, Object.keys, Object.values

Создание и копирование объектов и массивов (поверхностное и глубокое)

JSON: parse и stringify

Асинхронность: setTimeout, setInterval (углублённо)

Event loop и очередь событий (основы)

Promise: resolve, reject, then, catch

async/await

try...catch

Модули: export/import и require

## Typescript
Массивы, кортежи (tuple), тип any, unknown, void, never

Типизация функций: аргументы, возвращаемое значение, типы по умолчанию

Объекты и интерфейсы (interface)

Типы и алиасы (type alias)

Разница между type и interface

Объединение (union), пересечение (intersection) типов

Литеральные типы и строковые литералы  

Enum и const enum

Типизация массивов и объектов (Record, Partial, Required, Readonly)

Дженерики (Generics) и обобщённые типы
  
Условные типы (Conditional Types)

Infer и предикаты типов (type predicates)

Оператор keyof, typeof, in, as

Type assertion и type casting

Работа с null и undefined: строгая проверка (strictNullChecks)

Namespace и модули

Асинхронность с типами: Promise, async/await


- Пропсы и состояние
    - Передача данных через props
    - Управление локальным состоянием с помощью `useState`
- Основные хуки: useState, useEffect, useRef
- Подъём состояния (lifting state up)
    - Поднятие state к общему родителю для синхронизации между компонентами
- Списки и ключи (key)
    - Правильная генерация списка с `key`
        
    - Ошибки при использовании индексов
        
- FlatList: оптимизация списков и keyExtractor
    
    - Эффективная работа с большими массивами данных
        
    - Кастомный `keyExtractor`, производительность
        
- Основы маршрутизации: expo-router
    
    - Как работает файловая структура
        
    - Хуки `useRouter`, `Link`, `useLocalSearchParams`
        
- Разница между stack, slot, tab
    
    - Когда использовать стековую, табовую и слот-навигацию
        
- Передача параметров между экранами
    
    - Навигация с параметрами и их получение на другом экране
        
- Работа с размерами и адаптивность
    
    - Использование `Dimensions`, `useWindowDimensions`, `StyleSheet`
        
    - Относительные единицы, flex
        
- Хуки оптимизации: useMemo, useCallback
    
    - Избежание лишних ререндеров
        
    - Мемоизация данных и функций
        
- Хоки (memo)
    
    - Обёртка компонентов для предотвращения лишних обновлений
      
      
      12. **Глобальное состояние: Context API**  
    — Создание глобального состояния с `Context`  
    — Провайдер и `useContext` для доступа к состоянию
    
13. **Глобальное состояние с Redux**  
    — Основы Redux: store, actions, reducers, dispatch  
    — Использование `Redux Toolkit` (`createSlice`, `configureStore`)
    
14. **Глобальное состояние с useReducer**  
    — Сравнение `useReducer` с `useState`  
    — Управление сложным состоянием с `useReducer`  
    — Использование `dispatch` с `useReducer` для обновления состояния
    
15. **Zustand для глобального состояния**  
    — Установка и настройка Zustand  
    — Простота использования: создание store, обновление состояния
    
16. **Диспатч в Redux и useReducer**  
    — В Redux: использование `dispatch` для отправки action в store  
    — В `useReducer`: использование `dispatch` для обновления состояния через редукторы