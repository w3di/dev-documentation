{
  "items": [
    {
      "question": "Что такое <b>default.js</b> и зачем он нужен в <b>Parallel Routes</b>?",
      "id": "q-1-97c7f174",
      "answer": "▪ <b>default.js</b> — это файл, который рендерится как <b>fallback</b> для слота, когда Next.js не может восстановить его активное состояние после жёсткой навигации (<b>full-page load</b>). Он нужен, чтобы слоты, не совпадающие с текущим URL, не показывали 404, а отображали заглушку<br />"
    },
    {
      "question": "В каких случаях Next.js использует <b>default.js</b>?",
      "id": "q-2-57b0625e",
      "answer": "▪ При <b>hard navigation</b> (<b>F5</b> или прямой переход по ссылке)<br />▪ Когда активное состояние слота не может быть восстановлено из URL<br />▪ Для subpages, которые не совпадают с текущим URL<br />"
    },
    {
      "question": "Чем отличается поведение слотов при <b>soft navigation</b> и <b>hard navigation</b>?",
      "id": "q-3-bf78a930",
      "answer": "▪ Soft navigation: Next.js отслеживает состояние каждого слота и рендерит его как есть<br />▪ Hard navigation: Next.js не знает активное состояние слотов, поэтому для слотов без совпадения с URL рендерится <b>default.js</b> (или 404, если <b>default.js</b> нет)<br />"
    },
    {
      "question": "Что произойдёт, если слот не имеет <b>default.js</b> и Next.js не может восстановить его состояние?",
      "id": "q-4-2fde9ace",
      "answer": "▪ В таком случае Next.js рендерит 404 внутри этого слота<br />"
    },
    {
      "question": "Почему нужно создавать <b>default.js</b> для implicit slot children?",
      "id": "q-5-f5ae9a44",
      "answer": "<br />"
    },
    {
      "question": "Что такое <b>Dynamic Route Segment</b> и как он создаётся?",
      "id": "q-6-4bebe0ab",
      "answer": "▪ Dynamic Segment используется, когда имена сегментов маршрута заранее неизвестны и определяются динамически. Создаётся с помощью квадратных скобок:<br />"
    },
    {
      "question": "Как передаются dynamic <b>params</b> в компонент?",
      "id": "q-7-88b4fd02",
      "answer": "▪ В <b>Server Components</b> они приходят через проп <b>params</b> (как promise).<br />▪ В <b>Client Components</b> можно:<br />▪ использовать <b>use</b>(<b>params</b>) для получения значения;<br />▪ использовать хук <b>useParams</b>() в любом месте дерева клиента.<br />"
    },
    {
      "question": "Что такое Catch-all Segments?",
      "id": "q-8-8f97ecce",
      "answer": "▪ Catch-all [...slug] захватывает все последующие части пути в <b>Dynamic Route Segment</b><br />"
    },
    {
      "question": "Чем отличаются Catch-all и Optional Catch-all?",
      "id": "q-9-e71eea1d",
      "answer": "▪ [...slug] → требует хотя бы один сегмент.<br />▪ [[...slug]] → может быть без сегмента (/shop тоже матчится).<br />"
    },
    {
      "question": "Что делает <b>generateStaticParams</b>?",
      "id": "q-10-8aed86ed",
      "answer": "▪ Функция <b>generateStaticParams</b> позволяет заранее (на этапе сборки) сгенерировать динамические маршруты.<br /><br />"
    },
    {
      "question": "Что такое <b>error.js</b> и зачем он нужен в Next.js?",
      "id": "q-11-35a4ab55",
      "answer": "▪ это специальный файл, который позволяет обрабатывать неожиданные runtime-ошибки и показывать <b>fallback</b> UI вместо того, чтобы страница падала полностью. Он работает как React <b>Error Boundary</b>, оборачивая сегмент маршрута и его дочерние элементы.<br />"
    },
    {
      "question": "Почему <b>error.js</b> должен быть Client Component?",
      "id": "q-12-8899faac",
      "answer": "▪ Error Boundaries в React могут быть реализованы только в <b>Client Components</b>. Поэтому <b>error.js</b> всегда должен начинаться с '<b>use client</b>'<br />"
    },
    {
      "question": "Как работает <b>error.js</b> внутри сегмента маршрута?",
      "id": "q-13-df4e899e",
      "answer": "▪ Каждый сегмент маршрута может иметь свой <b>error.js</b>.<br />▪ Если в сегменте или его дочерних компонентах происходит ошибка, Next.js рендерит <b>error.js</b> вместо содержимого сегмента<br />▪ Если нужно, ошибка может \"проброситься\" выше к родительскому <b>error.js</b><br />"
    },
    {
      "question": "Какие пропсы получает <b>error.js</b> и что они означают?",
      "id": "q-14-7454668e",
      "answer": "▪ error — объект ошибки<br />▪ В dev-режиме включает сообщение ошибки (для удобной отладки)<br />▪ В продакшене ошибки из <b>Server Components</b> передаются как безопасный объект с <b>digest</b> (чтобы не утекли чувствительные данные).<br />▪ Ошибки из <b>Client Components</b> показывают оригинальное сообщение<br />▪ reset — функция, которая позволяет попробовать перерисовать сегмент:<br />"
    },
    {
      "question": "Чем отличаются ошибки из <b>Client Components</b> и <b>Server Components</b> в том, как они передаются в <b>error.js</b>?",
      "id": "q-15-3561630a",
      "answer": "▪ <b>Client Components</b> → передаётся оригинальное сообщение ошибки<br />▪ <b>Server Components</b> → передаётся обезличенное сообщение + <b>digest</b>, чтобы исключить утечку приватных данных.<br />"
    },
    {
      "question": "Что делает функция reset() в <b>error.js</b>?",
      "id": "q-16-0c2c67c7",
      "answer": "▪ Она инициирует повторный рендер сегмента маршрута.<br /><br />"
    },
    {
      "question": "Чем global.js отличается от global.jsx и что и когда нужно применять?",
      "id": "q-17-f58a5b43",
      "answer": "▪ <b>error.js</b> → обрабатывает ошибки локально, внутри конкретного сегмента и его дочерних страниц.<br />▪ global-<b>error.js</b>x → глобальный обработчик, заменяющий root layout или template при ошибке. Используется для критических ошибок, которые ломают всё приложение<br />"
    },
    {
      "question": "Почему в global-error нужно определять свои <html> и <body>?",
      "id": "q-18-0b4ca035",
      "answer": "▪ global-<b>error.js</b>x заменяет root layout, у него нет доступа к общим обёрткам (layout, template)<br /><br />"
    },
    {
      "question": "Что такое <b>instrumentation.js</b> и зачем он нужен в Next.js?",
      "id": "q-19-32d630d3",
      "answer": "▪ <b>instrumentation.js</b> — это специальный файл для интеграции серверных инструментов наблюдаемости (observability) в Next.js. Он позволяет подключать системы вроде <b>OpenTelemetry</b>, <b>Sentry</b> или кастомные логгеры для отслеживания производительности, логирования ошибок и отладки в продакшене.<br />"
    },
    {
      "question": "Где должен находиться файл <b>instrumentation.js</b>|ts?",
      "id": "q-20-27df9666",
      "answer": "▪ В корне проекта<br />"
    },
    {
      "question": "Когда вызывается функция <b>register</b>() и что в ней обычно делают?",
      "id": "q-21-794da9e8",
      "answer": "▪ <b>register</b>() вызывается один раз при инициализации нового экземпляра сервера Next.js. Обычно внутри неё подключают и настраивают библиотеку наблюдаемости, например <b>OpenTelemetry</b> или кастомный логгер<br />"
    },
    {
      "question": "Для чего используется <b>onRequestError</b> и какие параметры он принимает?",
      "id": "q-22-c33980c4",
      "answer": "▪ <b>onRequestError</b> вызывается, когда Next.js сервер зафиксировал ошибку. Обычно его используют, чтобы отправить информацию об ошибках в сторонние сервисы<br />▪ error — объект ошибки + <b>digest</b> (уникальный идентификатор ошибки).<br />▪ request — данные запроса (path, method, <b>headers</b>).<br />▪ context — контекст ошибки (тип роутера, сегмент, где упало: render, route, action, middleware).<br />"
    },
    {
      "question": "Что такое <b>digest</b> у ошибки в <b>onRequestError</b>?",
      "id": "q-23-470a43d3",
      "answer": "▪ <b>digest</b> — уникальный хэш ошибки, который помогает связать ошибку в клиенте с соответствующими логами на сервере<br />"
    },
    {
      "question": "Как можно разделить реализацию <b>register</b> и <b>onRequestError</b> для <b>Node.js</b> и <b>Edge</b> рантаймов?",
      "id": "q-24-8de12d2c",
      "answer": "▪ Через process.env.<b>NEXTRUNTIME</b><br /><br />"
    },
    {
      "question": "Что такое <b>instrumentation-client.js</b> и для чего он используется?",
      "id": "q-25-5d072256",
      "answer": "▪ <b>instrumentation-client.js</b>|ts — это файл для добавления клиентских инструментов наблюдаемости таких как аналитики, трекинга производительности, отслеживания ошибок, полифиллов и других side-effects, которые должны работать до того, как React станет интерактивным<br />"
    },
    {
      "question": "Где должен находиться файл <b>instrumentation-client.js</b>|ts?",
      "id": "q-26-bdc78ef7",
      "answer": "▪ в корне приложения<br />"
    },
    {
      "question": "В какой момент жизненного цикла приложения выполняется код из <b>instrumentation-client.js</b>?",
      "id": "q-27-c3300a36",
      "answer": "▪ после загрузки HTML но до гидратации React и возможности взаимодействия пользователя<br />"
    },
    {
      "question": "Для чего используется <b>onRouterTransitionStart</b> и какие параметры она получает?",
      "id": "q-28-02b2393a",
      "answer": "▪ Функция вызывается при начале навигации внутри приложения<br />▪ url: string — URL, на который происходит переход.<br />▪ avigationType: 'push' | 'replace' | 'traverse' — тип навигации<br /><br />"
    },
    {
      "question": "Что такое <b>Intercepting Routes</b> и для чего они используются?",
      "id": "q-29-566a9d34",
      "answer": "▪ <b>Intercepting Routes</b> позволяют загружать маршрут из другой части приложения в текущем layout. Это полезно, когда нужно показать контент без переключения основного контекста страницы<br />"
    },
    {
      "question": "В чём разница между <b>soft navigation</b> и <b>hard navigation</b> при использовании <b>Intercepting Routes</b>?",
      "id": "q-30-46b9d11c",
      "answer": "▪ Soft navigation — при клиентской навигации (например, клик по фото в ленте) маршрут перехватывается, URL маскируется, и фото показывается в модальном окне.<br />▪ Hard navigation — при обновлении страницы или переходе по прямой ссылке весь маршрут рендерится как полноценная страница без перехвата.<br />"
    },
    {
      "question": "Как работает (.), (..), (..)(..), и (...) при определении перехватываемых маршрутов?",
      "id": "q-31-ba80c2d4",
      "answer": "▪ (.) — перехватывает сегменты на том же уровне.<br />▪ (..) — перехватывает сегменты на один уровень выше.<br />▪ (..)(..) — на два уровня выше.<br />▪ (...) — перехватывает сегменты начиная с корня app<br />"
    },
    {
      "question": "Почему ( .. ) работает по сегментам маршрута, а не по файловой системе?",
      "id": "q-32-a854280a",
      "answer": "▪ Потому что Next.js ориентируется на сегменты маршрутов, а не на структуру папок. Например, @slot в <b>Parallel Routes</b> не считается сегментом, поэтому относительность определяется только по route segments<br /><br />"
    },
    {
      "question": "Что такое <b>layout.js</b> и для чего он используется в Next.js?",
      "id": "q-33-46a1cf57",
      "answer": "▪ Layout — компонент, определяющий структуру интерфейса сегмента маршрута. Оборачивает дочерние сегменты и переиспользует общий UI<br />"
    },
    {
      "question": "Что такое root layout и чем он отличается от обычного layout?",
      "id": "q-34-b1feef93",
      "answer": "▪ Root layout — верхний layout в app/. Обязан содержать <html> и <body>, задаёт глобальный UI для всего приложения. Вложенные layouts применяются к своим сегментам.<br />"
    },
    {
      "question": "Какие пропсы получает layout и как их использовать?",
      "id": "q-35-4b5b6df4",
      "answer": "▪ children — обязательный, содержит дочерние сегменты.<br />▪ <b>params</b> — опциональный промис с динамическими параметрами от корневого сегмента до текущего layout.<br />"
    },
    {
      "question": "Как использовать <b>LayoutProps</b> для типизации layout?",
      "id": "q-36-4b7cf612",
      "answer": "▪ <b>LayoutProps</b> предоставляет типы для children, <b>params</b> и именованных слотов (@slot) на основе структуры директорий.<br />"
    },
    {
      "question": "Могут ли layouts перерендериваться при навигации и почему?",
      "id": "q-37-bc593dcc",
      "answer": "▪ Нет. Layouts сохраняются между переходами, чтобы избегать лишних запросов и вычислений; кэшируются на клиенте.<br />"
    },
    {
      "question": "Как layout может работать с данными?",
      "id": "q-38-e7a596fe",
      "answer": "▪ Может выполнять <b>fetch</b> и отображать данные внутри себя. Непосредственно передавать данные дочерним страницам нельзя. Запросы дочерних страниц дедуплицируются.<br />"
    },
    {
      "question": "Как layout работает с query <b>params</b> и pathname?",
      "id": "q-39-6c5bc046",
      "answer": "▪ Layouts не обновляются на навигации и не получают новые query <b>params</b> или pathname напрямую.<br />▪ Для работы используют <b>use</b>SearchParams и <b>use</b>Pathname в <b>Client Components</b>.<br />▪ Актуальное состояние обеспечивают дочерние страницы или клиентские компоненты внутри layout.<br />"
    },
    {
      "question": "Как layout может взаимодействовать с дочерними сегментами?",
      "id": "q-40-c19516d1",
      "answer": "▪ Прямого доступа нет. Для определения активного сегмента используют <b>use</b>SelectedLayoutSegment или <b>use</b>SelectedLayoutSegments в <b>Client Components</b>.<br />"
    },
    {
      "question": "Может ли layout быть клиентским (<b>CSR</b>)?",
      "id": "q-41-df66083b",
      "answer": "▪ Root layout — нет; должен быть серверным и содержать <html> и <body>.<br />▪ Вложенные layouts — да; можно сделать клиентскими с '<b>use client</b>'.<br />▪ Ограничения клиентского layout: нет доступа к <b>headers</b>()/<b>cookies</b>()/<b>draftMode</b>(), нельзя делать серверный <b>fetch</b>, увеличивается размер бандла и время гидратации.<br /><br />"
    },
    {
      "question": "Что такое <b>loading.js</b> и для чего он используется в Next.js?",
      "id": "q-42-9f597187",
      "answer": "▪ <b>loading.js</b> — это специальный файл, который позволяет создавать понятный Loading UI с использованием React <b>Suspense</b>. Он показывает мгновенное состояние загрузки (<b>instant loading state</b>) с сервера, пока контент сегмента маршрута подгружается, и автоматически заменяет его на основной контент после завершения загрузки.<br />"
    },
    {
      "question": "Где нужно размещать файл <b>loading.js</b> внутри маршрута?",
      "id": "q-43-1126c2ff",
      "answer": "▪ Файл <b>loading.js</b> размещается в папке сегмента маршрута, внутри которого вы хотите показать состояние загрузки<br />"
    },
    {
      "question": "Какой тип компонента по умолчанию имеет <b>loading.js</b> и можно ли его сделать Client Component?",
      "id": "q-44-381a8ef8",
      "answer": "▪ По умолчанию <b>loading.js</b> является Server Component, но его можно сделать Client Component, добавив директиву '<b>use client</b>' в начале файла<br />"
    },
    {
      "question": "Какие параметры принимает компонент <b>loading.js</b>?",
      "id": "q-45-4f75fea7",
      "answer": "▪ Компонент <b>loading.js</b> не принимает никаких параметров<br />"
    },
    {
      "question": "Что такое <b>instant loading state</b> и как его использовать?",
      "id": "q-46-493fc724",
      "answer": "▪ Instant loading state — это UI, который показывается мгновенно при навигации, например скелетоны, спиннеры или небольшая часть будущего экрана. Он помогает пользователю понять, что приложение отвечает, и улучшает UX. Для этого создается <b>loading.js</b> с легковесным интерфейсом загрузки внутри соответствующего сегмента<br />"
    },
    {
      "question": "Как <b>loading.js</b> взаимодействует с <b>layout.js</b> и <b>page.js</b> внутри сегмента маршрута?",
      "id": "q-47-2862900e",
      "answer": "▪ <b>loading.js</b> автоматически оборачивает <b>page.js</b> и всех его потомков внутри <<b>Suspense</b>> границы, если находится в одной папке с <b>layout.js</b>. То есть при загрузке нового сегмента UI <b>fallback</b> из <b>loading.js</b> показывается до полного рендеринга страницы<br />"
    },
    {
      "question": "Можно ли использовать <b>loading.js</b> при статическом экспорте сайта?",
      "id": "q-48-d8d37ac8",
      "answer": "▪ Нет, <b>loading.js</b> не поддерживается при статическом экспорте<br />"
    },
    {
      "question": "Как вручную создавать <b>Suspense</b> Boundaries для своих компонентов и как это соотносится с <b>loading.js</b>?",
      "id": "q-49-ab435f99",
      "answer": "▪ Можно вручную обернуть любой асинхронный компонент в <<b>Suspense</b> <b>fallback</b>={...}>. В этом случае <b>fallback</b> UI работает аналогично <b>loading.js</b>, показывая UI пока выполняется асинхронное действие<br />"
    },
    {
      "question": "Какие преимущества дает использование <b>Suspense</b> вместе с <b>loading.js</b>?",
      "id": "q-50-b9c0490b",
      "answer": "▪ <b>Streaming Server Rendering</b> — прогрессивный рендеринг HTML с сервера на клиент<br />▪ <b>Selective Hydration</b> — React делает интерактивными компоненты приоритетно, в зависимости от взаимодействия пользовател<br />▪ Автоматическое отображение <b>fallback</b> UI и плавная замена его на основной контент<br /><br />"
    },
    {
      "question": "Для чего используется файл <b>not-found.js</b> в Next.js?",
      "id": "q-51-c002c5cb",
      "answer": "▪ Он рендерит UI, когда внутри сегмента маршрута вызывается <b>notFound</b>(). Используется для обработки 404 на уровне конкретного сегмента.<br />"
    },
    {
      "question": "Чем отличается <b>not-found.js</b> от global-<b>not-found.js</b>?",
      "id": "q-52-937b2c78",
      "answer": "▪ <b>not-found.js</b> работает в пределах сегмента и зависит от маршрута.<br />▪ global-<b>not-found.js</b> используется для глобальной 404-страницы, если URL вообще не совпал ни с одним маршрутом.<br />"
    },
    {
      "question": "Какой статус код возвращает Next.js при использовании <b>not-found.js</b>?",
      "id": "q-53-41f8f347",
      "answer": "▪ Для стриминговых ответов → 200.<br />▪ Для нестриминговых → 404.<br />"
    },
    {
      "question": "В каких случаях стоит использовать global-<b>not-found.js</b>?",
      "id": "q-54-c4dfd39d",
      "answer": "▪ Когда в приложении есть несколько root layout'ов.<br />▪ Когда root layout определён с динамическими сегментами (например, app/[country]/<b>layout.js</b>).<br />"
    },
    {
      "question": "Почему global-<b>not-found.js</b> должен возвращать полный HTML-документ?",
      "id": "q-55-f645e7ed",
      "answer": "▪ Потому что он обходит обычный процесс рендеринга приложения, и Next.js ожидает полный HTML (с <html> и <body>).<br />"
    },
    {
      "question": "Какие props принимают компоненты <b>not-found.js</b> и global-<b>not-found.js</b>?",
      "id": "q-56-e7720d9a",
      "answer": "▪ Они не принимают никаких props<br />"
    },
    {
      "question": "Можно ли в <b>not-found.js</b> выполнять серверный <b>fetch</b>?",
      "id": "q-57-eb47c333",
      "answer": "▪ Да, он является серверным компонентом и может быть <b>async</b>. Можно, например, использовать <b>headers</b>() и загружать данные для отображения кастомного 404-UI<br />"
    },
    {
      "question": "Какие метаданные автоматически добавляет Next.js для страниц с 404?",
      "id": "q-58-45848d06",
      "answer": "▪ Автоматически вставляется <<b>meta</b> name=\"<b>robots</b>\" content=\"<b>noindex</b>\" />, чтобы такие страницы не индексировались поисковиками.<br /><br />"
    },
    {
      "question": "Для чего используется файл <b>page.js</b> в Next.js?",
      "id": "q-59-dde39a9f",
      "answer": "▪ Файл <b>page.js</b> используется для определения UI, уникального для маршрута. Это конечная точка (leaf) дерева маршрутов, которая делает сегмент публично доступным.<br />"
    },
    {
      "question": "Является ли <b>page.js</b> обязательным для того, чтобы сегмент маршрута был публично доступен?",
      "id": "q-60-9ff1e115",
      "answer": "▪ Да, без <b>page.js</b> сегмент маршрута не будет доступен пользователю напрямую.<br />"
    },
    {
      "question": "Что означает, что страница всегда является листом (leaf) дерева маршрутов?",
      "id": "q-61-f20a3c4e",
      "answer": "▪ Это значит, что страница (<b>page.js</b>) всегда находится на нижнем уровне маршрута — она не может иметь вложенных сегментов под собой Вложенные сегменты должны определяться выше.<br />"
    },
    {
      "question": "Какой компонент по умолчанию является <b>page.js</b> — серверным или клиентским? Можно ли его изменить?",
      "id": "q-62-a6d4a969",
      "answer": "▪ По умолчанию <b>page.js</b> — Server Component, но его можно сделать Client Component, добавив директиву \"<b>use client</b>\" в начале файла.<br />"
    },
    {
      "question": "Какие расширения файлов поддерживает Next.js для страниц?",
      "id": "q-63-bbdc1a60",
      "answer": "▪ Поддерживаются расширения: .js || .jsx || .tsx<br />"
    },
    {
      "question": "Какие props доступны в <b>page.js</b> и для чего они нужны?",
      "id": "q-64-e623282a",
      "answer": "▪ <b>params</b> — объект (<b>Promise</b>), содержащий динамические параметры маршрута ([slug], [id] и т.п.).<br />▪ <b>searchParams</b> — объект (<b>Promise</b>), содержащий параметры строки запроса (?a=1&b=2).<br />"
    },
    {
      "question": "В какой форме передаются <b>params</b> и <b>searchParams</b> в Next.js 15 и как они отличаются от версии 14?",
      "id": "q-65-bdbe8e78",
      "answer": "▪ В Next.js 15: <b>params</b> и <b>searchParams</b> передаются как <b>Promise</b>, их нужно обрабатывать через <b>await</b> или React <b>use</b>, В Next.js 14 и ниже: они были синхронными объектами<br />"
    },
    {
      "question": "Как получить значения из <b>params</b> и <b>searchParams</b> в серверном компоненте?",
      "id": "q-66-e363dea4",
      "answer": "▪ Использовать <b>async</b>/<b>await</b>:<br />"
    },
    {
      "question": "Как получить значения из <b>params</b> и <b>searchParams</b> в клиентском компоненте, где нельзя использовать <b>async</b>?",
      "id": "q-67-de1d0cec",
      "answer": "▪ В клиентском компоненте можно использовать React-хук <b>use</b> для чтения <b>Promise</b><br />"
    },
    {
      "question": "Что происходит при использовании <b>searchParams</b> в странице относительно рендера (статический или динамический)?",
      "id": "q-68-d20aaff5",
      "answer": "▪ Использование <b>searchParams</b> переводит страницу в динамический рендеринг на уровне запроса, так как их значения нельзя предсказать заранее.<br />"
    },
    {
      "question": "Чем отличается <b>searchParams</b> от стандартного объекта <b>URLSearchParams</b>?",
      "id": "q-69-2c55323c",
      "answer": "▪ <b>searchParams</b> — это обычный JS-объект ({ a: '1', b: '2' }), а не экземпляр <b>URLSearchParams</b>.<br />▪ Значения могут быть строкой или массивом строк (string | string[]).<br />"
    },
    {
      "question": "Что такое <b>PageProps</b> helper и зачем его использовать?",
      "id": "q-70-722858b0",
      "answer": "▪ <b>PageProps</b> — это глобально доступный TypeScript-хелпер, который позволяет типизировать <b>params</b> и <b>searchParams</b> на основе буквального маршрута, добавляет автодополнение ключей и строгую типизацию, автоматически генерируется при next dev, next build или next typegen.<br /><br />"
    },
    {
      "question": "Для чего нужны <b>Parallel Routes</b>?",
      "id": "q-71-15598bbc",
      "answer": "▪ Они позволяют одновременно или условно рендерить несколько страниц в одном layout. Это особенно полезно для динамических разделов, например, дашбордов или соцсетевых лент.<br />"
    },
    {
      "question": "Что такое слоты и как они создаются?",
      "id": "q-72-c501e785",
      "answer": "▪ Слоты — это именованные области внутри layout, создаваемые через папки с префиксом @. Например, @analytics или @team. Они передаются как пропсы в общий layout.<br />"
    },
    {
      "question": "Влияют ли слоты на URL?",
      "id": "q-73-e5c1ad62",
      "answer": "▪ Нет. Слоты не формируют часть маршрута. Например, app/@analytics/views будет доступен по адресу /views.<br />"
    },
    {
      "question": "Что такое implicit slot (children)?",
      "id": "q-74-4f7182df",
      "answer": "▪ children — это встроенный слот, который всегда присутствует. Файл app/<b>page.js</b> эквивалентен app/@children/<b>page.js</b>.<br />"
    },
    {
      "question": "Для чего используется <b>default.js</b>?",
      "id": "q-75-37be6e25",
      "answer": "▪ <b>default.js</b> задаёт контент по умолчанию для слота, если при загрузке страницы или обновлении браузера Next.js не может восстановить активное состояние слота. Если файла нет — будет показан 404.<br />"
    },
    {
      "text": "6. Soft navigation vs Hard navigation",
      "answer": [
        {
          "text": "▪ Soft navigation (клиентская навигация) сохраняет состояние всех слотов, меняя только активный.",
          "answer": []
        },
        {
          "text": "▪ Hard navigation (перезагрузка страницы) сбрасывает состояние, и для неподходящих слотов рендерится <b>default.js</b> или 404.",
          "answer": []
        }
      ]
    },
    {
      "question": "Зачем нужен parallelRoutesKey в <b>use</b>SelectedLayoutSegment(s)?",
      "id": "q-76-c28ec178",
      "answer": "▪ Он позволяет определить активный сегмент маршрута внутри конкретного слота. Например, чтобы узнать, открыт ли /login в @auth.<br />"
    },
    {
      "question": "Как использовать <b>Parallel Routes</b> для условного рендера?",
      "id": "q-77-1356a9eb",
      "answer": "▪ Можно отобразить разные слоты в зависимости от условий (например, роли пользователя: <b>use</b>r или admin).<br />"
    },
    {
      "question": "Что такое Tab Groups?",
      "id": "q-78-a3ee95fa",
      "answer": "▪ Это слоты с собственным layout, который позволяет пользователю переключаться между вложенными страницами, как между вкладками.<br />"
    },
    {
      "question": "Как <b>Parallel Routes</b> помогают реализовать модальные окна?",
      "id": "q-79-ec417df0",
      "answer": "▪ Они позволяют открыть модальное окно через слот и <b>Intercepting Routes</b>, сохранив корректный URL, deep linking и восстановление состояния после обновления страницы.<br />"
    },
    {
      "question": "Зачем нужен (.) в <b>Intercepting Routes</b>?",
      "id": "q-80-db42c876",
      "answer": "▪ (.) указывает на перехват маршрута внутри слота (intercepting route), позволяя рендерить, например, модалку поверх текущей страницы.<br />"
    },
    {
      "question": "Как закрывать модальное окно в <b>Parallel Routes</b>?",
      "id": "q-81-bdb55ee1",
      "answer": "▪ Через <b>router.back</b>(), через <b>Link</b> или подменяя слот компонентом, возвращающим null.<br />"
    },
    {
      "question": "Когда нужен catch-all слот ([...catchAll])?",
      "id": "q-82-9f1cdb7c",
      "answer": "▪ Когда нужно закрывать слот (например, модальное окно) при навигации на любые маршруты, которые не должны отображать его.<br />"
    },
    {
      "question": "Можно ли определить отдельные loading и error состояния для каждого слота?",
      "id": "q-83-c11653f2",
      "answer": "▪ Да. Каждый слот может иметь собственные <b>loading.js</b> и <b>error.js</b>, которые обрабатываются независимо.<br /><br />"
    },
    {
      "question": "Для чего используется папка <b>public</b> в Next.js?",
      "id": "q-84-d2a9b6c1",
      "answer": "▪ Для хранения статических файлов, которые нужно отдать напрямую без обработки.<br />"
    },
    {
      "question": "Как можно обратиться к файлу, находящемуся внутри <b>public</b>?",
      "id": "q-85-0a8201ce",
      "answer": "▪ По пути, начиная с /. Например, <b>public</b>/avatars/me.png доступен по адресу /avatars/me.png.<br />"
    },
    {
      "question": "Какой HTTP-заголовок кэширования применяется к файлам из <b>public</b> по умолчанию?",
      "id": "q-86-17c2dcac",
      "answer": "▪ <b>Cache-Control</b>: <b>public</b>, max-age=0<br />"
    },
    {
      "question": "Почему Next.js не кэширует файлы в <b>public</b> на длительное время?",
      "id": "q-87-7d89561a",
      "answer": "▪ Потому что содержимое файлов в <b>public</b> может изменяться, и Next.js не может безопасно гарантировать их долговременное кэширование.<br />"
    },
    {
      "question": "Где рекомендуется хранить статические метаданные (<b>robots.txt</b>, <b>fav</b>icon<b>.ico</b> и т.п.) в новых проектах Next.js?",
      "id": "q-88-1feca05e",
      "answer": "▪ Внутри специальных <b>meta</b>data-файлов в папке app, а не в <b>public</b><br /><br />"
    },
    {
      "question": "Что такое <b>Route Groups</b> в Next.js?",
      "id": "q-89-6ccf9c8a",
      "answer": "▪ Это соглашение для организации маршрутов в папки, которые не влияют на URL.<br />"
    },
    {
      "question": "Как создаётся группа маршрутов в файловой структуре?",
      "id": "q-90-5615111f",
      "answer": "▪ Папку нужно обернуть в скобки, например: (shop) или (marketing).<br />"
    },
    {
      "question": "Влияет ли название группы маршрутов (в скобках) на конечный URL?",
      "id": "q-91-492a4876",
      "answer": "▪ Нет, оно используется только для организации структуры и не попадает в путь<br />"
    },
    {
      "question": "Для чего обычно используют <b>Route Groups</b>?",
      "id": "q-92-34377641",
      "answer": "▪ для организации маршрутов по фичам или командам,<br />▪ для создания нескольких root layouts,<br />▪ разделить набор страниц по разным layout, не смешивая их<br />"
    },
    {
      "question": "Можно ли с помощью <b>Route Groups</b> определить несколько root layout?",
      "id": "q-93-95c244e6",
      "answer": "▪ Да, каждая группа может иметь свой собственный root layout.<br />"
    },
    {
      "question": "Что произойдёт при навигации между страницами, которые используют разные root layout?",
      "id": "q-94-9d8e507f",
      "answer": "▪ Это приведёт к полной перезагрузке страницы (full page reload).<br />"
    },
    {
      "question": "Какая проблема может возникнуть, если маршруты в разных группах разрешаются в один и тот же путь?",
      "id": "q-95-ae622b2f",
      "answer": "▪ Возникнет конфликт: разные файлы будут пытаться отрендерить один и тот же URL, что вызовет ошибку.<br />"
    },
    {
      "question": "Что нужно учитывать при использовании нескольких root layout и отсутствии общего top-level <b>layout.js</b>?",
      "id": "q-96-49e42d21",
      "answer": "▪ Нужно, чтобы маршрут / был определён хотя бы в одной из групп, например в app/(marketing)/<b>page.js</b>.<br /><br /><br />"
    },
    {
      "question": "Для чего используется папка <b>src</b> в Next.js и чем она удобна?",
      "id": "q-97-2bfdd57b",
      "answer": "▪ Папка <b>src</b> используется как альтернатива размещению специальных папок app или pages в корне проекта, она отделяет код приложения от конфигурационных файлов проекта, которые обычно находятся в корне.<br />"
    },
    {
      "question": "Какие специальные папки можно перенести в <b>src</b>?",
      "id": "q-98-01a66e63",
      "answer": "▪ /<b>src</b>/app || <b>src</b>/pages и другие папки с кодом приложения<br />"
    },
    {
      "question": "Можно ли использовать одновременно app или pages в корне и в <b>src</b>?",
      "id": "q-99-2ec0fb0c",
      "answer": "▪ Нет, <b>src</b>/app или <b>src</b>/pages будут проигнорированы, если app или pages присутствуют в корневой директории так как Next.js приоритизирует папки в корне проекта над папками в <b>src</b>.<br />"
    },
    {
      "question": "Где должна оставаться папка /<b>public</b>, если используется структура с <b>src</b>?",
      "id": "q-100-48ba6352",
      "answer": "▪ Папка /<b>public</b> должна оставаться в корне проекта.<br />"
    },
    {
      "question": "Какие файлы должны оставаться в корне проекта при использовании <b>src</b>?",
      "id": "q-101-1a8aff15",
      "answer": "▪ /<b>public</b> и конфигурационыне файлы<br /><br />"
    },
    {
      "question": "Что такое <b>template.js</b> и чем он отличается от <b>layout.js</b>?",
      "id": "q-102-fd79b2dd",
      "answer": "▪ <b>template.js</b> — это файл, похожий на <b>layout.js</b>, который оборачивает layout или page. В отличие от layouts, которые сохраняются между маршрутами и поддерживают состояние, templates получают уникальный ключ, что означает, что дочерние <b>Client Components</b> сбрасывают своё состояние при навигации.<br />"
    },
    {
      "question": "Для чего используется <b>template.js</b>?",
      "id": "q-103-ecada348",
      "answer": "▪ Для повторной синхронизации <b>use</b>Effect при навигации<br />▪ Для сброса состояния дочерних <b>Client Components</b> при навигации (например, поля ввода)<br />▪ Для изменения поведения фреймворка по умолчанию (например, <b>Suspense</b> boundaries в layouts показывают <b>fallback</b> только при первой загрузке, а в templates — при каждой навигации)<br />"
    },
    {
      "question": "Какой порядок рендеринга у <b>template.js</b> в иерархии компонентов?",
      "id": "q-104-8b0b7d05",
      "answer": "▪ <b>template.js</b> рендерится между layout и его дочерними элементами<br />▪ Структура: <Layout><Template key={routeParam}>{children}</Template></Layout><br />"
    },
    {
      "question": "Какие пропсы принимает <b>template.js</b>?",
      "id": "q-105-0ad085a3",
      "answer": "▪ children (обязательный) — дочерние элементы<br />"
    },
    {
      "question": "Какой тип компонента по умолчанию имеет <b>template.js</b>?",
      "id": "q-106-205ca13a",
      "answer": "▪ По умолчанию templates являются <b>Server Components</b><br />"
    },
    {
      "question": "Что происходит с <b>template.js</b> при навигации?",
      "id": "q-107-0288bac2",
      "answer": "▪ Templates получают уникальный ключ автоматически<br />▪ Переход на новый маршрут вызывает перемонтирование template и его дочерних элементов<br />"
    },
    {
      "question": "В чём основное отличие поведения <b>template.js</b> от <b>layout.js</b> при навигации?",
      "id": "q-108-420de4b4",
      "answer": "▪ Layouts сохраняются между маршрутами и поддерживают состояние<br />▪ Templates перемонтируются при каждой навигации и сбрасывают состояние<br />"
    },
    {
      "question": "Какие преимущества даёт использование <b>template.js</b> для сброса состояния?",
      "id": "q-109-ab4724f6",
      "answer": "▪ Автоматический сброс состояния всех <b>Client Components</b> внутри template<br />▪ Перезапуск <b>use</b>Effect при навигации<br />▪ Полное пересоздание DOM элементов<br />"
    },
    {
      "question": "Как <b>template.js</b> влияет на поведение <b>Suspense</b> boundaries?",
      "id": "q-110-41622773",
      "answer": "▪ <b>Suspense</b> boundaries внутри layouts показывают <b>fallback</b> только при первой загрузке<br />▪ <b>Suspense</b> boundaries внутри templates показывают <b>fallback</b> при каждой навигации<br />"
    },
    {
      "question": "Что означает \"уникальный ключ\" для <b>template.js</b>?",
      "id": "q-111-06a566b2",
      "answer": "▪ Next.js автоматически присваивает template уникальный ключ на основе параметров маршрута<br />▪ Это заставляет React перемонтировать компонент при изменении ключа<br />"
    },
    {
      "question": "Можно ли сделать <b>template.js</b> клиентским компонентом?",
      "id": "q-112-8dca327f",
      "answer": "▪ Да, можно добавить директиву '<b>use client</b>' в начало файла<br />"
    },
    {
      "question": "Как <b>template.js</b> влияет на DOM элементы при навигации?",
      "id": "q-113-07cfbaf8",
      "answer": "▪ DOM элементы внутри template полностью пересоздаются при навигации<br />"
    },
    {
      "question": "В каких случаях стоит использовать <b>template.js</b> вместо <b>layout.js</b>?",
      "id": "q-114-6e67d4c3",
      "answer": "▪ Когда нужно сбрасывать состояние форм при навигации<br />▪ Когда нужно перезапускать <b>use</b>Effect при каждой навигации<br />▪ Когда нужно изменить поведение <b>Suspense</b> boundaries<br />"
    },
    {
      "question": "Что происходит с <b>use</b>Effect в <b>Client Components</b> внутри <b>template.js</b> при навигации?",
      "id": "q-115-af6820dc",
      "answer": "▪ <b>use</b>Effect перезапускается, так как компонент перемонтируется<br />"
    },
    {
      "question": "Как <b>template.js</b> работает с <b>Server Components</b>?",
      "id": "q-116-6ed4d174",
      "answer": "▪ По умолчанию <b>template.js</b> является Server Component<br />▪ Может содержать <b>Server Components</b> внутри себя<br />"
    },
    {
      "question": "Можно ли использовать <b>template.js</b> и <b>layout.js</b> одновременно в одном сегменте?",
      "id": "q-117-4a0c37ac",
      "answer": "▪ Да, <b>template.js</b> рендерится между layout и его дочерними элементами<br />"
    },
    {
      "question": "Что происходит с состоянием формы в <b>template.js</b> при навигации?",
      "id": "q-118-2136f05b",
      "answer": "▪ Состояние формы полностью сбрасывается при навигации<br />"
    },
    {
      "question": "Как <b>template.js</b> влияет на производительность приложения?",
      "id": "q-119-964bb8a5",
      "answer": "▪ Может снижать производительность из-за постоянного перемонтирования компонентов<br />▪ Увеличивает количество рендеров при навигации<br />"
    },
    {
      "question": "Какие ограничения есть у <b>template.js</b> по сравнению с <b>layout.js</b>?",
      "id": "q-120-1e4852c7",
      "answer": "▪ Постоянное перемонтирование может быть нежелательным для производительности<br />▪ Не подходит для компонентов, которые должны сохранять состояние между навигациями<br /><br /><br /><br /><br /><br /><br />##### <b>favicon</b>, <b>icon</b>, and apple-<b>icon</b><br />##### <b>manifest.json</b><br />##### <b>opengraph-image</b> and <b>twitter-image</b><br />##### <b>robots.txt</b><br />##### <b>sitemap.xml</b>"
    }
  ]
}