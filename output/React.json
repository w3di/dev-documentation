{
  "items": [
    {
      "question": "Что такое Virtual DOM в React и зачем он нужен?",
      "id": "q-1-b0b274f0",
      "answer": "▪ Virtual DOM - это абстрактное представление UI в виде дерева обычных JavaScript-объектов, которые отражают структуру реального DOM. React использует его, чтобы оптимизировать и контролировать обновления интерфейса.<br />"
    },
    {
      "question": "Как работает Virtual DOM в React — от создания до обновления реального DOM?",
      "id": "q-2-187560b0",
      "answer": "▪ Компонент возвращает JSX которое затем превращается в дерево Virtual DOM<br />▪ При изменении состояния или пропсов React создаёт новое дерево VDOM<br />▪ React сравнивает новое и старое дерево (алгоритм diff)<br />▪ Вычисляется минимальный набор изменений (patch)<br />▪ Реальный DOM обновляется точечно, на основе diff-а<br />"
    },
    {
      "question": "Какие события в React приводят к пересозданию/обновлению Virtual DOM?",
      "id": "q-3-7f7b3b6f",
      "answer": "▪ Изменение props компонента<br />▪ Изменение контекста через <b>useContext</b><br />▪ Монтирование и размонтирование компонентов<br />▪ Изменение состояния через <b>useState</b> или <b>useReducer</b><br />▪ Любые изменения данных, влияющие на вывод JSX<br />"
    },
    {
      "question": "Где выполняется Virtual DOM в React (в какой среде/памяти)?",
      "id": "q-4-bb57318d",
      "answer": "▪ Virtual DOM работает в памяти JavaScript-движка, то есть в оперативной памяти (RAM) браузера, внутри JavaScript-окружения<br />"
    },
    {
      "question": "Из каких структур данных состоит Virtual DOM в React?",
      "id": "q-5-75a9bd12",
      "answer": "▪ Virtual DOM состоит из JavaScript-объектов, каждый из которых представляет один UI-элемент (аналог узла DOM)<br />"
    },
    {
      "question": "Почему Virtual DOM эффективнее прямых манипуляций с DOM?",
      "id": "q-6-b5296522",
      "answer": "▪ Прямые манипуляции с DOM вызывают дорогостоящие затраты браузера на layout/repaint<br />▪ Virtual DOM работает с UI в памяти<br />▪ Обновления происходят в памяти, что позволяет вычислять минимальный набор изменений (diffing) и применять их пакетно, снижая количество дорогостоящих операций с реальным DOM"
    },
    {
      "question": "Как работает алгоритм diffing в React при сравнении изменений в Virtual DOM и какова его сложность?",
      "id": "q-7-44c24bcb",
      "answer": "▪ React использует эффективный алгоритм diffing с линейной сложностью O(n)<br />▪ Сравнивает элементы сверху вниз и слева направо<br />▪ Если у элементов разный type (например, div и span или разные компоненты), React полностью заменяет соответствующее поддерево<br />▪ Если type совпадает, React сравнивает props и рекурсивно переходит к сравнению детей<br />▪ При сравнении детей React ориентируется на позицию элементов и key:<br />▪ Если ключи присутствуют, используется сопоставление по ним для эффективной обработки добавлений, удалений и перемещений<br />▪ Без ключей сравнение идёт по индексу, что менее эффективно и может привести к лишним обновлениям<br />"
    },
    {
      "question": "Что такое ключи (key) в React и как они влияют на сравнение элементов в списках?",
      "id": "q-8-3d4d0edb",
      "answer": "▪ Ключи (key) — это уникальные идентификаторы элементов списка, которые React использует для сопоставления элементов между старым и новым деревом<br />▪ Если ключи присутствуют, React сопоставляет элементы по ним, что позволяет эффективно выявлять добавленные, удалённые перемещённые элементы<br />▪ Без ключей React сравнивает элементы по их позиции (индексу) в массиве<br /><br />"
    },
    {
      "question": "Что такое архитектура React Fiber и чем она отличается от прежнего Stack Reconciler?",
      "id": "q-9-ece7a021",
      "answer": "▪ Прерываемость<br />▪ Приоритезация<br />▪ Инкрементальный рендеринг<br />"
    },
    {
      "question": "В чём недостатки старого синхронного reconciler'а по сравнению с React Fiber?",
      "id": "q-10-62c85081",
      "answer": "▪ Старый Virtual DOM работал синхронно и непрерываемо, что приводило к блокировкам UI при больших обновлениях<br />▪ Отсутствие приоритезации обновлений: все обновления обрабатывались с одинаковым приоритетом<br />▪ Нельзя было прервать, отложить или отменить рендеринг, что негативно влияло на отзывчивость интерфейса<br />▪ Отсутствие инкрементального (пошагового) рендеринга<br />▪ Отсутствие возможности прерывать и возобновлять рендеринг с учётом приоритетов<br />"
    },
    {
      "question": "Почему React Fiber использует связный список для обхода дерева, а не рекурсию?",
      "id": "q-11-ed6f34e5",
      "answer": "▪ Связный список позволяет React:<br />▪ Выполнять обход дерева итеративно, без глубокого рекурсивного стека, что снижает риск переполнения стека<br />▪ Прерывать и возобновлять рендеринг<br />▪ Управлять приоритетами задач и планировать работу по частям<br />▪ Рекурсия же требует полного прохода и не позволяет прерывать работу посередине"
    },
    {
      "question": "Как используется связный список узлов в React Fiber для обхода дерева?",
      "id": "q-12-f09f4268",
      "answer": "▪ это структура из объектов FiberNode, где каждый узел содержит ссылки:<br />▪ <b>child</b> — на первого потомка<br />▪ <b>sibling</b> — на следующего брата (соседа)<br />▪ <b>return</b> — на родителя<br />▪ Так можно пройти всё дерево последовательно, переходя от родителя к первому ребёнку, потом к соседям, обходя дерево без рекурсии<br />"
    },
    {
      "question": "Что такое FiberNode в React и как он устроен?",
      "id": "q-13-4ef99f0c",
      "answer": "▪ FiberNode — это объект, представляющий один узел дерева Fiber. Он содержит всю информацию, необходимую React для управления рендерингом и обновлением конкретного UI-элемента<br />"
    },
    {
      "question": "Какие ключевые поля содержит объект FiberNode и что каждое из них означает?",
      "id": "q-14-080607fe",
      "answer": "▪ <b>stateNode</b> — ссылка на реальный инстанс, связанный с этим узлом (DOM-элемент, экземпляр класса, или null для функциональных компонентов)<br />▪ <b>return</b> — ссылка на родительский FiberNode, позволяющая подниматься вверх по дереву<br />▪ <b>child</b> — ссылка на первый дочерний FiberNode, начало обхода детей<br />▪ <b>sibling</b> — ссылка на следующий соседний FiberNode на том же уровне<br />▪ <b>flags</b> — битовая маска, указывающая, какие операции (вставка, обновление, удаление) нужно выполнить с этим узлом"
    },
    {
      "question": "Как поля return, child и sibling в FiberNode обеспечивают безрекурсивный обход дерева Fiber?",
      "id": "q-15-56ce335b",
      "answer": "▪ Поле <b>child</b> позволяет спуститься вниз по дереву<br />▪ поле <b>sibling</b> — перейти к соседнему узлу на том же уровне<br />▪ поле <b>return</b> — подняться вверх к родителю после обхода всех детей<br />▪ Вместе они реализуют итеративный обход дерева, заменяющий рекурсию, что даёт контроль над процессом рендеринга и позволяет прерывать и возобновлять работу<br />"
    },
    {
      "question": "Какие бывают типы флагов (flags) в FiberNode и какие операции они обозначают?",
      "id": "q-16-a649447c",
      "answer": "▪ <b>flags</b> — это битовая маска, которая сообщает React, какие действия нужно выполнить над узлом на этапе commit. Основные флаги:<br />▪ <b>Placement</b> — узел нужно вставить в DOM (новый элемент)<br />▪ <b>Update</b> — узел нужно обновить (например, props или DOM-атрибуты)<br />▪ <b>Deletion</b> — узел нужно удалить из DOM<br />▪ <b>ChildDeletion</b> — удалить одного или нескольких потомков<br />▪ <b>Ref</b> — обновить ref<br />▪ <b>Passive</b> — выполнить эффекты <b>useEffect</b><br />"
    },
    {
      "question": "Что такое двойная буферизация (double buffering) в React Fiber и зачем она нужна?",
      "id": "q-17-bf072018",
      "answer": "▪ Двойная буферизация в Fiber — это хранение двух деревьев (current и working) для безопасного обновления UI без блокировок: изменения делают в рабочем дереве, а после завершения заменяют текущее<br /><br />"
    },
    {
      "question": "Что такое work loop в React Fiber и как он организует процесс рендеринга?",
      "id": "q-18-95a4382c",
      "answer": "▪ Work loop в React Fiber — это основной цикл, в котором React пошагово обходит дерево Fiber, создаёт/обновляет FiberNode'ы и готовит дерево к коммиту. Он лежит в основе инкрементального, прерываемого рендеринга<br />"
    },
    {
      "question": "Как связный список в React Fiber позволяет прерывать и возобновлять рендеринг?",
      "id": "q-19-f1a80c2c",
      "answer": "▪ обход дерева — это итеративный процесс с явным хранением текущей позиции, это позволяет просто сохранить состояние обхода (текущий узел), остановить цикл и освободить основной поток для других задач, при следующем вызове React продолжит обход с сохранённого узла, а не начинает заново или не уходит в глубокую рекурсию"
    },
    {
      "question": "Как обновляется UI в React Fiber: полный цикл от setState до отрисовки?",
      "id": "q-20-ba6caff7",
      "answer": "▪ Инициирование обновления<br />▪ создаётся объект обновления, который добавляется в очередь обновлений соответствующего FiberNode<br />▪ Приоритезация<br />▪ Обновление получает приоритет через систему Lanes<br />▪ Планирование задачи (Scheduler)<br />▪ Scheduler решает, когда запускать работу: сразу (высокий приоритет) или отложить (низкий)<br />▪ Render-фаза (Reconciliation) - эта фаза прерываема и инкрементальна, может быть приостановлена и возобновлена<br />▪ Создаётся новое дерево work-in-progress (рабочее дерево Fiber) на основе текущего<br />▪ React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов<br />▪ Завершение render-фазы<br />▪ После обхода дерева React формирует полный список эффектов для commit-фазы<br />▪ Commit-фаза (синхронная, непрерываемая)<br />▪ Фаза размонтирования эффектов<br />▪ Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала <b>useLayoutEffect</b> cleanup, потом <b>useEffect</b> cleanup<br />▪ Mutation этап<br />▪ React применяет изменения в DOM: удаление, вставка, обновление<br />▪ Выполняются функции <b>useLayoutEffect</b><br />▪ Выполняются функции <b>useEffect</b><br />▪ Обновление текущего дерева<br />▪ Рабочее дерево work-in-progress становится текущим (current), старое может быть удалено или повторно использовано"
    },
    {
      "question": "Какие фазы включает процесс обновления в React Fiber?",
      "id": "q-21-b5221d86",
      "answer": "▪ Reconciliation (render фаза) - Прерываемая и инкрементальная<br />▪ Commit фаза - Синхронная и непрерываемая<br />"
    },
    {
      "question": "Чем отличаются фазы в Fiber и какую роль они играют в обновлении UI?",
      "id": "q-22-ed85a604",
      "answer": "▪ Reconciliation (render фаза) - отвечает за подготовку и планирование изменений<br />▪ commit фаза - за их окончательное применение и взаимодействие с DOM<br />"
    },
    {
      "question": "Что происходит в React в фазе Render (reconciliation)?",
      "id": "q-23-6c042511",
      "answer": "▪ Создаётся новое дерево work-in-progress на основе текущего<br />▪ React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов<br />▪ После обхода дерева React формирует полный список эффектов для commit-фазы<br />▪ Фаза может быть прервана и возобновлена, чтобы избежать блокировки основного потока<br />"
    },
    {
      "question": "Что происходит в React в фазе Commit?",
      "id": "q-24-f6710916",
      "answer": "▪ Фаза размонтирования эффектов<br />▪ Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала <b>useLayoutEffect</b> cleanup, потом <b>useEffect</b> cleanup<br />▪ Mutation этап<br />▪ React применяет изменения в DOM: удаление, вставка, обновление<br />▪ Выполняются функции <b>useLayoutEffect</b><br />▪ Выполняются функции <b>useEffect</b><br />▪ Commit-фаза не прерывается, чтобы гарантировать консистентность DOM"
    },
    {
      "question": "Что такое Effect List в React Fiber и для чего он используется?",
      "id": "q-25-33274795",
      "answer": "▪ это связанный список узлов Fiber с помеченными изменениями, которые React последовательно применяет к DOM и запускает соответствующие эффекты в фазе commit<br />"
    },
    {
      "question": "Как в React формируется и используется Effect List?",
      "id": "q-26-8b0cbcd0",
      "answer": "▪ Во время render-фазы React при обходе work-in-progress дерева помечает каждый FiberNode с изменениями специальными флагами<br />▪ Эти помеченные узлы собираются в Effect List — связанный список эффектов, которые нужно применить<br />▪ В commit-фазе React последовательно проходит по Effect List и выполняет соответствующие операции<br /><br />"
    },
    {
      "question": "Как работает система приоритетов в React Fiber и как она влияет на рендеринг?",
      "id": "q-27-7ec5e92a",
      "answer": "▪ Каждое обновление получает приоритет — через механизм Lanes<br />▪ React сначала обрабатывает более приоритетные задачи (например, ввод), менее важные — откладывает<br />"
    },
    {
      "question": "Что такое модель приоритетов Lane в React и как она работает?",
      "id": "q-28-f5c362b3",
      "answer": "▪ Lane-модель — система приоритизации обновлений в React Fiber, где каждое обновление относится к одной или нескольким lanes — битовым флагам разного приоритета<br />"
    },
    {
      "question": "Какие типы (lanes) существуют (<b>SyncLane</b>, <b>InputContinuousLane</b>, <b>DefaultLane</b> и др.)?",
      "id": "q-29-c1362d8a",
      "answer": "▪ <b>SyncLane</b> — максимальный приоритет, обновления должны выполниться сразу (например, <b>flushSync</b>)<br />▪ <b>InputContinuousLane</b> — приоритет интерактивного ввода, чтобы UI был отзывчивым<br />▪ <b>DefaultLane</b> — обычные фоновые обновления<br />"
    },
    {
      "question": "Что такое Scheduler в React и за что он отвечает?",
      "id": "q-30-77af447b",
      "answer": "▪ Это планировщик задач React, который решает, когда и с каким приоритетом запускать работу по обновлению UI. Он координирует выполнение render-фазы, позволяя прерывать низкоприоритетные задачи ради более важных"
    },
    {
      "question": "Как Scheduler в React выбирает приоритет задач?",
      "id": "q-31-b45a78c1",
      "answer": "▪ Scheduler использует lanes и сопоставляет их с уровнями приоритетов<br />▪ Задачи с более высоким приоритетом прерывают текущие и запускаются раньше<br />"
    },
    {
      "question": "Что делает <b>flushSync</b> и как он обходит приоритезацию?",
      "id": "q-32-f97c2579",
      "answer": "▪ <b>flushSync</b> — функция, которая запускает обновление синхронно, игнорируя систему приоритетов и асинхронность Scheduler. Она принудительно выполняет render и commit сразу, чтобы обновление UI произошло немедленно"
    },
    {
      "question": "Что такое конкурентный рендеринг (Concurrent Features) в React и чем он отличается от синхронного?",
      "id": "q-33-39b17b62",
      "answer": "▪ Concurrent Mode - новый способ работы React с рендерингом, при котором React не блокирует основной поток на долгое время, а разбивает работу на небольшие части (инкрементальный рендеринг)<br />▪ Позволяет React приостанавливать, возобновлять и приоритезировать работу по обновлению интерфейса<br />"
    },
    {
      "question": "Что такое time slicing в React и зачем он нужен?",
      "id": "q-34-ff15ddef",
      "answer": "▪ механизм в React Fiber, который разбивает работу по рендерингу на небольшие части. React выполняет эти части по очереди, прерываясь по тайм-ауту, чтобы дать браузеру возможность обрабатывать пользовательские события и другие задачи<br />▪ Time slicing реализуется за счёт итеративного обхода дерева Fiber с сохранением состояния, чтобы при возобновлении рендеринга продолжить с того места, где остановились"
    },
    {
      "question": "Как React прерывает и возобновляет рендеринг (time slicing)?",
      "id": "q-35-227a3dd8",
      "answer": "▪ React разбивает работу рендера на небольшие задачи — единицы работы (units of work)<br />▪ При достижении лимита времени текущая задача прерывается, текущее состояние обхода (nextUnitOfWork) сохраняется<br />▪ В следующий момент React возобновляет обход с сохранённой позиции, позволяя браузеру обрабатывать важные события между этими фрагментами работы<br />"
    },
    {
      "question": "Как React Suspense использует механизм прерывания рендера?",
      "id": "q-36-a7fafa3b",
      "answer": "▪ Suspense позволяет React прервать рендеринг компонента, если он «зависает» на асинхронной операции (например, загрузке данных или кода)<br />▪ React отменяет текущую работу по рендеру, показывает fallback UI, а затем возобновляет рендеринг, когда асинхронная операция завершена<br /><br />"
    },
    {
      "question": "Как в React работает гидратация (hydration) после серверного рендеринга (SSR)?",
      "id": "q-37-d6f8e043",
      "answer": "▪ Сервер присылает готовую страницу с уже заполненным HTML<br />▪ Браузер показывает этот HTML — пользователь сразу видит контент, даже если JS ещё не загрузился<br />▪ После загрузки JS React берёт этот HTML и «подключает» к нему свою логику: навешивает обработчики событий, создаёт внутренние структуры для управления состоянием<br />▪ React не рисует заново весь UI, а работает поверх уже существующего DOM, делая его интерактивным<br />"
    },
    {
      "question": "Что такое selective hydration в React и как она ускоряет загрузку?",
      "id": "q-38-23528a87",
      "answer": "▪ Selective hydration — это стратегия, при которой React не гидратирует сразу всё дерево, а по частям и с приоритетом. Например, сначала гидратируются видимые пользователю интерактивные части, а остальные — позже или при взаимодействии"
    },
    {
      "question": "Что такое React Server Components и чем они отличаются от клиентских?",
      "id": "q-39-e7b0baf1",
      "answer": "▪ Server Components — это React-компоненты, которые рендерятся только на сервере. Они не попадают в клиентский бандл, не запускают JS в браузере и позволяют значительно уменьшить размер кода на клиенте. Серверные компоненты могут напрямую обращаться к базе данных или файловой системе и отправлять готовый HTML, облегчая загрузку и повышая производительность<br />"
    },
    {
      "question": "Что такое серверные функции (Server Actions) в React и когда их использовать?",
      "id": "q-40-0f4dde82",
      "answer": "▪ Серверные функции (Server Actions) — это функции, которые выполняются на сервере по вызову из React-компонента. Они могут обрабатывать данные, выполнять бизнес-логику или работать с API, при этом не отправляя клиенту лишний JavaScript<br />"
    },
    {
      "question": "Что означает директива <b>use client</b> в React и когда её использовать?",
      "id": "q-41-38a262f3",
      "answer": "▪ строчка в начале файла которая указывает, что компонент должен рендериться и работать на клиенте<br />"
    },
    {
      "question": "Что означает директива <b>use server</b> в React и когда её использовать?",
      "id": "q-42-96348ae8",
      "answer": "▪ строчка в начале файла указывает, что функция или компонент выполняется только на сервере"
    },
    {
      "question": "Что можно делать в серверных компонентах React, чего нельзя в клиентских?",
      "id": "q-43-7ea9e5d4",
      "answer": "▪ доступ к базе данных, файловой системе, секретам<br />▪ использовать серверные зависимости (например, fs, pg, bcrypt)<br />"
    },
    {
      "question": "Что можно делать в клиентских компонентах React, чего нельзя в серверных?",
      "id": "q-44-91739fe1",
      "answer": "▪ использовать:<br />▪ браузерные API<br />▪ Хуки react<br />▪ обработчики событий<br />▪ манипулировать с DOM"
    },
    {
      "question": "Что такое Streaming SSR в React и как он работает?",
      "id": "q-45-c2f31fb2",
      "answer": "▪ Streaming SSR — это возможность React отдавать HTML по мере готовности дерева пока React рендерит все по частям<br />▪ Работает через <b>renderToPipeableStream</b> (Node.js) или <b>renderToReadableStream</b> (Edge/Cloud)<br />"
    },
    {
      "question": "Что такое hydration mismatch в React и почему он возникает?",
      "id": "q-46-41be3129",
      "answer": "▪ Hydration mismatch — это ситуация, когда HTML, пришедший с сервера (SSR) не совпадает с тем, что React \"ожидает\" при клиентской гидратации"
    },
    {
      "question": "Как избежать hydration mismatch в приложениях React с SSR?",
      "id": "q-47-26fa4518",
      "answer": "▪ Соблюдать одинаковую логику рендера на сервере и клиенте:<br />▪ не использовать случайные значения (<b>Math.random()</b>, <b>Date.now()</b>)<br />▪ <b>window</b>, <b>document</b> и любые browser-only API<br />▪ Использовать <b>useEffect</b>, а не <b>useLayoutEffect</b> для client-only логики"
    },
    {
      "question": "Почему важно, чтобы SSR и клиентский рендер в React генерировали одинаковый DOM?",
      "id": "q-48-79170f2b",
      "answer": "▪ React при гидратации подключается к существующему серверному HTML и ожидает, что структура совпадёт. Если DOM не совпадает — происходит hydration mismatch, React показывает предупреждения и может перерисовать большие участки UI<br />"
    },
    {
      "question": "Что происходит на клиенте при hydration mismatch в React?",
      "id": "q-49-cc9bb7fe",
      "answer": "▪ React покажет warning, а иногда — перерисует весь DOM узел<br />"
    },
    {
      "question": "Как <b>useLayoutEffect</b> может повлиять на гидратацию (hydration) после SSR в React?",
      "id": "q-50-fa7720ce",
      "answer": "▪ <b>useLayoutEffect</b> выполняется до отрисовки, только на клиенте — и может синхронно изменить DOM, не совпадающий с HTML от сервера, что приводит к hydration mismatch"
    },
    {
      "question": "Как SSR в React помогает уменьшить Time to First Byte (TTFB)?",
      "id": "q-51-0959b8ca",
      "answer": "▪ SSR позволяет серверу сразу отправить полностью сформированный HTML, благодаря чему браузер начинает отображать контент сразу после получения первого байта без задержек на загрузку и выполнение JS<br />"
    },
    {
      "question": "Как в React/Next.js избежать отправки лишнего JavaScript на клиент?",
      "id": "q-52-4f8fa5e5",
      "answer": "▪ Использовать Server Components, которые рендерятся только на сервере и не попадают в клиентский бандл<br />▪ Применять <b>use client</b> директиву строго там, где нужна интерактивность<br />▪ Делать код-сплиттинг и динамический импорт для загрузки JS только при необходимости<br />▪ Минимизировать зависимости и не импортировать клиентские библиотеки в серверные компоненты<br />▪ Использовать selective hydration, чтобы загружать JS по частям и с приоритетом"
    },
    {
      "question": "Как работают Suspense и ленивая загрузка серверных данных и компонентов в React/Next.js?",
      "id": "q-53-ee873845",
      "answer": "▪ Серверные компоненты могут использовать асинхронные функции (например, <b>await fetch()</b>) прямо внутри тела компонента. React ждёт их завершения или отдаёт fallback, обеспечивая эффективный ленивый рендеринг и загрузку<br />▪ После загрузки данных React «дозаписывает» оставшийся HTML по стриму (Streaming SSR), обеспечивая эффективный ленивый рендеринг и быструю первую отрисовку<br />▪ На клиенте Suspense переключается между fallback и готовым UI по мере завершения загрузки, поддерживая плавный переход<br />"
    },
    {
      "question": "Какие хуки доступны в React Server Components?",
      "id": "q-54-00848328",
      "answer": "▪ <b>useId</b> - Генерация стабильных ID<br /><br />"
    },
    {
      "question": "Как React избегает лишних ререндеров?",
      "id": "q-55-806179fc",
      "answer": "▪ Virtual DOM и сравнение (reconciliation)<br />▪ Мемоизация с <b>React.memo</b><br />▪ Хуки <b>useMemo</b> и <b>useCallback</b><br />▪ Контроль ключей (key) в списках<br />"
    },
    {
      "question": "Как работает batching обновлений состояния в React?",
      "id": "q-56-ee1cbb95",
      "answer": "▪ это механизм объединения нескольких обновлений состояния (state updates) в один цикл рендера<br />▪ внутри обработчика вызывается несколько setState или обновлений, React объединяет (batch) их и выполняет один рендер после завершения обработчика<br />"
    },
    {
      "question": "Как Fiber улучшает отзывчивость UI (например, при анимациях)?",
      "id": "q-57-75475dba",
      "answer": "▪ Приоритизация обновлений<br />▪ Прерываемость рендера<br />▪ благодаря time slicing и прерывистому рендеру, браузер может своевременно обновлять кадры анимаций и избегать \"фризов\"<br /><br />"
    },
    {
      "question": "Как архитектура React Fiber учитывает асинхронные операции при обновлении UI?",
      "id": "q-58-fe12dbcb",
      "answer": "▪ Fiber сам по себе не выполняет асинхронные операции, но он управляет их результатами и обновлением UI с учётом приоритетов<br />"
    },
    {
      "question": "Как работает Suspense для данных в React?",
      "id": "q-59-8c144f49",
      "answer": "▪ Suspense для данных приостанавливает рендер компонента, если данные ещё не готовы, бросая Promise. React показывает fallback UI, пока Promise не разрешится, после чего рендер возобновляется с готовыми данными"
    },
    {
      "question": "Что такое API <b>use()</b> в React и для чего оно нужно?",
      "id": "q-60-8f88a6de",
      "answer": "▪ <b>use()</b> — это React API для чтения значения ресурса, такого как Promise или контекст<br />"
    },
    {
      "question": "Для чего нужен <b>use()</b> в React и какие ресурсы он читает?",
      "id": "q-61-93ad2edd",
      "answer": "▪ Чтобы \"подписаться\" на Promise или контекст и получить их значение, интегрируясь с Suspense и Error Boundaries<br />"
    },
    {
      "question": "Как работает <b>use()</b> с Promise и контекстом в React?",
      "id": "q-62-abbaa735",
      "answer": "▪ Если передан Promise, React \"приостанавливает\" рендер компонента до его разрешения (Suspense fallback показывается)<br />▪ Если Promise отклонён — срабатывает ближайший Error Boundary<br />▪ Если передан контекст — <b>use()</b> возвращает его значение, как <b>useContext</b>, но может использоваться в условных и циклах"
    },
    {
      "question": "Где доступен <b>use()</b> в React (SSR или CSR) и когда его применять?",
      "id": "q-63-9c9e19c5",
      "answer": "▪ Работает и на сервере, и на клиенте, но преимущественно используется для чтения ресурсов в Client Components<br />"
    },
    {
      "question": "Как новый хук <b>use()</b> взаимодействует с Fiber?",
      "id": "q-64-5af72946",
      "answer": "▪ <b>use()</b> интегрируется с механизмом Suspense в Fiber: при ожидании Promise Fiber приостанавливает рендер и переключается на fallback, а после разрешения возобновляет рендер с полученными данными<br />"
    },
    {
      "question": "Как использовать <b>use()</b> для чтения контекста вместо <b>useContext</b>?",
      "id": "q-65-200105a0",
      "answer": "▪ Использование <b>use</b> с контекстом способ читать значение контекста, аналогичный <b>useContext</b>, но с преимуществом возможности вызывать <b>use</b> внутри условных блоков и циклов<br />"
    },
    {
      "question": "Почему нельзя просто await в Client Components вместо <b>use()</b>?",
      "id": "q-66-214710df",
      "answer": "▪ <b>await</b> нельзя использовать напрямую в теле функционального компонента — он синхронный и блокирует. <b>use()</b> позволяет React управлять состоянием ожидания асинхронного результата в рамках Fiber и Suspense<br /><br />"
    },
    {
      "question": "В чём разница между <b>useLayoutEffect</b> и <b>useEffect</b> с точки зрения Fiber?",
      "id": "q-67-e8e5e792",
      "answer": "▪ <b>useLayoutEffect</b> — синхронный, блокирующий эффект, полезен для измерений DOM и синхронных манипуляций. выполняется в phase commit, после того, как React применил изменения к DOM, но до того, как браузер обновил экран<br />▪ <b>useEffect</b> — асинхронный, неблокирующий, выполняется после отрисовки, оптимален для сетевых запросов, подписок и не критичных к времени операций. выполняется после фазы commit и после того, как браузер отрисовал обновлённый UI"
    },
    {
      "question": "Как React делит работу на чанки и приостанавливает рендеринг для более важных задач?",
      "id": "q-68-c5d18a6b",
      "answer": "▪ React Fiber разбивает работу рендеринга на небольшие части (чанки). При этом рендеринг приостанавливается (interruptible rendering), если появляется задача с более высоким приоритетом (например, пользовательский ввод)<br />"
    },
    {
      "question": "Как React обрабатывает \"зависшие\" компоненты (например, при загрузке данных)?",
      "id": "q-69-6302a678",
      "answer": "▪ При загрузке данных, если компонент возвращает Promise, React приостанавливает его рендеринг, показывая запасной UI (fallback) через Suspense. Когда данные загружены, React продолжает рендеринг компонента с этими данными<br />"
    },
    {
      "question": "Что такое Selective Hydration в React на клиенте?",
      "id": "q-70-3ae298cd",
      "answer": "▪ Selective Hydration — это техника, при которой React при гидратации на клиенте сначала гидратирует только самые важные или видимые части UI, а остальные части гидратируются позже, по мере необходимости"
    },
    {
      "question": "В чём разница между срочными (urgent) и отложенными (non-urgent) обновлениями в React, и как это связано с приоритетами Scheduler?",
      "id": "q-71-350a33fa",
      "answer": "▪ Срочные (urgent) обновления — это события с высоким приоритетом, как ввод пользователя или клики, которые React должен обработать немедленно<br />▪ Отложенные (non-urgent) обновления — менее важные задачи, например, обновление неактивных компонентов, которые можно выполнить позже<br />▪ Scheduler React управляет этими приоритетами, позволяя прерывать низкоприоритетные задачи для срочных, поддерживая отзывчивость UI<br />"
    },
    {
      "question": "Что такое interruptible rendering в React и зачем он нужен?",
      "id": "q-72-fde2239d",
      "answer": "▪ Interruptible rendering — возможность React прерывать текущий процесс рендеринга в любой момент, чтобы переключиться на более приоритетную работу, а затем продолжать с места остановки"
    },
    {
      "question": "Почему React Server Components не имеют состояния и хуков?",
      "id": "q-73-381518aa",
      "answer": "▪ Server Components рендерятся на сервере и не имеют жизненного цикла или интерактивности, поэтому состояние и хуки им не нужны<br />"
    },
    {
      "question": "Как React Server Components уменьшают размер клиентского бандла?",
      "id": "q-74-9ef21670",
      "answer": "▪ Server Components не включаются в клиентский бандл JavaScript — они полностью рендерятся на сервере и передают клиенту уже готовый HTML<br />"
    },
    {
      "question": "Как работают <b>React.lazy</b> и Suspense для динамического импорта компонентов?",
      "id": "q-75-521e1b2f",
      "answer": "▪ <b>React.lazy</b> динамически импортирует компонент (через <b>import()</b>), возвращая промис<br />▪ Пока компонент загружается — Suspense показывает fallback UI<br />▪ После загрузки компонент рендерится как обычно"
    },
    {
      "question": "Какие варианты fallback UI поддерживает React Suspense и как работает вложенность?",
      "id": "q-76-1b3945af",
      "answer": "▪ Fallback — любой React-элемент, показываемый во время загрузки<br />▪ Вложенные Suspense показывают самый близкий fallback для загрузки в своей области<br />"
    },
    {
      "question": "Какие основные этапы монтирования, обновления и размонтирования компонентов в функциональном React?",
      "id": "q-77-9f380ba2",
      "answer": "▪ Монтирование: рендер + запуск эффектов с пустым массивом зависимостей (<b>useEffect(() => {}, [])</b>)<br />▪ Обновление: повторный рендер + эффекты с изменившимися зависимостями<br />▪ Размонтирование: вызов очисток эффектов (функций, возвращаемых из <b>useEffect</b>)<br />"
    },
    {
      "question": "Как компоненты ведут себя в разных режимах рендера (синхронном и конкурентном)?",
      "id": "q-78-06a6f284",
      "answer": "▪ Sync: рендер блокирует UI до конца<br />▪ Concurrent: рендер можно приостанавливать, приоритеты обновлений<br /><br />"
    },
    {
      "question": "Как реализуется однонаправленный поток данных в React?",
      "id": "q-79-b46b3540",
      "answer": "▪ Однонаправленный поток данных в React означает, что данные всегда идут сверху вниз — от родительских компонентов к дочерним через props<br />▪ Родитель хранит состояние и передаёт его дочерним, которые могут только читать эти props, но не менять их напрямую. Изменения состояния происходят в родителе через коллбэки, переданные вниз<br />"
    },
    {
      "question": "Что такое \"lifting state up\" и как его правильно использовать?",
      "id": "q-80-dfeff5ef",
      "answer": "▪ это когда состояние, нужное нескольким компонентам, поднимается к их ближайшему общему родителю. Вместо того чтобы каждый компонент держал своё локальное состояние и пытался синхронизировать его, состояние централизуется в одном компоненте-родителе, а дочерним передаются через props и коллбэки для изменения<br />"
    },
    {
      "question": "В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?",
      "id": "q-81-2330f760",
      "answer": "▪ Контролируемые компоненты — это компоненты, где состояние формы полностью управляется React через state и обновляется через обработчики (<b>onChange</b>). Значение поля всегда берётся из состояния, а не из DOM<br />▪ Неконтролируемые компоненты — это компоненты, где состояние формы хранится непосредственно в DOM, а React лишь получает доступ через ref. React не управляет значением, а читает его при необходимости<br />▪ Контролируемые компоненты позволяют сразу валидировать, управлять вводом, делать условный рендер элементов формы<br /><br />"
    },
    {
      "question": "Как и зачем применять <b>React.Fragment</b>?",
      "id": "q-82-82799e82",
      "answer": "▪ Позволяет сгруппировать несколько элементов без добавления лишнего DOM-узла<br />"
    },
    {
      "question": "Когда и как правильно использовать порталы в React?",
      "id": "q-83-ee5e6166",
      "answer": "▪ Используйте порталы, когда UI-элемент должен визуально выходить за пределы текущей иерархии DOM — например, модальные окна, тултипы, всплывающие меню, уведомления<br />"
    },
    {
      "question": "Как работает <b>ReactDOM.createPortal</b> и как он участвует в Fiber-дереве?",
      "id": "q-84-a66795c2",
      "answer": "▪ <b>ReactDOM.createPortal</b> рендерит элемент в другой DOM-узел, но оставляет его частью того же Fiber-дерева. Компонент внутри портала получает контексты, участвует в рендеринге, Suspense, ErrorBoundary и сохраняет порядок событий"
    },
    {
      "question": "Как ведёт себя React при вложенных Suspense и цепочках fallback (suspense cascade)?",
      "id": "q-85-04243abf",
      "answer": "▪ При вложенных Suspense, React строит цепочку fallback'ов: если inner Suspense переходит в состояние ожидания (suspend), React показывает его fallback<br />▪ Если fallback-контент тоже вызывает suspend (например, ленивый компонент или async server компонент), React поднимается к ближайшему родительскому Suspense выше по компонентному дереву (не по DOM) и рендерит уже его fallback. Этот процесс продолжается вверх, пока не найдётся fallback, который можно отрендерить синхронно<br />▪ Это называется suspense cascade — поведение предсказуемо, и важно, что цепочка строится по дереву компонентов, а не по DOM<br />"
    },
    {
      "question": "Какие особенности управления событиями и фокусом возникают при работе с порталами?",
      "id": "q-86-34f685d0",
      "answer": "▪ События всплывают по React-дереву, а не по DOM — обработчики работают как обычно, несмотря на другой DOM-узел<br />▪ Фокусом нужно управлять вручную: при открытии модалки ставить фокус в портал, при закрытии — возвращать на исходный элемент"
    },
    {
      "question": "Какие аргументы принимает <b>ReactDOM.createPortal</b>?",
      "id": "q-87-cb333264",
      "answer": "▪ <b>children</b> — React-элементы, которые нужно отрендерить (JSX, компоненты, строки, фрагменты и т.п.)<br />▪ <b>domNode</b> — DOM-узел, куда будет помещён этот контент. Этот узел должен уже существовать в DOM<br />▪ <b>key</b> (опционально) — уникальный ключ (строка или число) для идентификации портала, особенно при рендере списков порталов<br />"
    },
    {
      "question": "Какие стандартные атрибуты и API React помогают создавать доступный UI?",
      "id": "q-88-220948eb",
      "answer": "▪ <b>aria-</b> (<b>aria-label</b>, <b>aria-labelledby</b>, <b>aria-describedby</b>, <b>aria-hidden</b>) для описания элементов для скринридеров<br />▪ <b>tabIndex</b> - для настройки порядка табуляции и возможности фокусировки"
    },
    {
      "question": "Как правильно реализовать контролируемые и неконтролируемые компоненты форм?",
      "id": "q-89-c4758ede",
      "answer": "▪ Контролируемые компоненты: значение хранится в состоянии (<b>useState</b>), обновляется через <b>onChange</b>. React полностью управляет вводом<br />▪ Неконтролируемые компоненты: значение хранится в DOM, доступ через ref. React не управляет вводом напрямую<br />"
    },
    {
      "question": "Как в React обрабатывать события <b>onChange</b> и <b>onSubmit</b> в формах?",
      "id": "q-90-6b2f6a86",
      "answer": "▪ <b>onChange</b>: обновляет состояние для контролируемых компонентов<br />▪ <b>onSubmit</b>: отменяет стандартное поведение и обрабатывает данные из состояния или ref"
    },
    {
      "question": "Как сделать простую валидацию без сторонних библиотек?",
      "id": "q-91-e0eac400",
      "answer": "▪ выполняется прямо в обработчике <b>onSubmit</b> или <b>onChange</b> — проверяем значения на нужные условия с сохранением ошибок в состоянии<br />▪ HTML-атрибуты валидации <b>required</b>, <b>minLength</b>, <b>pattern</b><br />"
    },
    {
      "question": "Как реализовать анимации с помощью CSS в React-приложении?",
      "id": "q-92-06c665f7",
      "answer": "▪ Создаёшь CSS-классы с <b>transition</b> (для плавных переходов свойств) или <b>@keyframes</b> (для сложных анимаций)"
    },
    {
      "question": "Как работает система SyntheticEvent в React?",
      "id": "q-93-ffa3530b",
      "answer": "▪ SyntheticEvent — это обёртка над нативными событиями браузера, которую React создаёт для обеспечения кроссбраузерного и одинакового API при работе с событиями<br />"
    },
    {
      "question": "В чём основные отличия между Synthetic Events и нативными событиями браузера?",
      "id": "q-94-00ba0ec0",
      "answer": "▪ Кроссбраузерность<br />▪ SyntheticEvent предоставляет единый интерфейс, который одинаково работает во всех браузерах. Нативные события могут иметь отличия в свойствах и поведении между браузерами<br />▪ Поведение всплытия<br />▪ События в React всплывают по React-иерархии компонентов, даже если DOM-структура другая (например, при использовании createPortal). Нативные события всплывают по DOM-дереву<br />▪ Совместимость с React API<br />▪ Только SyntheticEvent работает корректно с системой приоритетов событий в concurrent режиме. Нативные события об этом \"не знают\"<br />▪ API одинаково везде<br />▪ У SyntheticEvent всегда есть стандартные свойства (<b>type</b>, <b>target</b>, <b>currentTarget</b>, <b>preventDefault()</b>, <b>stopPropagation()</b> и т.п.), даже если браузер этого не поддерживает напрямую"
    },
    {
      "question": "Как ведёт себя React Strict Mode в режиме разработки и зачем он нужен?",
      "id": "q-95-76f6f896",
      "answer": "▪ В Strict Mode компоненты и хуки специально монтируются, размонтируются и монтируются заново в режиме разработки. Это имитация двойного вызова жизненных циклов для выявления побочных эффектов<br />"
    },
    {
      "question": "Почему компоненты и хуки вызываются повторно в Strict Mode?",
      "id": "q-96-814b003e",
      "answer": "▪ React повторно вызывает функции компонентов и эффекты, чтобы проверить, правильно ли они чистят ресурсы и не вызывают неожиданных сайд-эффектов при монтировании/размонтировании<br />"
    },
    {
      "question": "Как Strict Mode помогает улучшить качество кода и отловить ошибки?",
      "id": "q-97-662fe0b3",
      "answer": "▪ Такая проверка помогает заранее выявлять баги, неправильное управление эффектами и состояние, делая код более устойчивым и предсказуемым перед продакшен-сборкой<br />"
    },
    {
      "question": "Как включить React Strict Mode в приложении?",
      "id": "q-98-cbebe486",
      "answer": "▪ обернуть компонент в <b><React.StrictMode></b>"
    },
    {
      "question": "Как получить доступ к React Context без хуков?",
      "id": "q-99-2cd86dff",
      "answer": "▪ через компонент <b><MyContext.Consumer></b>. В него передают функцию, которая получает текущее значение контекста<br />"
    },
    {
      "question": "Какие проблемы с производительностью возникают при частых обновлениях контекста?",
      "id": "q-100-da9f222c",
      "answer": "▪ При изменении значения в провайдере все дочерние компоненты использующие контекст перерендериваются, даже если используют лишь часть данных или не затронуты логикой<br />"
    },
    {
      "question": "Как JSX трансформируется в вызовы <b>React.createElement</b>?",
      "id": "q-101-1b668400",
      "answer": "▪ JSX — это синтаксический сахар, который во время сборки транспилируется в вызовы <b>React.createElement</b><br />"
    },
    {
      "question": "Что такое ReactElement и чем он отличается от компонента?",
      "id": "q-102-e1cc7c08",
      "answer": "▪ ReactElement — это обычный объект, который описывает элемент React: тип (тег или компонент), пропсы и детей. Это «план» для реального DOM. Он не является компонентом и не содержит логики — это результат вызова компонента или JSX<br /><br />"
    },
    {
      "question": "Как Automatic Batching в React 18 работает с промисами и таймерами?",
      "id": "q-103-cd654b7c",
      "answer": "▪ В React 18 Automatic Batching работает со всеми асинхронными операциями. Когда несколько setState вызываются внутри промиса или setTimeout, React автоматически объединяет их в один рендер, что значительно улучшает производительность<br />"
    },
    {
      "question": "В чем разница между React 17 и React 18 batching?",
      "id": "q-104-af733ece",
      "answer": "▪ React 17: batching работал только в обработчиках событий React (<b>onClick</b>, <b>onChange</b> и т.д.)<br />▪ React 18: batching работает везде, включая промисы, таймеры, сетевые запросы и любые другие асинхронные операции<br />"
    },
    {
      "question": "Как <b>flushSync</b> обходит Automatic Batching?",
      "id": "q-105-614c3812",
      "answer": "▪ <b>flushSync</b> принудительно выполняет обновление синхронно, игнорируя Automatic Batching. Это полезно когда нужно немедленно применить изменения, например, для измерений DOM или интеграции с внешними библиотеками<br />"
    },
    {
      "question": "Что такое React Compiler и какую роль он играет в оптимизации React-кода?",
      "id": "q-106-962cd467",
      "answer": "▪ React Compiler — это инструмент, который автоматически оптимизирует React код во время компиляции. Он анализирует код и применяет оптимизации, которые раньше требовали ручного написания <b>useMemo</b>, <b>useCallback</b> и других оптимизаций<br />"
    },
    {
      "question": "Как React Compiler оптимизирует код?",
      "id": "q-107-a0a31aa8",
      "answer": "▪ React Compiler автоматически мемоизирует компоненты и функции, удаляет ненужные ререндеры, оптимизирует пропсы и состояния. Он делает это на уровне компиляции, что более эффективно чем ручные оптимизации<br /><br />"
    },
    {
      "question": "Какие правила использования хуков React нужно соблюдать?",
      "id": "q-108-7223b52d",
      "answer": "▪ Вызывайте их на верхнем уровне в теле компонента функции<br />▪ Вызывайте их на верхнем уровне в теле пользовательского хука<br />▪ Не вызывайте хуки внутри условий или циклов<br />▪ Не называйте хуки после условного return оператора<br />▪ Не вызывайте хуки в обработчиках событий<br />▪ Не вызывайте хуки в компонентах класса<br />▪ Не вызывайте хуки внутри функций, переданных в <b>useMemo</b>, <b>useReducer</b>, или <b>useEffect</b><br /><br />"
    },
    {
      "question": "Для чего нужен <b>useState</b>?",
      "id": "q-109-e0450b88",
      "answer": "▪ Чтобы создать локальное состояние в функциональном компоненте<br />"
    },
    {
      "question": "Что возвращает <b>useState</b>?",
      "id": "q-110-49255c65",
      "answer": "▪ Массив из двух элементов: текущее значение и функция для его обновления<br />"
    },
    {
      "question": "Как изменить состояние <b>useState</b>?",
      "id": "q-111-4c48e5cc",
      "answer": "▪ Вызов <b>setState(newValue)</b> или <b>setState(prev => computeNext(prev))</b><br />"
    },
    {
      "question": "Как обновлять состояние на основе предыдущего значения?",
      "id": "q-112-4b9f6998",
      "answer": "▪ <b>setState(prev => computeNext(prev))</b><br />"
    },
    {
      "question": "Почему setState асинхронен, и как это влияет на обновления?",
      "id": "q-113-17bb88ce",
      "answer": "▪ batching группирует обновления, чтобы не делать лишнюю работу. Поэтому state не обновляется сразу после вызова setState<br />"
    },
    {
      "question": "Что произойдет, если вызвать setState с тем же значением?",
      "id": "q-114-990487cc",
      "answer": "▪ React использует <b>Object.is</b> для сравнения. Если значение не изменилось — ререндер не произойдёт"
    },
    {
      "question": "Как работает shallow compare в <b>useState</b>?",
      "id": "q-115-252d7d59",
      "answer": "▪ Shallow сравнение — <b>Object.is(prev, next)</b>. Для объектов и массивов — сравниваются только ссылки<br />"
    },
    {
      "question": "Как работает <b>useState</b> при повторных рендерах?",
      "id": "q-116-2fd6473d",
      "answer": "▪ React сохраняет значение в ячейке хука. Инициализация выполняется один раз — при первом рендере<br />"
    },
    {
      "question": "Как правильно обновлять состояние, если оно — объект или массив?",
      "id": "q-117-5ab8e831",
      "answer": "▪ Иммутабельно: <b>setState(prev => ({ ...prev, updated: true }))</b>"
    },
    {
      "question": "Почему нельзя вызывать <b>useState</b> условно?",
      "id": "q-118-b3432429",
      "answer": "▪ Потому что порядок вызовов хуков должен быть стабильным между рендерами<br />"
    },
    {
      "question": "В чем отличие <b>useState</b> от <b>useReducer</b>?",
      "id": "q-119-df21f49f",
      "answer": "▪ <b>useState</b> — для простого состояния. <b>useReducer</b> — для сложной логики и вложенных структур. <b>useReducer</b> даёт больше контроля и лучше масштабируется<br />"
    },
    {
      "question": "Как ведет себя <b>useState</b> при размонтировании компонента?",
      "id": "q-120-3fe48d39",
      "answer": "▪ Хук отрабатывает только при монтировании. После анмаунта setState ничего не делает"
    },
    {
      "question": "Как сделать ленивую инициализацию состояния в <b>useState</b>?",
      "id": "q-121-2ba5500d",
      "answer": "▪ <b>useState(() => computeExpensiveInitial())</b><br />"
    },
    {
      "question": "В чем разница между <b>useState(someFunction())</b>, <b>useState(someFunction)</b>, <b>useState(() => someFunction())</b>?",
      "id": "q-122-5c50ff74",
      "answer": "▪ <b>someFn()</b> — вызов сразу, значение — результат<br />▪ <b>someFn</b> — функция как значение, не вызовется<br />▪ <b>() => someFn()</b> — ленивый вызов, только при первом рендере"
    },
    {
      "question": "Можно ли мемоизировать setState с помощью <b>useCallback</b>?",
      "id": "q-123-c01faba1",
      "answer": "▪ Можно, но не нужно. setState стабилен, ссылка не меняется<br />"
    },
    {
      "question": "Что произойдёт, если передать пропсы как начальное значение в <b>useState</b>, а затем эти пропсы изменятся?",
      "id": "q-124-9f66f4db",
      "answer": "▪ Ничего не произойдёт. Начальное значение читается только при монтировании. Для синхронизации с пропсами нужен <b>useEffect</b><br />"
    },
    {
      "question": "Как синхронизировать значение <b>useState</b> с передаваемыми компоненту пропсами?",
      "id": "q-125-11682d6f",
      "answer": "▪ Чтобы синхронизировать state с пропсами, нужно использовать <b>useEffect</b> с подпиской на нужные пропсы"
    },
    {
      "question": "Что будет если <b>useState</b> при значении объекта через setState присвоить этот же объект?",
      "id": "q-126-b6c5aa50",
      "answer": "▪ <b>setObj((obj) => obj)</b> - ничего не будет так как ссылка такая же<br />▪ <b>setObj((obj) => {...obj})</b> - произойдет перерендер так как ссылку уже будет другой<br />"
    },
    {
      "question": "Как избежать stale-значений при обновлении состояния в async-колбэках или таймерах?",
      "id": "q-127-536cb904",
      "answer": "▪ Использовать функциональный <b>setState(prev => ...)</b>"
    },
    {
      "question": "Почему setState внутри <b>useEffect</b> может зациклить рендер?",
      "id": "q-128-b9be1e48",
      "answer": "▪ Если setState вызывается без условий, и обновляемое состояние входит в deps, произойдёт бесконечный цикл<br />"
    },
    {
      "question": "Как работает batching в React 18 и какие кейсы нарушают его (например, setTimeout, промисы)?",
      "id": "q-129-217259ec",
      "answer": "▪ React batch'ит несколько вызовов setState в один ререндер<br />▪ после 18 версии всё, что запущено внутри одного \"tick\" (микро/макрозадачи), будет батчиться<br />▪ <b>flushSync</b> принудительно ререндерит компонент игнорируя batch(инг)<br /><br /><br />---<br /><br />"
    },
    {
      "question": "Для чего нужен <b>useEffect</b>?",
      "id": "q-130-51b78ae4",
      "answer": "▪ <b>useEffect</b> позволяет выполнять побочные эффекты<br />"
    },
    {
      "question": "Когда вызывается <b>useEffect</b>?",
      "id": "q-131-184c7f70",
      "answer": "▪ После рендера, асинхронно, уже после того как браузер нарисовал DOM<br />"
    },
    {
      "question": "Какие параметры принимает <b>useEffect</b> и что они означают?",
      "id": "q-132-040b488a",
      "answer": "▪ <b>callback: () => void</b> — основная функция с эффектом<br />▪ <b>deps: any[]</b> — массив зависимостей (опционально)<br />"
    },
    {
      "question": "Что возвращает <b>useEffect</b>?",
      "id": "q-133-554447bf",
      "answer": "▪ Ничего сам по себе (undefined). Но колбэк может вернуть функцию очистки — она вызовется при размонтировании или перед следующим выполнением эффекта<br />"
    },
    {
      "question": "Как работает массив зависимостей?",
      "id": "q-134-ea9d5c15",
      "answer": "▪ React сравнивает зависимости (по <b>Object.is</b>). Эффект выполняется только если хотя бы одна зависимость изменилась. Если массив пустой — выполнится один раз при монтировании"
    },
    {
      "question": "Что будет, если не указать зависимости?",
      "id": "q-135-1d4105ae",
      "answer": "▪ Эффект будет выполняться после каждого рендера<br />"
    },
    {
      "question": "Как выполнить эффект только при монтировании компонента?",
      "id": "q-136-679cc248",
      "answer": "▪ Передать пустой массив зависимостей<br />"
    },
    {
      "question": "Как использовать <b>useEffect</b> с асинхронными функциями?",
      "id": "q-137-d252ea9b",
      "answer": "▪ Нельзя сделать сам <b>useEffect</b> async, но можно в callback создать асинхронную функцию и вызвать ее"
    },
    {
      "question": "Что такое функция очистки (cleanup)?",
      "id": "q-138-82eef0bb",
      "answer": "▪ Это функция, которую может возвращать callback. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента<br />▪ Используется для отмены подписок, таймеров, abort-controllers и т.п.<br />"
    },
    {
      "question": "Когда вызывается функция очистки?",
      "id": "q-139-763d472b",
      "answer": "▪ Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента"
    },
    {
      "question": "Как отменять асинхронные операции в <b>useEffect</b>?",
      "id": "q-140-4d47ecbe",
      "answer": "▪ <b>AbortController</b> для запросов<br />▪ флаг переменную<br />"
    },
    {
      "question": "Чем <b>useEffect</b> отличается от <b>useLayoutEffect</b>?",
      "id": "q-141-e3215483",
      "answer": "▪ <b>useEffect</b>: вызывается асинхронно, после рендера и отрисовки<br />▪ <b>useLayoutEffect</b>: вызывается синхронно, до отрисовки браузером и может блокировать отрисовку"
    },
    {
      "question": "Что такое \"useEffect первого рендера\" и \"useEffect обновления\"? Как их различать?",
      "id": "q-142-6fe0fd51",
      "answer": "▪ useEffect первого рендера: выполняются один раз при монтировании (<b>useEffect(() => {...}, [])</b>)<br />▪ useEffect обновления: выполняются при изменении зависимостей (<b>useEffect(() => {...}, [a, b])</b>)<br />"
    },
    {
      "question": "Как избежать гонки состояний (race conditions) в асинхронных эффектах?",
      "id": "q-143-3c8b4467",
      "answer": "▪ Используй <b>AbortController</b>, флаги <b>isMounted</b>"
    },
    {
      "question": "Почему нельзя делать await напрямую в <b>useEffect(callback)</b>?",
      "id": "q-144-4c9f643a",
      "answer": "▪ Потому что <b>useEffect</b> должен возвращать либо undefined, либо функцию очистки. async функция всегда возвращает Promise, что нарушает контракт<br />"
    },
    {
      "question": "Как правильно использовать эффекты с подписками на внешние источники (WebSocket, Observer, EventListener)?",
      "id": "q-145-7f7deb7a",
      "answer": "▪ Создай подписку в <b>useEffect</b><br />▪ Вернуть функцию очистки, чтобы отписаться при размонтировании или повторном вызове"
    },
    {
      "question": "Что произойдёт, если не использовать функцию очистки при подписке?",
      "id": "q-146-0ae9e4cb",
      "answer": "▪ Повторные подписки → дублирование событий<br />▪ неактуальные колбэки<br />▪ Утечка ресурсов<br />"
    },
    {
      "question": "Чем отличается порядок выполнения нескольких <b>useEffect</b> в одном компоненте?",
      "id": "q-147-5288f213",
      "answer": "▪ Они выполняются сверху вниз, в порядке объявления. Это важно, если между ними есть зависимость"
    },
    {
      "question": "Как влияет Strict Mode на вызовы <b>useEffect</b>? Как это влияет на эффекты с побочками?",
      "id": "q-148-7bb96567",
      "answer": "▪ <b>useEffect</b> вызывается дважды (монтирование → размонтирование → повторное монтирование)<br />▪ Цель — поймать ошибки в нечистых эффектов, например, без cleanup<br /><br /><br />"
    },
    {
      "question": "Для чего нужен <b>useRef</b>?",
      "id": "q-149-f96dcc7b",
      "answer": "▪ Также — для доступа к DOM-элементам<br />▪ Чтобы хранить значения, которые не вызывают ререндер при изменении<br />"
    },
    {
      "question": "Какие варианты использования <b>useRef</b> в React?",
      "id": "q-150-53eabee0",
      "answer": "▪ Доступ к DOM<br />▪ Хранение значения между рендерами<br />▪ Предыдущее значение<br />▪ Флаг \"монтирован\"<br />▪ Таймеры, id, внешние инстансы<br />"
    },
    {
      "question": "Как получить доступ к DOM-элементу с помощью <b>useRef</b>?",
      "id": "q-151-d69a4e40",
      "answer": "▪ Прокинуть в атрибут ref html тега переменную которой присвоили <b>useRef()</b><br />"
    },
    {
      "question": "Что хранится в <b>.current</b>?",
      "id": "q-152-87aa18ed",
      "answer": "▪ В поле <b>.current</b> хранится текущее значение, которое туда положили. По умолчанию — значение, переданное в <b>useRef(initialValue)</b><br />"
    },
    {
      "question": "Можно ли изменять <b>.current</b>?",
      "id": "q-153-04a3ee61",
      "answer": "▪ Да, через <b>ref.current = newValue</b><br />"
    },
    {
      "question": "Вызывает ли изменение <b>.current</b> перерендер?",
      "id": "q-154-d6c911ce",
      "answer": "▪ <b>useRef</b> не триггерит повторный рендер, в отличие от <b>useState</b>"
    },
    {
      "question": "Как использовать <b>useRef</b> для хранения значений между рендерами?",
      "id": "q-155-bbcf245d",
      "answer": "▪ Любое значение, присвоенное <b>ref.current</b>, мутабельно, доступно для использования и сохраняется между перерендерами<br />"
    },
    {
      "question": "Чем <b>useRef</b> отличается от <b>useState</b>?",
      "id": "q-156-d0e32d7c",
      "answer": "▪ <b>useRef</b> не вызывает ререндер при изменении<br />▪ <b>useState</b> — триггерит ререндер<br />"
    },
    {
      "question": "Как использовать <b>useRef</b> для хранения предыдущего значения?",
      "id": "q-157-1e01fd73",
      "answer": "▪ Любое значение, присвоенное <b>ref.current</b>, мутабельно, доступно для использования и сохраняется между перерендерами<br />"
    },
    {
      "question": "Как <b>useRef</b> помогает избежать лишнего рендера в <b>onScroll</b>, <b>onResize</b> и других частых ивентах?",
      "id": "q-158-dd72d080",
      "answer": "▪ При <b>onScroll</b>, <b>onResize</b> и подобных событиях состояние часто обновляется, но повторный рендер при каждом изменении — дорог. <b>useRef</b> позволяет сохранять значения между рендерами, не вызывая лишних повторных рендеров.<br />"
    },
    {
      "question": "Можно ли использовать <b>useRef</b> как глобальный стейт? Почему это плохая идея?",
      "id": "q-159-3d52e57a",
      "answer": "▪ Можно, но не нужно, так как:<br />▪ <b>useRef</b> — локален компоненту<br />▪ не вызывает ререндер<br />▪ не реактивен — другие компоненты не узнают об изменении<br />"
    },
    {
      "question": "Как связать <b>useRef</b> и <b>forwardRef</b> для передачи доступа к DOM наружу?",
      "id": "q-160-7cc7fe7a",
      "answer": "▪ <b>forwardRef</b> нужен, чтобы пробросить ref от родителя к DOM-элементу внутри компонента.<br />---<br /><br />"
    },
    {
      "question": "Что такое хук <b>useMemo</b> в React и для чего он используется?",
      "id": "q-161-aa724973",
      "answer": "▪ <b>useMemo</b> — это хук, который мемоизирует результат вычисления между рендерами, чтобы не пересчитывать заново, если зависимости не изменились<br />"
    },
    {
      "question": "Какие аргументы принимает <b>useMemo</b> и что они означают?",
      "id": "q-162-7f0b3524",
      "answer": "▪ Функция, которая возвращает значение<br />▪ Массив зависимостей (deps)<br />"
    },
    {
      "question": "Что возвращает <b>useMemo</b> при успешной мемоизации?",
      "id": "q-163-6f7c4517",
      "answer": "▪ Результат выполнения переданной функции — мемоизированное значение<br />"
    },
    {
      "question": "Когда имеет смысл применять <b>useMemo</b> в React-компонентах?",
      "id": "q-164-4e41c220",
      "answer": "▪ Дорогие вычисления<br />▪ Передача стабильной ссылки в зависимости<br />▪ Оптимизация рендеров дочерних компонентов<br />"
    },
    {
      "question": "В каких случаях <b>useMemo</b> не приносит пользы и может навредить?",
      "id": "q-165-8294a5fc",
      "answer": "▪ Преждевременная мемоизация нагружает память и CPU<br />▪ Если вычисление дешёвое<br />▪ Если часто меняются зависимости и значение всегда пересчитывается<br />▪ Если нет проблем с производительностью"
    },
    {
      "question": "Как устроена мемоизация в <b>useMemo</b> под капотом?",
      "id": "q-166-4eb4b78d",
      "answer": "▪ React запоминает результат выполнения функции<br />▪ При следующем рендере сравнивает зависимости<br />▪ Если зависимости не изменились (<b>Object.is</b>) — возвращает кэш, иначе — пересчитывает<br />"
    },
    {
      "question": "Что произойдёт в <b>useMemo</b>, если не указать массив зависимостей?",
      "id": "q-167-4b261024",
      "answer": "▪ Функция будет перевычисляться при каждом рендере<br />"
    },
    {
      "question": "В каких случаях <b>useMemo</b> может ухудшить производительность приложения?",
      "id": "q-168-f65148c0",
      "answer": "▪ Если мемоизируется дешёвая логика<br />▪ Если зависимости часто меняются<br />▪ Если много <b>useMemo</b> — меньше GC, больше памяти<br />"
    },
    {
      "question": "Как <b>useMemo</b> сравнивает зависимости: по ссылке или по значению?",
      "id": "q-169-18d1893f",
      "answer": "▪ По ссылке, через <b>Object.is()</b><br />"
    },
    {
      "question": "Как <b>useMemo</b> ведёт себя в конкурентном рендеринге (Concurrent Mode)?",
      "id": "q-170-c0f8eeef",
      "answer": "▪ В Concurrent Mode <b>useMemo</b> ведёт себя также, как и другие React-хуки: результат мемоизации сохраняется только после коммита. Если рендер был прерван, результат <b>useMemo</b> не сохраняется, и при следующем рендере функция будет вызвана снова"
    },
    {
      "question": "Чем <b>useMemo</b> отличается от мемоизации вне React (например, <b>lodash.memoize</b>)?",
      "id": "q-171-7c963f13",
      "answer": "▪ <b>useMemo</b> — это hook, встроенный в React-цикл рендеринга и зависящий от зависимостей и жизненного цикла компонента. Он автоматически сбрасывается при размонтировании компонента<br />▪ В отличие от него, <b>lodash.memoize</b> — это императивная мемоизация, работающая вне контекста React и требующая ручного контроля над кэшем. Она сохраняет результат в глобальном или внешнем кэше и не зависит от ререндеров<br />"
    },
    {
      "question": "Как <b>useMemo</b> влияет на использование памяти и работу сборщика мусора?",
      "id": "q-172-498df503",
      "answer": "▪ Каждый <b>useMemo</b> сохраняет результат в кэше до тех пор, пока компонент не размонтируется или зависимости не изменятся. Если <b>useMemo</b> используется без нужды (например, для дешёвых вычислений), это может увеличить потребление памяти, замедлить сборку мусора и создать лишнюю нагрузку на CPU из-за отслеживания зависимостей<br />"
    },
    {
      "question": "Как <b>useMemo</b> взаимодействует с режимом Suspense в React?",
      "id": "q-173-5ce26a18",
      "answer": "▪ В режиме Suspense, если рендер компонента прерывается из-за \"зависания\" на промисе (например, в data fetching), <b>useMemo</b> работает аналогично Concurrent Mode: результат не кэшируется, пока не произойдёт успешный коммит. Это значит, что функция в <b>useMemo</b> может вызываться повторно при каждом новом рендере, до тех пор, пока Suspense не завершит ожидание<br />"
    },
    {
      "question": "Какие ошибки возникают при неправильном указании зависимостей в <b>useMemo</b>?",
      "id": "q-174-e6a7c9c0",
      "answer": "▪ Если зависимости <b>useMemo</b> указаны неправильно (например, не указаны значения, от которых зависит вычисление), могут возникнуть баги со stale values: мемоизированное значение будет пересчитываться реже, чем нужно, и может стать неактуальным. Это приводит к неконсистентному UI, неверным данным или логике<br /><br />---<br /><br />"
    },
    {
      "question": "Что такое хук <b>useCallback</b> в React и для чего он используется?",
      "id": "q-175-01236565",
      "answer": "▪ <b>useCallback</b> — это хук, который мемоизирует функцию, чтобы она сохраняла стабильную ссылку между рендерами, если не изменились зависимости<br />"
    },
    {
      "question": "Какие аргументы принимает <b>useCallback</b> и что они означают?",
      "id": "q-176-ebb0bd51",
      "answer": "▪ Колбэк-функция (возвращается как есть, не вызывается)<br />▪ Массив зависимостей<br />"
    },
    {
      "question": "Что возвращает <b>useCallback</b> и когда ссылка на функцию остаётся стабильной?",
      "id": "q-177-0fcfb182",
      "answer": "▪ Мемоизированную функцию<br />"
    },
    {
      "question": "Когда имеет смысл применять <b>useCallback</b> в React-компонентах?",
      "id": "q-178-984e0b19",
      "answer": "▪ Когда нужно передать функцию в memoized-компонент<br />▪ В <b>useEffect</b> / <b>useMemo</b> / <b>setInterval</b> — когда функция зависит от стабильности ссылки<br />▪ Для оптимизации компонентов, избегающих лишнего рендера по ссылке на колбэк<br />"
    },
    {
      "question": "В каких случаях <b>useCallback</b> бесполезен и не даёт выигрыша?",
      "id": "q-179-1f2e98b3",
      "answer": "▪ Если компонент не зависит от стабильности функции<br />▪ Если функция пересоздаётся каждый раз из-за нестабильных зависимостей<br />▪ Если перерисовки и так дешёвые"
    },
    {
      "question": "Что произойдёт, если колбэк в <b>useCallback</b> зависит от внешних значений, но их нет в зависимостях?",
      "id": "q-180-a07e7bc3",
      "answer": "▪ баг: внутри функции будут устаревшие значения (stale closure)<br />"
    },
    {
      "question": "Чем отличается <b>useCallback</b> от <b>useMemo</b>?",
      "id": "q-181-fc943b9a",
      "answer": "▪ <b>useCallback</b>:<br />▪ Мемоизирует функцию<br />▪ Возвращает саму функцию<br />▪ <b>useMemo</b>:<br />▪ Мемоизирует значение<br />▪ Возвращает результат вызова<br />"
    },
    {
      "question": "Когда стоит предпочесть <b>useCallback</b> вместо обычного объявления функции в компоненте?",
      "id": "q-182-b51c4478",
      "answer": "▪ Когда функция передаётся вниз (в props) и нужно избежать лишнего рендера дочернего <b>React.memo</b> компонента<br />▪ Когда функция участвует в зависимостях эффекта, и нужна стабильная ссылка<br />"
    },
    {
      "question": "Можно ли заменить <b>useCallback</b> с помощью <b>useMemo</b>? Почему это не рекомендуется?",
      "id": "q-183-60398762",
      "answer": "▪ Да, но не рекомендуется из-за неочевидности<br />"
    },
    {
      "question": "Как избежать stale-замыканий (устаревших значений) при использовании <b>useCallback</b>?",
      "id": "q-184-212d9e72",
      "answer": "▪ Чтобы избежать stale closure, необходимо указывать в массиве зависимостей все значения, на которые ссылается колбэк: пропсы, стейт и любые переменные из внешней области. Это гарантирует, что функция будет пересоздана при изменении нужных данных и всегда работать с актуальными значениями"
    },
    {
      "question": "Как <b>useCallback</b> ведёт себя в конкурентном рендеринге (Concurrent Mode)?",
      "id": "q-185-e052fcce",
      "answer": "▪ <b>useCallback</b> — не сохраняется между прерванными рендерами, пока не завершится коммит<br />▪ Но после успешного коммита, возвращаемая функция будет стабильна, если зависимости не поменялись<br />"
    },
    {
      "question": "Почему нельзя мемоизировать колбэк с пустым массивом зависимостей, если внутри используются пропсы/состояние?",
      "id": "q-186-259055a0",
      "answer": "▪ Пустой массив зависимостей фиксирует колбэк навсегда после первого рендера. Если в теле функции используются внешние значения, они будут захвачены однажды и больше не обновятся. Это приведёт к использованию устаревших данных и нарушит ожидаемое поведение компонента<br />"
    },
    {
      "question": "Можно ли комбинировать <b>useCallback</b> с <b>useMemo</b> и когда это оправдано?",
      "id": "q-187-367734f0",
      "answer": "▪ Комбинация возможна и уместна, когда требуется создать мемоизированную структуру, содержащую функции, и сохранить стабильность всей структуры между рендерами<br />"
    },
    {
      "question": "Чем <b>useCallback</b> отличается от простого объявления функции внутри компонента?",
      "id": "q-188-a5450225",
      "answer": "▪ Функция, объявленная внутри компонента без <b>useCallback</b>, пересоздаётся при каждом рендере и всегда имеет новую ссылку. <b>useCallback</b> позволяет сохранить ссылку на функцию между рендерами при условии, что зависимости не изменились<br /><br /><br />---<br /><br />"
    },
    {
      "question": "Для чего используется хук <b>useId</b> в React и какие задачи он решает?",
      "id": "q-189-baaa39e2",
      "answer": "▪ нужен для генерации уникального, стабильного ID, который синхронизируется между сервером и клиентом<br />▪ полезен для привязки label ↔ input, <b>aria-describedby</b>, и в компонентах, рендерящихся и на сервере, и на клиенте<br />"
    },
    {
      "question": "Как работает <b>useId</b> и почему его ID стабильны между рендерами?",
      "id": "q-190-e812f325",
      "answer": "▪ React генерирует уникальный, стабильный префикс независимо от количества ререндеров<br />"
    },
    {
      "question": "Можно ли использовать <b>useId</b> в серверных компонентах React (RSC)?",
      "id": "q-191-27fb0e73",
      "answer": "▪ Да. <b>useId</b> безопасен для Server Components и работает и на сервере, и на клиенте. Это одна из его задач — избежать mismatch при гидратации<br />"
    },
    {
      "question": "Как <b>useId</b> помогает при серверном рендеринге (SSR) избежать mismatch?",
      "id": "q-192-3076d3db",
      "answer": "▪ <b>useId</b> гарантирует одинаковый ID на обеих сторонах (в отличие от <b>Math.random()</b>, uuid), потому что React сам контролирует генерацию и встраивает метаданные в HTML<br />"
    },
    {
      "question": "Чем <b>useId</b> отличается от генерации ID через <b>Math.random()</b> и сторонние библиотеки?",
      "id": "q-193-6061f74d",
      "answer": "▪ Стабильный между рендерами<br />▪ Работает при SSR-гидратации<br />▪ безопасен для accessibility"
    },
    {
      "question": "Можно ли использовать <b>useId</b> для генерации ключей (key) в списках React?",
      "id": "q-194-113c1eb5",
      "answer": "▪ Нет. Ключи в списках должны быть детерминированы по данным, иначе при изменении порядка или количества элементов React будет пере-монтировать всё<br />"
    },
    {
      "question": "Что будет, если использовать <b>useId</b> в компоненте, который часто ререндерится?",
      "id": "q-195-adf69e53",
      "answer": "▪ <b>useId</b> стабилен — он выдаёт одно и то же значение между рендерами, пока компонент не размонтируется<br />"
    },
    {
      "question": "Какие проблемы <b>useId</b> решает в контексте доступности (a11y)?",
      "id": "q-196-1667745a",
      "answer": "▪ Для доступности важно, чтобы label имел <b>htmlFor={id}</b>, а input — <b>id={sameId}</b>. Если ID разные на сервере и клиенте — атрибут for указывает не туда → screen reader не сможет связать label и поле. <b>useId</b> даёт одинаковый ID и решает эту проблему<br />"
    },
    {
      "question": "Как <b>useId</b> ведёт себя при гидратации после SSR?",
      "id": "q-197-6508665a",
      "answer": "▪ React знает, как синхронизировать ID, сгенерированные на сервере и клиенте, чтобы избежать ошибок. Это происходит через встроенные маркеры в HTML, которые позволяют React восстановить правильный <b>state</b> без mismatch<br />"
    },
    {
      "question": "Как <b>useId</b> генерирует стабильные ID в конкурентном режиме (Concurrent Mode)?",
      "id": "q-198-4d899ba4",
      "answer": "▪ <b>useId()</b> генерирует стабильный уникальный ID, который:<br />▪ Не зависит от порядка рендера и не сбивается даже при конкурентных прерываниях (concurrent rendering), т.к. не использует счётчики, как <b>useRef</b> или инкремент<br />"
    },
    {
      "question": "Есть ли ограничения по количеству вызовов <b>useId</b> в одном компоненте?",
      "id": "q-199-f96f93ba",
      "answer": "▪ Нет, жёстких ограничений нет — можно вызывать <b>useId</b> сколько угодно раз, и каждый вызов <b>useId()</b> вернёт уникальный ID, даже в одном компоненте"
    },
    {
      "question": "Как <b>useId</b> ведёт себя при гидратации SSR в сочетании с React Suspense?",
      "id": "q-200-c61353cc",
      "answer": "▪ React гарантирует, что <b>useId()</b> возвращает одинаковое значение на сервере и клиенте. Это особенно важно при использовании Suspense, где часть дерева может быть отложена, что меняет порядок вызова хуков<br />▪ ID детерминированный, стабилен даже при Suspense, <b>startTransition</b>, и других асинхронных рендерах<br /><br />---<br /><br /><br />useContext<br />"
    },
    {
      "question": "Для чего нужен хук <b>useContext</b> в React и что он возвращает?",
      "id": "q-201-100753cf",
      "answer": "▪ Чтобы получать значение из контекста<br />"
    },
    {
      "question": "Как создать и экспортировать контекст в React?",
      "id": "q-202-748eb73a",
      "answer": "▪ <b>export const ThemeContext = React.createContext(null);</b><br />"
    },
    {
      "question": "Как использовать <b>useContext</b> для получения значения из контекста?",
      "id": "q-203-73ed555e",
      "answer": "▪ <b>const theme = useContext(ThemeContext);</b><br />"
    },
    {
      "question": "Можно ли использовать <b>useContext</b> вне компонента? Почему?",
      "id": "q-204-6e476731",
      "answer": "▪ Нельзя. <b>useContext</b> — это хук, он должен вызываться внутри функционального компонента или другого хука<br />"
    },
    {
      "question": "Как <b>useContext</b> работает при обновлении значения в провайдере?",
      "id": "q-205-cfa35075",
      "answer": "▪ Если значение контекст меняется, все потомки, использующие <b>useContext</b>, перерисуются<br />▪ React сравнивает по <b>Object.is</b><br />"
    },
    {
      "question": "Как избежать лишних рендеров при использовании <b>useContext</b>?",
      "id": "q-206-054a812f",
      "answer": "▪ Мемоизировать value<br />▪ Разделить контексты: один для данных, другой для диспатча (Pattern: StateContext + DispatchContext)<br />▪ Вынести <b>useContext</b> ближе к месту, где нужен<br />"
    },
    {
      "question": "Можно ли использовать несколько контекстов одновременно? Как это делать?",
      "id": "q-207-a441c45f",
      "answer": "▪ Да. Просто вложив провайдеры друг в друга<br />"
    },
    {
      "question": "Когда использовать <b>useContext</b>, а когда — глобальные стейты типа <b>Redux</b> или <b>Zustand</b>?",
      "id": "q-208-f2d0c7a9",
      "answer": "▪ Используй <b>useContext</b> для UI-состояния и небольших кусков, <b>Redux</b>/<b>Zustand</b> — если данные масштабируются и делятся между многими частями приложения<br />"
    },
    {
      "question": "Как работает <b>useContext</b> с серверным рендерингом (SSR)?",
      "id": "q-209-bcbbb532",
      "answer": "▪ Неизвестно (нужна доработка раздела)<br />"
    },
    {
      "question": "Какие ограничения и подводные камни есть у <b>useContext</b>?",
      "id": "q-210-220be28a",
      "answer": "▪ Все потребители перерисуются при любом изменении value<br />▪ Плохая производительность при больших объектах в value<br />▪ Нельзя вызывать вне компонента<br />▪ Мутирование объекта в value не вызовет ререндер<br />"
    },
    {
      "question": "Как работает обновление контекста при вложенных провайдерах с одинаковым типом?",
      "id": "q-211-cfa7ab0c",
      "answer": "▪ Если компонент обернут во вложенные <b><Context.Provider></b> одного и того же контекста, то <b>useContext(Context)</b> всегда читает ближайший вверх по дереву Provider<br />"
    },
    {
      "question": "Как <b>useContext</b> влияет на производительность в больших приложениях?",
      "id": "q-212-6347110b",
      "answer": "▪ При любом изменении value в Provider, все компоненты, читающие этот контекст (через <b>useContext</b>), перерисовываются, даже если они используют только часть value<br />▪ Это связано с тем, что React делает сравнение по <b>Object.is(value)</b> на уровне Provider<br />"
    },
    {
      "question": "Как обрабатывать ошибки при чтении контекста вне провайдера?",
      "id": "q-213-a68fca3d",
      "answer": "▪ Создай обёртку-хук:<br /><br /><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;function useStrictContext() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  const context = useContext(MyContext);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (!context) {<br />&nbsp;&nbsp;&nbsp;&nbsp;    throw new Error('useMyContext должен вызываться внутри <MyContext.Provider>');<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return context;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre><br />"
    },
    {
      "question": "Какие альтернативы <b>useContext</b> для глобального состояния и когда их лучше применять?",
      "id": "q-214-a9ccb218",
      "answer": "▪ <b>Zustand</b>, <b>Redux</b> + RTK, Recoil<br />▪ <b>useContext</b> хорошо работает для:<br />▪ UI-состояния<br />▪ локальных настроек<br />▪ небольшого шаринга между родителем и потомками<br /><br />---<br /><br />useReducer<br />"
    },
    {
      "question": "Что такое <b>useReducer</b> и для чего он нужен?",
      "id": "q-215-5d988193",
      "answer": "▪ Это хук для управления сложным или предсказуемым состоянием<br />"
    },
    {
      "question": "Какие параметры принимает <b>useReducer</b> и что они означают?",
      "id": "q-216-6b656950",
      "answer": "▪ <b>reducer</b>: Редюсер — чистая функция, которая определяет логику обновления состояния. Редюсер принимает два аргумента – состояние и действие, и возвращает следующее состояние. Состояние и действие могут быть любых типов<br />▪ <b>initialArg</b>: Значение на основе которого вычисляется начальное состояние. Значение начального состояния может быть любого типа. То как из него будет вычисляться начальное состояние, зависит от аргумента init<br />▪ <b>init</b>(опционально): функция-инициализатор, возвращающая начальное состояние. Если не указана — состояние устанавливается в initialArg. Если указана — используется результат init(initialArg)<br />"
    },
    {
      "question": "Чем отличается <b>useReducer</b> от <b>useState</b>?",
      "id": "q-217-da3fdbeb",
      "answer": "▪ <b>useState</b> → императивный: напрямую задаёшь новое значение<br />▪ <b>useReducer</b> → декларативный: ты диспатчишь событие (dispatch(<b>action</b>)), и редьюсер решает, как изменится состояние<br />▪ <b>useReducer</b> легче масштабировать<br />"
    },
    {
      "question": "Как устроена редьюсер-функция? Какие параметры она принимает?",
      "id": "q-218-77523e06",
      "answer": "▪ Редьюсер — это чистая функция:<br />▪ <b>(</b>state<b>, </b>action<b>) => newState</b>, где:<br />▪ <b>state</b> — текущее состояние<br />▪ <b>action</b> — объект, описывающий событие<br />▪ Возвращает новое состояние. Не мутирует предыдущее<br />"
    },
    {
      "question": "Что возвращает <b>useReducer</b>?",
      "id": "q-219-bb25f3e1",
      "answer": "▪ Массив из двух значений:<br />▪ <b>state</b> — текущее состояние<br />▪ <b>dispatch</b> — функция, которая запускает редьюсер<br />"
    },
    {
      "question": "Что такое функция dispatch?",
      "id": "q-220-2d0c26e4",
      "answer": "▪ <b>dispatch(</b>action<b>)</b> — это функция, которая передаёт <b>action</b> в редьюсер и вызывает пересчёт нового состояния<br />"
    },
    {
      "question": "Как задать начальное состояние в <b>useReducer</b> и сделать ленивую инициализацию?",
      "id": "q-221-57f2c230",
      "answer": "▪ Через <b>initFn</b><br />▪ <b>initialArg</b> — любое значение (можно undefined)<br />▪ <b>initFn(initialArg)</b> - возвращает начальное состояние (вызывается один раз)<br />"
    },
    {
      "question": "Как работает dispatch в <b>useReducer</b>? Можно ли вызывать его асинхронно?",
      "id": "q-222-12fabde8",
      "answer": "▪ <b>dispatch</b> синхронно ставит обновление в очередь, но повторный рендер происходит асинхронно (в режиме батчинга React)<br />▪ <b>dispatch</b> сам не поддерживает async/await, но можно вызывать его из <b>useEffect</b>, async function, setTimeout и т.д<br />"
    },
    {
      "question": "Как использовать <b>useReducer</b> с асинхронными операциями?",
      "id": "q-223-ed3c5673",
      "answer": "▪ Асинхронность обрабатывается вне редьюсера, а сам редьюсер — синхронный<br />"
    },
    {
      "question": "Как использовать <b>useReducer</b> вместе с <b>useContext</b> для глобального стейта?",
      "id": "q-224-2dbf374c",
      "answer": "▪ Создаёшь контекст, в который кладёшь <b>[</b>state<b>, dispatch]</b><br />▪ Оборачиваешь <b>Context.Provider</b> вокруг <b><App></b><br />▪ Любой компонент может использовать <b>useContext(Context)</b> - получает <b>state</b> и dispatch<br />"
    },
    {
      "question": "Как React 18+ улучшает работу с <b>useReducer</b> (например, конкурентный режим и приоритеты обновлений)?",
      "id": "q-225-bf3f4e5f",
      "answer": "▪ Обновления через dispatch теперь участвуют в automatic batching"
    },
    {
      "question": "Что происходит, если вызвать dispatch после размонтирования компонента?",
      "id": "q-226-f08a27f3",
      "answer": "▪ Никакой ошибки не будет, но dispatch вызовет ничего — компонент уже не существует<br />▪ Решение — проверять isMounted через useRef или отменять побочные эффекты в cleanup<br />"
    },
    {
      "question": "Почему редьюсер должен быть чистой функцией? Какие проблемы возникают при мутации?",
      "id": "q-227-7fb734c3",
      "answer": "▪ Редьюсер обязан быть чистой функцией, потому что React полагается на сравнение по ссылке, чтобы понять, произошло ли изменение состояния. Если внутри редьюсера мутировать объект и возвращать ту же ссылку, React не обнаружит изменения и не перерендерит компонент"
    },
    {
      "question": "Как избежать вызова dispatch после размонтирования компонента?",
      "id": "q-228-15bb2e76",
      "answer": "▪ В <b>useEffect</b> можно установить флаг при монтировании и сбросить его в cleanup<br />▪ Перед вызовом dispatch проверять этот флаг<br />"
    },
    {
      "question": "Можно ли использовать несколько редьюсеров в одном компоненте?",
      "id": "q-229-72611718",
      "answer": "▪ Да, можно, каждый useReducer управляет своей частью данных и не зависит от других"
    },
    {
      "question": "Как обновлять части состояния, если <b>state</b> — объект или массив, чтобы избежать мутаций?",
      "id": "q-230-29b0becf",
      "answer": "▪ Вместо мутаций создавать новую версию объекта или массива, копируя неизменённые части<br />"
    },
    {
      "question": "В чём различия между <b>useReducer</b> и <b>Redux</b>-подходом?",
      "id": "q-231-8156402e",
      "answer": "▪ <b>useReducer</b> — это локальный инструмент, предназначенный для управления сложным состоянием внутри одного компонента или изолированной части UI. <b>Redux</b> — это глобальный store, ориентированный на управление состоянием всего приложения<br /><br />-----<br />"
    },
    {
      "question": "Что делает <b>useTransition</b> и как отличить его поведение от обычного обновления?",
      "id": "q-232-543383a0",
      "answer": "▪ Без <b>startTransition</b> обновление может блокировать весь рендер; с <b>startTransition</b> — критичные части UI обновятся сразу, а «тяжёлые» — позже<br />"
    },
    {
      "question": "Как <b>startTransition</b> влияет на приоритет обновлений в React?",
      "id": "q-233-227ff811",
      "answer": "▪ React снижает приоритет запускаемых внутри <b>startTransition</b> обновлений до TransitionLane (в React scheduler), т.е. это concurrent и прерываемые обновления, в отличие от синхронных (DefaultLane, SyncLane) — они могут быть отложены, отменены или заблокированы Suspense<br />"
    },
    {
      "question": "Что происходит, если вызвать <b>startTransition</b> внутри уже идущего <b>startTransition</b>?",
      "id": "q-234-5e4eb4f3",
      "answer": "▪ Никакого дополнительного эффекта не будет — вложенные <b>startTransition</b> не стекуются и не создают вложенные транзакции. Все вложенные обновления также будут иметь TransitionLane, то есть они остаются низкоприоритетными<br />"
    },
    {
      "question": "Как React решает, когда прервать отложенный ререндер?",
      "id": "q-235-bfa04735",
      "answer": "▪ Во время рендера React использует cooperative scheduling. Если текущий transition-рендер занимает слишком много времени (time slicing), он может быть прерван, чтобы отрисовать более приоритетные обновления (например, ввод). После прерывания запускается повторный рендер с учётом новых данных<br />"
    },
    {
      "question": "Как <b>isPending</b> синхронизирован между render-фазами?",
      "id": "q-236-6d02ada0",
      "answer": "▪ <b>isPending</b> — это значение, возвращаемое из <b>useTransition</b>, оно обновляется при старте и завершении transition-обновлений. Он не гарантирует точное состояние рендера, так как обновляется асинхронно и может отставать на один тик. Это флаг для UI-индикации, не для логики<br />"
    },
    {
      "question": "Как отменяется отложенное обновление, если пришёл новый input?",
      "id": "q-237-0b2f01a3",
      "answer": "▪ Если во время transition приходит новый ввод, React прерывает текущий рендер и перезапускает его с актуальными данными. Предыдущая версия не применяется. Это возможно благодаря тому, что transition — прерываемый рендер<br />"
    },
    {
      "question": "Почему <b>useTransition</b> не вызывает повторного рендера сразу?",
      "id": "q-238-ec8eed16",
      "answer": "▪ Обновления внутри <b>startTransition</b> попадают в очередь с низким приоритетом. React может отложить их выполнение, если есть более важные дела<br />"
    },
    {
      "question": "Как <b>useTransition</b> взаимодействует с Suspense?",
      "id": "q-239-3251d0eb",
      "answer": "▪ Если отложенное обновление внутри <b>startTransition</b> приводит к загрузке (<b><Suspense></b> fallback), React отрендерит fallback UI. Так как это transition, fallback будет временным, и пользователь может продолжать взаимодействие<br />"
    },
    {
      "question": "Как <b>useTransition</b> работает с <b>React.memo</b>, и влияет ли отложенное состояние на сравнение props?",
      "id": "q-240-6c424253",
      "answer": "▪ Если переданные props приходят из <b>useDeferredValue</b> или <b>useTransition</b>'а (через <b>state</b>), то <b>React.memo</b> сравнивает их обычным shallowEqual<br /><br />"
    },
    {
      "question": "Что делает <b>useDeferredValue</b> и в чём отличие от <b>useTransition</b>?",
      "id": "q-241-c8a4e42f",
      "answer": "▪ <b>useDeferredValue(value)</b> возвращает отложенную версию value, которая обновляется с низким приоритетом<br />▪ В отличие от <b>useTransition</b>, который оборачивает setState, <b>useDeferredValue</b> применяется к уже вычисленному значению<br />"
    },
    {
      "question": "Что произойдёт, если <b>useDeferredValue</b> применяется к primitive, object, array, function?",
      "id": "q-242-8836b72d",
      "answer": "▪ <b>useDeferredValue</b> работает с любыми типами<br />▪ Для объектов/массивов/функций важно, что сравнение идёт по ссылке, не по содержимому<br />"
    },
    {
      "question": "Как работает сравнение значений prev vs deferred – shallow или deep?",
      "id": "q-243-fb47d639",
      "answer": "▪ React сравнивает по ссылке (reference equality)<br />"
    },
    {
      "question": "Когда <b>useDeferredValue</b> может не вызвать повторного рендера?",
      "id": "q-244-197ea7ec",
      "answer": "▪ Когда value изменился, но новое значение === предыдущему (для примитивов — по значению, для объектов — по ссылке)<br />▪ Также, если deferredValue всё ещё \"догоняет\" старое значение и не успел обновиться<br />"
    },
    {
      "question": "Как работает с <b>React.memo</b> — что попадёт в areEqual(prevProps, nextProps)?",
      "id": "q-245-78984e73",
      "answer": "▪ <b>React.memo</b> сравнивает deferredValue, а не оригинальный value<br />"
    },
    {
      "question": "Что происходит, если исходное значение меняется чаще, чем deferred успевает обновиться?",
      "id": "q-246-04b0e7c6",
      "answer": "▪ deferredValue может \"зависнуть\" на старом значение<br />▪ React может пропустить промежуточные значения и применит только последнее, когда появится «окно» времени<br />▪ Это поведение делает его похожим на автоматический дебаунс<br />"
    },
    {
      "question": "Как использовать <b>useDeferredValue</b> с Suspense и fallback UI?",
      "id": "q-247-9b08c158",
      "answer": "▪ <b>useDeferredValue</b> можно применять к данным, загружаемым через Suspense<br />▪ Отложенный переход позволит сначала показать fallback, не блокируя основной поток<br />▪ Часто комбинируется с <b>useMemo</b> и <b>React.lazy</b><br />"
    },
    {
      "question": "Может ли <b>useDeferredValue</b> вызывать tearing или лаги?",
      "id": "q-248-f50927b1",
      "answer": "▪ Да, если value и deferredValue попадают в разные рендеры компонентов<br />▪ Важно избегать чтения value и deferredValue одновременно в одном компоненте, чтобы не получить рассинхрон<br /><br />"
    },
    {
      "question": "Что делает <b>useSyncExternalStore</b> и в каких случаях он необходим?",
      "id": "q-249-a13c8060",
      "answer": "▪ <b>useSyncExternalStore</b> — это хук React, позволяющий синхронизировать состояние React-компонента с внешним (не React) стором или API<br />▪ Его основная задача — гарантировать, что подписка и чтение состояния извне происходит синхронно и без рассинхронизации. Это особенно важно для Concurrent Mode и SSR<br />"
    },
    {
      "question": "Какие аргументы принимает <b>useSyncExternalStore</b> и что он возвращает?",
      "id": "q-250-d0f8ceab",
      "answer": "▪ <b>subscribe</b> — функция подписки на изменения внешнего стора. Она принимает коллбек, который вызывается при изменении данных, и возвращает функцию отписки<br />▪ <b>getSnapshot</b> — функция, которая синхронно возвращает актуальный снимок (snapshot) состояния из стора. React вызывает её при рендере, чтобы получить текущее состояние<br />▪ <b>getServerSnapshot?</b> — опциональная функция, которая возвращает snapshot для серверного рендера. Используется при SSR для генерации начального состояния, чтобы клиент и сервер были синхронизированы<br />▪ Возвращает текущее состояние (snapshot), которое получено из getSnapshot (или из getServerSnapshot при серверном рендере)<br />"
    },
    {
      "question": "Почему нельзя использовать <b>useState</b>/<b>useEffect</b> для подписки на внешний store?",
      "id": "q-251-9c945a7b",
      "answer": "▪ <b>useState</b> + <b>useEffect</b> создают асинхронные обновления, которые могут привести к рассинхронизации UI<br />▪ При SSR <b>useEffect</b> не вызывается, поэтому компонент на сервере и клиенте может получить разное состояние<br />▪ React не может гарантировать согласованность между рендером и подпиской<br />"
    },
    {
      "question": "Какие проблемы решает <b>useSyncExternalStore</b>?",
      "id": "q-252-8bc82621",
      "answer": "▪ Обеспечивает, что React читает актуальное состояние синхронно во время рендера<br />▪ Позволяет корректно подписываться на внешние изменения и автоматически отписываться при размонтировании или изменении подписки<br />▪ Обеспечивает согласованность состояния между серверным рендером и клиентской гидрацией"
    },
    {
      "question": "Как работает <b>getSnapshot</b> и когда он должен быть стабилен?",
      "id": "q-253-f3462231",
      "answer": "▪ <b>getSnapshot</b> — функция, которая возвращает текущее значение из внешнего стора<br />▪ Она должна быть чистой и стабильной: при отсутствии изменений — возвращать одно и то же значение (сравнение через <b>Object.is</b>)<br />▪ Если данные в сторе не изменились — возвращать тот же объект/примитив, чтобы избежать лишних ререндеров<br />▪ Если <b>getSnapshot</b> возвращает новый объект при каждом вызове — React будет ререндерить компонент бесконечно<br />"
    },
    {
      "question": "Что произойдёт, если <b>getSnapshot</b> возвращает новое значение при каждом вызове?",
      "id": "q-254-eb914319",
      "answer": "▪ Приведёт к бесконечному циклу ререндеров<br />"
    },
    {
      "question": "Как работает подписка — синхронно или асинхронно?",
      "id": "q-255-7971a1a0",
      "answer": "▪ Подписка через <b>subscribe</b> вызывается синхронно при изменениях в сторе<br />▪ React при получении уведомления вызывает <b>getSnapshot</b> и запускает ререндер<br />▪ Подписка должна возвращать функцию отписки"
    },
    {
      "question": "В чём разница между <b>subscribe</b> и <b>getSnapshot</b> по таймингу?",
      "id": "q-256-871c6c20",
      "answer": "▪ <b>subscribe</b> — устанавливает слушателя изменений. Вызывается один раз при монтировании или обновлении хука. subscribe говорит React, когда вызвать getSnapshot<br />▪ <b>getSnapshot</b> — вызывается при каждом рендере и при оповещении о событии изменения, чтобы получить актуальное значение<br />"
    },
    {
      "question": "Как работает SSR-поддержка через <b>useSyncExternalStoreWithSelector</b>?",
      "id": "q-257-d6426289",
      "answer": "▪ В SSR используется третий аргумент <b>getServerSnapshot</b> — возвращает начальное значение стора на сервере<br />▪ При SSR <b>getServerSnapshot</b> вызывается только на сервере и при гидрации клиента<br />▪ Если <b>getServerSnapshot</b> не передан, SSR рендер выбросит ошибку<br />"
    },
    {
      "question": "Что происходит, если snapshot меняется во время рендера?",
      "id": "q-258-5f55340b",
      "answer": "▪ React запускает повторный рендер<br />▪ Это связано с Concurrent Mode: React может дважды вызвать <b>getSnapshot</b> — перед и после применения изменений<br />"
    },
    {
      "question": "Какие ошибки возникают при нестабильном snapshot или unsubscribe?",
      "id": "q-259-a5fa512b",
      "answer": "▪ Бесконечные ререндеры<br />▪ Если <b>subscribe</b> объявлен внутри компонента и меняется на каждом рендере, React будет переподписываться слишком часто, снижая производительность<br />▪ Неправильный unsubscribe приведёт к утечке ресурсов<br /><br />"
    },
    {
      "question": "Чем <b>useInsertionEffect</b> отличается от <b>useEffect</b> и <b>useLayoutEffect</b>?",
      "id": "q-260-9ef09794",
      "answer": "▪ <b>useInsertionEffect</b> вызывается — до того, как React вставит DOM-узлы и выполнит <b>useLayoutEffect</b>. Это самый ранний эффект, нужен для синхронной вставки стилей перед любой отрисовкой<br />"
    },
    {
      "question": "Почему <b>useInsertionEffect</b> нужен для библиотек CSS-in-JS?",
      "id": "q-261-f5ef98c0",
      "answer": "▪ <b>useInsertionEffect</b> позволяет вставить стили до запуска любых layout-эффектов, тем самым гарантируя, что компоненты отрендерятся уже с правильными стилями<br />"
    },
    {
      "question": "Что произойдёт, если внутри <b>useInsertionEffect</b> сделать <b>setState</b>?",
      "id": "q-262-0299f056",
      "answer": "▪ React бросит ошибку или предупредит, потому что вызов обновления состояния в <b>useInsertionEffect</b> может привести к бесконечным циклам рендера и рассинхронизации фаз рендера<br />▪ <b>useInsertionEffect</b> предназначен только для побочных эффектов, не меняющих состояние компонента<br />"
    },
    {
      "question": "Почему нельзя читать DOM внутри <b>useInsertionEffect</b>?",
      "id": "q-263-6cb23ec7",
      "answer": "▪ В момент вызова <b>useInsertionEffect</b> DOM ещё не обновлён новым рендером<br />▪ Чтение DOM может вернуть устаревшие данные или привести к ошибкам, поскольку React только начинает фазу commit, но ещё не применил изменения к DOM<br />"
    },
    {
      "question": "Как <b>useInsertionEffect</b> влияет на порядок вставки CSS и приоритет specificity?",
      "id": "q-264-d63f2000",
      "answer": "▪ <b>useInsertionEffect</b> гарантирует, что стили вставляются раньше всех других эффектов, включая <b>useLayoutEffect</b>. Это обеспечивает правильный порядок <b><style></b>-тегов в <b><head></b>, что важно для корректного применения CSS-правил с нужным приоритетом (specificity)<br />"
    },
    {
      "question": "Что произойдёт, если <b>useInsertionEffect</b> недоступен (например, SSR)?",
      "id": "q-265-3fc6744d",
      "answer": "▪ <b>useInsertionEffect</b> не вызывается на сервере, так как там нет DOM<br /><br />"
    },
    {
      "question": "Как работает <b>useImperativeHandle</b> и зачем он нужен?",
      "id": "q-266-ce2903e4",
      "answer": "▪ Позволяет кастомизировать объект, который родитель получит через ref<br />"
    },
    {
      "question": "Почему важно передавать второй аргумент в <b>forwardRef</b>, а не использовать <b>useRef</b> напрямую?",
      "id": "q-267-b919b893",
      "answer": "▪ В React 18 и ниже ref не приходит как проп — его нужно явно проксировать через <b>forwardRef</b><br />▪ В React 19 <b>forwardRef</b> не нужен и ref можно прокидывать обычным пропсом<br />"
    },
    {
      "question": "Можно ли в <b>useImperativeHandle</b> возвращать функции, которые используют stale props/<b>state</b>?",
      "id": "q-268-74883aa3",
      "answer": "▪ Да, можно, если правильно указать зависимости<br />"
    },
    {
      "question": "В каких случаях стоит избегать <b>useImperativeHandle</b> вообще?",
      "id": "q-269-a71ad335",
      "answer": "▪ Нет необходимости инкапсулировать доступ к DOM<br />▪ Нужное поведение — декларативное, а не императивное<br />▪ Применяется, когда это единственный способ выразить поведение: scroll, focus, animation trigger и т.д<br />"
    },
    {
      "question": "Что произойдёт, если ref в <b>forwardRef</b> null или изменится тип?",
      "id": "q-270-d1635b31",
      "answer": "▪ Если ref === null, <b>useImperativeHandle</b> не выполнится — React ничего не запишет<br />▪ Если ref изменит тип (например, с <b>useRef()</b> на колбэк-реф), React:<br />▪ сначала вызовет cleanup предыдущего handle (если был)<br />▪ потом вызовет createHandle для нового рефа<br /><br />"
    },
    {
      "question": "Как работает <b>useDebugValue</b> и влияет ли он на продакшн-бандл?",
      "id": "q-271-22077a8f",
      "answer": "▪ <b>useDebugValue(value, formatFn?)</b> — это хук, который используется исключительно для отладки в React DevTools<br />▪ Не влияет на поведение компонента, не вызывает побочные эффекты, удаляется на продакшн-сборке<br /><br />"
    },
    {
      "question": "Что делает <b>useOptimistic</b> и как он связан с <b>Server Action</b>s?",
      "id": "q-272-17832eb0",
      "answer": "▪ <b>useOptimistic(</b>state<b>, </b>updateFn<b>)</b> позволяет временно подменять <b>state</b> UI-объектом, отражающим предполагаемый результат асинхронного действия, пока оно не завершится<br />▪ <b>useOptimistic</b> позволяет сразу обновить UI, пока <b>Server Action</b> выполняется<br />▪ После завершения <b>Server Action</b> (успешного или с ошибкой), произойдёт сброс optimistic <b>state</b>, и UI обновится с новыми реальными данными"
    },
    {
      "question": "Как выглядит типичная схема: optimistic update → реальный результат → reconcile?",
      "id": "q-273-abc64a85",
      "answer": "▪ Пользователь отправляет данные<br />▪ <b>addOptimistic</b>(message) вызывается, UI сразу обновляется через <b>updateFn</b><br />▪ В фоне стартует <b>Server Action</b> (или любой async logic).<br />▪ Когда async завершился:<br />▪ Если SSR — сервер возвращает новый <b>state</b>.<br />▪ Если CSR — клиент получает новые данные.<br />▪ UI «reconciles» — т.е. сбрасывается optimisticState → <b>state</b>"
    },
    {
      "question": "Как отменить optimistic <b>state</b> при отмене запроса или ошибке?",
      "id": "q-274-5150990f",
      "answer": "▪ Нет прямого API для отмены optimistic update вручную — React автоматически сбрасывает optimistic <b>state</b><br />▪ произойдёт новый render с обновлённым <b>state</b> (например, после fetch),<br />▪ компонент размонтируется."
    },
    {
      "question": "Можно ли использовать <b>useOptimistic</b> без form и <b>Server Action</b>s?",
      "id": "q-275-74719a93",
      "answer": "▪ Да. <b>useOptimistic</b> — универсальный хук, он не зависит от form или <b>Server Action</b>s, может использоваться в <b>startTransition</b>, <b>onClick</b>, <b>onSubmit</b>, внутри обычного async-обработчика."
    },
    {
      "question": "Что произойдёт, если optimistic value конфликтует с новым реальным <b>state</b>?",
      "id": "q-276-afdaf648",
      "answer": "▪ При следующем ререндере UI заменит optimistic <b>state</b> новым <b>state</b>, полученным извне<br />▪ Конфликтов не будет — <b>useOptimistic</b> не делает дифф между ними."
    },
    {
      "question": "Как <b>useOptimistic</b> влияет на Suspense и конкурентный рендеринг?",
      "id": "q-277-bd7ad99c",
      "answer": "▪ <b>useOptimistic</b> полностью совместим с Concurrent Mode.<br />▪ Он может использоваться внутри <b>startTransition</b> для немутирующего UI-обновления.<br />▪ Работает как низкоприоритетный рендер и не блокирует основной рендер.<br />▪ Если используется в дереве с <Suspense>, то optimistic UI отрендерится до suspense-фолбека."
    },
    {
      "question": "Как работает <b>updateFn</b> и почему важно возвращать новый объект, а не мутировать?",
      "id": "q-278-43d1cee8",
      "answer": "▪ <b>updateFn</b>(<b>state</b>, <b>optimisticValue</b>) должен возвращать новый <b>state</b>.<br />▪ React ожидает иммутабельность — мутирование <b>state</b> не вызовет правильного рендера и может сломать работу."
    },
    {
      "question": "Может ли <b>useOptimistic</b> быть использован с внешними <b>state</b> management (<b>Redux</b>/<b>Zustand</b>)?",
      "id": "q-279-da64c939",
      "answer": "▪ Да, но <b>useOptimistic</b> — локальный хук, он не управляет внешним хранилищем.<br />▪ Он не должен напрямую мутировать <b>Zustand</b>/<b>Redux</b> <b>state</b>.<br />▪ Оптимистичное состояние может быть только для UI, а после успешного запроса обновляется реальный стор:<br /><br />"
    },
    {
      "question": "Чем <b>useActionState</b> отличается от обычного <b>useState</b> + <b>useEffect</b>?",
      "id": "q-280-d8b61924",
      "answer": "▪ <b>useActionState</b> объединяет в себе управление локальным состоянием и вызов асинхронной формы-ориентированной функции (<b>action</b>), обновляя состояние по результату <b>action</b>.<br />▪ В отличие от <b>useState</b> + <b>useEffect</b>, где нужно вручную слушать изменения и обновлять состояние, <b>useActionState</b> автоматически синхронизирует состояние с результатом последнего вызова <b>action</b>."
    },
    {
      "question": "Для чего нужен <b>useActionState</b>?",
      "id": "q-281-8ac62b65",
      "answer": "▪ Управление состоянием, которое обновляется в результате отправки формы или вызова асинхронного <b>action</b>.<br />▪ Синхронизация UI с результатом серверной функции (<b>Server Action</b>) при прогрессивной гидратации и взаимодействии.<br />▪ Облегчение написания интерактивных форм и асинхронных действий без громоздких эффектов."
    },
    {
      "question": "Какие аргументы принимает <b>useActionState</b>?",
      "id": "q-282-f1e9cd22",
      "answer": "▪ - <b>action</b>Fn: асинхронная функция или <b>Server Action</b>, вызываемая при отправке формы. Получает первым аргументом текущий (или предыдущий) <b>state</b>, затем <b>formData</b>.<br />▪ initialState начальное значение состояния до первой отправки формы.<br />▪ permalink (опционально): URL для прогрессивного улучшения на динамических страницах (редиректы до гидратации)."
    },
    {
      "question": "Что возвращает <b>useActionState</b>?",
      "id": "q-283-c7f6dbf7",
      "answer": "▪ Состояние (<b>state</b>) — это значение, которое возвращает переданная функция после выполнения. Изначально оно равно initialState, а потом обновляется при каждом вызове.<br />▪ Функция действия (<b>action</b>) — обёртка над твоей функцией. Её можно передать как <b>action</b>={...} в форму или вызывать вручную. Она принимает <b>formData</b> и вызывает переданную функцию с prevState и <b>formData</b>.<br />▪ Флаг <b>isPending</b> — указывает, выполняется ли сейчас <b>action</b>. Автоматически становится true при запуске и false после завершения, даже если внутри используется await."
    },
    {
      "question": "Как <b>useActionState</b> помогает обрабатывать формы и асинхронные действия?",
      "id": "q-284-b5d235da",
      "answer": "▪ Возвращает изменяемый <b>state</b>, который отражает результат последнего выполненного <b>action</b>.<br />▪ Возвращает модифицированный <b>action</b> (formAction), который следует использовать в <form <b>action</b>={formAction}> или в кнопке с formAction.<br />▪ Автоматически управляет состоянием ожидания (<b>isPending</b>) для UI.<br />▪ Обновляет <b>state</b> после завершения <b>action</b>, вызывая ререндер компонента"
    },
    {
      "question": "Что делает <b>action</b>(prevState, <b>formData</b>) и как использовать <b>formData</b> внутри?",
      "id": "q-285-93a3a21b",
      "answer": "▪ <b>action</b> — функция с подписью (prevState, <b>formData</b>) => newState | Promise<newState>.<br />▪ prevState — текущее состояние формы/компонента до отправки.<br />▪ <b>formData</b> — объект FormData с данными формы, передаваемый при отправке.<br />▪ Внутри <b>action</b> можно обрабатывать <b>formData</b>, вычислять новое состояние на основе предыдущего, возвращать результат синхронно или асинхронно."
    },
    {
      "question": "Как работает взаимодействие с <b>Server Action</b>s?",
      "id": "q-286-3fc18c8e",
      "answer": "▪ При использовании с <b>Server Action</b>s <b>useActionState</b> позволяет получить результат выполнения серверной функции и сразу обновить локальное состояние.<br />▪ При этом форма может быть интерактивной до полной гидратации, так как React уже знает, как обновлять состояние на основе ответа сервера.<br />▪ - permalink позволяет задать URL для прогрессивного улучшения на серверных маршрутах."
    },
    {
      "question": "Что происходит, если <b>action</b> возвращает ошибку — влияет ли это на UI?",
      "id": "q-287-97b4cf51",
      "answer": "▪ Если <b>action</b> выбрасывает ошибку (reject), <b>useActionState</b> не обновит состояние.<br />▪ Ошибка не перехватывается внутри хука — нужно обрабатывать её вручную (например, try/catch внутри <b>action</b> или обрабатывать ошибки глобально).<br />▪ В UI состояние останется прежним, и <b>isPending</b> перейдёт в false.<br />▪ Для отображения ошибок лучше использовать отдельный <b>state</b> или структуру данных, возвращаемую из <b>action</b>."
    },
    {
      "question": "Можно ли вызвать setState внутри <b>action</b> напрямую?",
      "id": "q-288-91d76434",
      "answer": "▪ Нет. <b>action</b> — чистая функция, которая должна возвращать новое состояние.<br />▪ Вызовы локальных React setState вне компонента из <b>action</b> невозможны.<br />▪ Все обновления состояния происходят через возвращаемое значение <b>action</b> и механизм <b>useActionState</b>."
    },
    {
      "question": "Как сбрасывается <b>state</b>, если отправка формы отменена или изменилась?",
      "id": "q-289-58c1cc97",
      "answer": "▪ Если отправка отменена (например, переход на другую страницу), состояние <b>useActionState</b> остаётся текущим до следующей успешной отправки.<br />▪ Если меняется initialState при повторном рендере, он игнорируется после первого действия — состояние сохраняется между отправками.<br />▪ Для сброса состояния нужно либо использовать отдельную логику, либо заново размонтировать компонент"
    },
    {
      "question": "Как <b>useActionState</b> влияет на retry, Suspense и optimistic UI?",
      "id": "q-290-93acd906",
      "answer": "▪ <b>useActionState</b> автоматически обновляет состояние по результату <b>action</b>, что упрощает retry — достаточно повторить вызов <b>action</b>.<br />▪ Поддержка Suspense и progressive hydration реализуется через серверные механизмы React и <b>Server Action</b>s.<br />▪ Для сложного optimistic UI лучше использовать <b>useOptimistic</b> или сторонние подходы, так как <b>useActionState</b> ориентирован на результат <b>action</b>, а не промежуточное состояние."
    },
    {
      "question": "Как синхронизировать состояние <b>useActionState</b> с пропсами?",
      "id": "q-291-2b52c943",
      "answer": "▪ <b>useActionState</b> не синхронизируется с пропсами автоматически. Он использует initialState только один раз при инициализации и больше не реагирует на его изменени<br />▪ Для синхронизации с внешними данными (пропсами или глобальным стором) нужно либо использовать локальный <b>useState</b> и синхронизировать его вручную через <b>useEffect</b>, либо вообще не использовать <b>useActionState</b> и управлять стейтом внешне"
    }
  ]
}