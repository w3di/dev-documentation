{
  "items": [
    {
      "question": "Чем типы <b>any</b> и <b>unknown</b> отличаются в TypeScript и когда использовать каждый?",
      "id": "q-1-aaf3ca65",
      "answer": "▪ <b>any</b> отключает проверку типов и позволяет делать со значением что угодно (любой доступ, вызов, присваивание).<br />▪ <b>unknown</b> безопаснее: требует сужения типа (type guard, проверка) или явного приведения перед использованием.<br />▪ <b>any</b> «протекает» в другие типы и ломает проверку вниз по цепочке; <b>unknown</b> останавливает небезопасные операции на границе.<br />"
    },
    {
      "question": "Чем различаются типы <b>void</b> и <b>never</b> в TypeScript, и где они применяются?",
      "id": "q-2-ece1c6aa",
      "answer": "▪ <b>void</b> — функция возвращает «ничего»; значение можно проигнорировать. <b>Promise<void></b> значит «промис завершится без результата».<br />▪ <b>never</b> — функция не завершается успешно: бросает ошибку или бесконечно работает. Полезно для исчерпывающих проверок (exhaustiveness).<br />▪ <b>never</b> подтип любого типа; ни один тип не подтип <b>never</b> (кроме него самого).<br />"
    },
    {
      "question": "В чём разница между модификатором <b>readonly</b> и утверждением <b>as const</b> в TypeScript?",
      "id": "q-3-cf0480e4",
      "answer": "▪ <b>readonly</b> (в типах/классах/массиве <b>ReadonlyArray<T></b>) делает свойства/элементы неизменяемыми (поверхностно).<br />▪ <b>as const</b> фиксирует литеральные типы (строки/числа), делает объект/кортеж глубоко readonly на уровне вывода типов.<br />▪ Для глубокой иммутабельности в типах используют mapped types (например, <b>DeepReadonly</b>).<br />"
    },
    {
      "question": "Что такое структурная типизация в TypeScript и чем она отличается от номинативной типизации?",
      "id": "q-4-5d7c0e8c",
      "answer": "▪ TypeScript — структурная типизация: совместимость по форме (совпадение набора свойств/сигнатур).<br />▪ Номинативная — по имени объявленного типа. В TS можно имитировать через «брендинг» (добавление уникального поля).<br /><br />"
    },
    {
      "question": "Когда уместнее использовать <b>type</b>, а когда <b>interface</b> в TypeScript? Приведите примеры?",
      "id": "q-5-30f9e5b6",
      "answer": "▪ <b>type</b>: объединения/пересечения, условные/шаблонные типы, алиасы примитивов/кортежей.<br />▪ <b>interface</b>: описание форм объектов/классов; поддерживает <b>extends</b>, <b>implements</b> и декларативное слияние.<br />▪ <b>interface</b> может расширять <b>type</b>, если тот раскрывается в объектный тип (не союз/пересечение).<br />▪ Нельзя выразить union через <b>interface</b>; для этого используют <b>type</b>.<br />"
    },
    {
      "question": "Что означает ключевое слово <b>implements</b> при объявлении класса в TypeScript?",
      "id": "q-6-5901c7e9",
      "answer": "▪ Класс обязан реализовать все свойства и методы интерфейса (совместимые типы и сигнатуры).<br />"
    },
    {
      "question": "Что означает <b>extends</b> в контексте наследования и в ограничениях дженериков (<b>T extends U</b>)?",
      "id": "q-7-14aac5f1",
      "answer": "▪ Наследование классов/интерфейсов: добавляет/переопределяет члены.<br />▪ Ограничение дженериков: <b>T extends U</b> задаёт верхнюю грань для <b>T</b>.<br />"
    },
    {
      "question": "Для чего используется <b>super</b> в классах TypeScript и когда вызывать <b>super()</b>?",
      "id": "q-8-974e1d7f",
      "answer": "▪ Доступ к членам базового класса и вызов конструктора <b>super()</b> в наследнике.<br />"
    },
    {
      "question": "Как правильно типизировать асинхронные функции и значения <b>Promise</b> в TypeScript?",
      "id": "q-9-513c8e18",
      "answer": "▪ <b>async function f(): Promise<R></b> — всегда возвращает <b>Promise<R></b>; <b>return</b> внутри превращается в <b>Promise.resolve</b>.<br />▪ Поддерживается <b>PromiseLike<T></b>; ошибки не типизируются (исключения — структурно <b>unknown</b>).<br /><br />"
    },
    {
      "question": "Какая разница между объединением типов (<b>A | B</b>) и пересечением типов (<b>A & B</b>) в TypeScript?",
      "id": "q-10-8910abaa",
      "answer": "▪ Union (<b>A | B</b>) — значение одного из вариантов; нужен narrowing для доступа к специфичным свойствам.<br />▪ Intersection (<b>A & B</b>) — требуется удовлетворить всем вариантам одновременно (пересечение свойств/контрактов).<br />"
    },
    {
      "question": "Что такое условные типы (<b>Conditional Types</b>) в TypeScript и как они работают?",
      "id": "q-11-c664cfde",
      "answer": "▪ Условные типы: <b>T extends U ? X : Y</b>.<br />▪ Дистрибутивность: <b>T</b> в «голом» виде распределяется по union. Чтобы отключить — обернуть: <b>[T] extends [U] ? X : Y</b>.<br />▪ Часто применяются с <b>infer</b> для извлечения частей типов.<br />"
    },
    {
      "question": "Как устроены дженерики (обобщённые типы) в TypeScript и зачем они нужны?",
      "id": "q-12-91014304",
      "answer": "▪ Обобщения параметризуют типы/функции/классы: <b>function id<T>(x: T): T</b>.<br />▪ Ограничения и значения по умолчанию: <b>T extends U = Default</b>.<br />▪ Важно располагать параметры по убыванию зависимости и задавать дефолты для удобства вызова.<br />"
    },
    {
      "question": "Что делает ключевое слово <b>infer</b> в условных типах TypeScript? Приведите пример?",
      "id": "q-13-0bc8e4e6",
      "answer": "▪ Ключевое слово для вывода части типа в условных типах: <b>T extends Promise<infer R> ? R : T</b>.<br />▪ Поддерживает вариадические кортежи: <b>T extends [...infer H, infer L] ? ...</b>.<br />"
    },
    {
      "question": "Что такое <b>asserts</b> в TypeScript и как им сужают типы (type narrowing)?",
      "id": "q-14-4786d7df",
      "answer": "▪ Предикат: <b>asserts value is Type</b> — сужает тип при успешной проверке.<br />▪ Утверждение: <b>asserts condition</b> — сообщает компилятору, что условие истинно (используется для инвариантов/проверок).<br />"
    },
    {
      "question": "Как вывести тип элемента массива или кортежа в TypeScript (например, <b>T[number]</b>)?",
      "id": "q-15-81bab1f4",
      "answer": "▪ <b>T[number]</b> для массива/кортежа; учитывает литеральные позиции в кортежах.<br /><br />"
    },
    {
      "question": "Как получить тип ключей (<b>keyof</b>) и тип значений (<b>T[keyof T]</b>) объекта в TypeScript?",
      "id": "q-16-7c5f9d72",
      "answer": "▪ Ключи: <b>keyof T</b>.<br />▪ Ключи у значения: <b>keyof typeof obj</b>.<br />▪ Значения: <b>T[keyof T]</b>.<br />▪ Индексный доступ к конкретному свойству: <b>type Age = Person[\"age\"]</b>.<br />▪ Замечание: индексные сигнатуры влияют на <b>keyof</b> (могут дать <b>string | number | symbol</b>).<br />"
    },
    {
      "question": "Что такое вывод типов (Type Inference) в TypeScript и как он работает?",
      "id": "q-17-fe7a5e14",
      "answer": "▪ Автоматический вывод типов: best common type, contextual typing (по месту использования), return type inference.<br />"
    },
    {
      "question": "Какими способами TypeScript автоматически выводит типы (контекстный, по возвращаемому значению и т.д.)?",
      "id": "q-18-6e3632ce",
      "answer": "▪ По присваиваемому значению (включая литералы → литеральные типы, если не расширяются контекстом).<br />▪ По возвращаемому значению функций/методов (если тип не указан).<br />▪ По контексту (параметры колбэков, JSX, вызовы API) и анализу потока управления.<br />"
    },
    {
      "question": "Что такое сужение типов (Type Narrowing) в TypeScript и для чего оно нужно?",
      "id": "q-19-8842128f",
      "answer": "▪ Сужение объединённых типов до более конкретного на основе проверок и анализа кода.<br />"
    },
    {
      "question": "Какими способами TypeScript выполняет сужение типов: <b>typeof</b>, <b>in</b>, <b>instanceof</b>, дискриминант и пользовательские type guards?",
      "id": "q-20-2ad58f06",
      "answer": "▪ <b>typeof</b> — для примитивов (<b>typeof v === \"string\"</b>).<br />▪ Truthiness narrowing — проверка на truthy/falsy (<b>if (user) { ... }</b>).<br />▪ Equality narrowing — сравнение с литералами/<b>null</b>/<b>undefined</b>.<br />▪ Оператор <b>in</b> — наличие свойства в объекте.<br />▪ <b>instanceof</b> — проверка по прототипной цепочке.<br />▪ Discriminated unions — по общему дискриминатору в union.<br />▪ Пользовательские гарды: <b>function isA(x: unknown): x is A { ... }</b>.<br />"
    },
    {
      "question": "Что такое утверждение типа (Type Assertion) в TypeScript и чем оно отличается от явных проверок?",
      "id": "q-21-9a6b4f74",
      "answer": "▪ Явная подсказка компилятору о типе значения: <b>value as Type</b> (не меняет рантайм‑значение).<br />▪ Предпочитать гарды/проверки. Уголочные скобки <b><Type></b> недоступны в <b>.tsx</b> из‑за JSX.<br />▪ Для литеральных значений используйте <b>as const</b>.<br />"
    },
    {
      "question": "Что такое отображаемые типы (Mapped Types) в TypeScript и как применять модификаторы <b>readonly</b> и <b>?</b>?",
      "id": "q-22-f003c1f6",
      "answer": "▪ Построение типа на основе другого: <b>{ [K in keyof T]: T[K] }</b>.<br />▪ Модификаторы: <b>+readonly/-readonly</b>, <b>+?/-?</b> для управления мутабельностью/обязательностью полей.<br />▪ Ремап ключей: <b>{ [K in keyof T as NewKey<K>]: ... }</b>.<br />"
    },
    {
      "question": "Какие утилитные типы есть в TypeScript и для каких задач они используются?",
      "id": "q-23-bd3a745e",
      "answer": "▪ Ключевые: <b>Partial</b>, <b>Required</b>, <b>Readonly</b>, <b>Pick</b>, <b>Omit</b>, <b>Record</b>, <b>Exclude</b>, <b>Extract</b>, <b>NonNullable</b>, <b>ReturnType</b>, <b>InstanceType</b>, <b>Parameters</b>, <b>ConstructorParameters</b>, <b>ThisParameterType</b>, <b>OmitThisParameter</b>, <b>ThisType</b>, <b>Uppercase/Lowercase/Capitalize/Uncapitalize</b>.<br /><br />"
    },
    {
      "question": "Что такое вариадические кортежи (Variadic Tuple Types) в TypeScript и где они полезны?",
      "id": "q-24-313ee6a9",
      "answer": "▪ Кортежи переменной длины с распаковкой: <b>type T = [A, ...B[], C]</b>; <b>infer</b> поддерживает распаковку частей кортежа.<br />"
    },
    {
      "question": "Что такое типы‑шаблоны строк (Template Literal Types) в TypeScript и как их сочетать с объединениями?",
      "id": "q-25-7e27265e",
      "answer": "▪ Строковые шаблоны: можно комбинировать литералы и объединения (<b>\"get-\" | \"set-\"</b> + <b>\"id\" | \"name\"</b>).<br />▪ Модификаторы регистра: <b>Uppercase</b>, <b>Lowercase</b>, <b>Capitalize</b>, <b>Uncapitalize</b>.<br />"
    },
    {
      "question": "Как объявлять перегрузки функций (Function Overloads) в TypeScript и как связана реализация с перегрузками?",
      "id": "q-26-738aab71",
      "answer": "▪ Несколько перегрузок (только сигнатуры) + одна реализация. Порядок — от более узких к более общим.<br />▪ Реализация должна покрывать все перегрузки; внутри — runtime‑проверки и сужения.<br />▪ альтернативой часто служат union‑аргументы и conditional types."
    }
  ]
}