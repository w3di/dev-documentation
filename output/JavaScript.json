{
  "items": [
    {
      "question": "Что такое переменные в JavaScript, и как они работают?",
      "id": "q-1-57d9378a",
      "answer": "▪ это именованные контейнеры, используемые для хранения данных<br />"
    },
    {
      "question": "В чём различия между <b>var</b>, <b>let</b> и <b>const</b> в JavaScript?",
      "id": "q-2-caedf688",
      "answer": "1. <b>var</b>: область видимости функциональная<br />2. <b>let</b> и <b>const</b>: область видимости блочная<br />3. <b>var</b>: можно переобъявлять в одной области видимости<br />4. <b>var</b>: <b>hoisting</b><br />5. <b>let</b> и <b>const</b>: <b>TDZ</b><br />6. <b>var</b> и <b>let</b>: можно объявить без инициализации<br />7. <b>var</b> и <b>let</b>: значения изменяемы (mutable)<br />8. <b>const</b>: ссылка неизменяема (immutable), но содержимое объектов и массивов может изменяться (mutable)<br />"
    },
    {
      "question": "Что такое <b>Temporal Dead Zone</b> и Hoisting? На какие сущности распространяется <b>TDZ</b> а на какие <b>hoisting</b>?",
      "id": "q-3-dafdf746",
      "answer": "▪ Hoisting – это механизм при котором интерпретатор во время фазы компиляции определяет все объявления переменных и функций и регистрирует их в соответствующей области видимости до начала выполнения кода<br />1. <b>var</b> - происходит инициализация значением <b>undefined</b> в начале выполнения кода<br />2. <b>function declaration</b> полностью определяется в начале<br />▪ <b>Temporal Dead Zone</b> - это период времени в процессе исполнения кода, когда переменная, объявленная через <b>let</b> или <b>const</b>, уже определена во внутренней структуре области видимости, но ещё не инициализирована<br />▪ <b>TDZ</b> распространяется на <b>const</b> <b>let</b> и Class<br />"
    },
    {
      "question": "Что такое область видимости (<b>scope</b>) и какие типы области видимости существуют в JavaScript?",
      "id": "q-4-b618f2a3",
      "answer": "▪ Область видимости - это контекст, в рамках которого определяются и становятся доступными переменные, функции и другие объекты<br />▪ типы областей видимости<br />1. глобальная - доступна во всём коде, переменные видимы в любом месте программы<br />2. функциональная - переменные доступны только внутри функции, где они были объявлены<br />3. блочная - переменные доступны только внутри блока {}, где они объявлены<br />4. модульная - переменные и функции доступны только внутри модуля, если они не экспортированы<br />5. лексическая - это механизм, который определяет доступность переменных на основании их расположения в коде во время его написания. Она описывает правила взаимодействия между вложенными областями видимости.<br />▪ Дочерние области видимости могут получать доступ к переменным родительских областей.<br />▪ Родительские области видимости не имеют доступа к переменным дочерних областей<br />"
    },
    {
      "question": "Что такое <b>Lexical Environment</b> и <b>Scope Chain</b>, и как они работают?",
      "id": "q-5-3aa20594",
      "answer": "▪ <b>Lexical Environment</b> - это структура которая состоит из<br />▪ Environment Record - информации о переменные и функции, объявленные в данном контексте или области видимости<br />▪ сcылку на родительский <b>Lexical Environment</b><br />▪ <b>Scope Chain</b> - это механизм, с помощью которого интерпретатор выполняет поиск переменных и функций, начиная с текущего <b>Lexical Environment</b> и последовательно переходя к его родительским окружениям, вплоть до глобального <b>Lexical Environment</b>.<br />"
    },
    {
      "question": "Какие типы данных существуют в JavaScript и чем отличаются примитивные и ссылочные типы данных?",
      "id": "q-6-bfb85174",
      "answer": "1. Примитивные хранятся непосредственно, они имутабельные сравниваются по значние и хрянятся в стеке<br />2. Ссылочные хранятся по ссылки, они мутабельные сравниваются по ссылке и хранятся в куче, а ссылка на него в стеке<br />"
    },
    {
      "question": "Какие типы данных в JavaScript являются примитивными?",
      "id": "q-7-5cf56f87",
      "answer": "1. <b>string</b><br />2. <b>number</b><br />3. <b>bigInt</b><br />4. <b>undefined</b><br />5. <b>null</b><br />6. <b>symbol</b><br />7. <b>boolean</b><br />"
    },
    {
      "question": "Что такое <b>Symbol</b> и для чего они используются в JavaScript?",
      "id": "q-8-1113ed44",
      "answer": "▪ уникальность и неизменность примитивный тип данных<br />▪ уникальные ключи для объектов<br />▪ создание скрытых свойств<br />▪ уникальные идентификаторы<br />"
    },
    {
      "question": "Как работает <b>BigInt</b> и для чего он нужен?",
      "id": "q-9-bdeacc92",
      "answer": "▪ для работы с целыми числами которые выходят за границы обычного <b>number</b><br />▪ несовместим без приведения типов с <b>number</b><br />▪ Для обозначения числа как <b>BigInt</b>, необходимо добавить суффикс n<br />"
    },
    {
      "question": "В чем разница между <b>null</b> и <b>undefined</b>?",
      "id": "q-10-6fd7232c",
      "answer": "▪ <b>null</b> для явного указания пустоты или обнуление<br />▪ <b>undefined</b> когда не присвоено значение или у объекта отсутствует свойство"
    },
    {
      "question": "Когда и почему можно ожидать значение <b>undefined</b>?",
      "id": "q-11-e8919784",
      "answer": "1. Обращение к переменной, объявленной через <b>var</b> до её инициализации:<br />2. Функции, которые ничего не возвращают<br />3. Переменные, объявленные с помощью <b>let</b> без инициализации<br />4. Обращение к несуществующему свойству объекта<br />5. Неинициализированные параметры функции<br />6. Элементы массива, которым не присвоено значение<br />7. Деструктуризация без соответствующего значения<br />"
    },
    {
      "question": "В чём разница между <b>Number.isNaN</b>() и <b>isNaN</b>() в JavaScript, и какой предпочтительнее использовать?",
      "id": "q-12-38ac834b",
      "answer": "▪ <b>isNaN</b>() - пытается преобразовать переданный аргумент в число перед проверкой<br />▪ <b>Number.isNaN</b>() безя преобразовагтя проверяет переданный аргумент<br />"
    },
    {
      "question": "Что вернёт <b>typeof</b> для <b>null</b>, и что вернёт <b>typeof</b> для функции? Почему?",
      "id": "q-13-0a9d1ca2",
      "answer": "▪ <b>object</b> так как исторической особенностью JavaScript<br />▪ <b>function</b><br />"
    },
    {
      "question": "Что такое приведение типов (<b>type coercion</b>) и явное преобразование (<b>type conversion</b>) в JavaScript? Примеры каждого?",
      "id": "q-14-59494e52",
      "answer": "▪ Приведение типов(<b>type coercion</b>, неявное преобразование) — это автоматическое преобразование '5' + 2 → '52', '5' - 2 → 3<br />▪ Преобразование типов (Type Conversion, явное преобразование) — это явное преобразование Number('5') → 5, String(123) → '123'<br />"
    },
    {
      "question": "Какие значения  при приведении к булевому типу (<b>boolean</b>) возвращают false?",
      "id": "q-15-a1de8004",
      "answer": "1. <b>0</b><br />2. <b>0n</b><br />3. <b>''</b><br />4. <b>undefined</b><br />5. <b>null</b><br />6. <b>NaN</b><br />"
    },
    {
      "question": "В чём разница между глубоким (deep) и поверхностным (shallow) копированием объектов в JavaScript?",
      "id": "q-16-82a704dc",
      "answer": "▪ Глубокое копирование копирует все уровни вложенности так что изменения в копии не затрагивают оригинальный объект.<br />▪ Поверхностное копирование копирует только верхний уровень объекта, при этом вложенные объекты и массивы копируются по ссылке и ссылки на вложенные структуры сохраняются.<br />"
    },
    {
      "question": "Что такое <b>Map</b> в JavaScript, чем он отличается от обычного объекта и от Weak<b>Map</b>?",
      "id": "q-17-1f3ae108",
      "answer": "▪ <b>Map</b> это  объект который представляет собой коллекцию пар ключ-значение<br />▪ Отличие от обычного объекта:<br />1. ключи могут быть любого типа<br />2. порядок вставки ключей сохраняется<br />3. оптимизирован для операций поиска вставки и удаления по ключ<br />▪ Отличие <b>Map</b> от <b>WeakMap</b><br />1. В <b>WeakMap</b> ключами могут быть только объекты<br />2. В <b>WeakMap</b> нет методов для перечисления ключей или значений (keys(), values(), entries())<br />3. Ключи в <b>WeakMap</b> являются \"слабыми ссылками\". Если на объект-ключ больше нет ссылок из других мест программы, он автоматически удаляется из Weak<b>Map</b> при сборке мусора<br />"
    },
    {
      "question": "Что такое <b>Set</b> в JavaScript, для каких задач он используется и чем отличается от <b>WeakSet</b>?",
      "id": "q-18-a7e599dc",
      "answer": "▪ <b>Set</b> это  объект который представляет собой коллекцию уникальных значений любого типа.<br />▪ <b>WeakSet</b> хранит только объекты<br />▪ У <b>WeakSet</b> нет методов для итерации (<b>forEach</b>, keys, values и т.д.), так как элементы могут удаляться динамически.<br />▪ <b>WeakSet</b> не предотвращает сборку мусора. Если объект больше не доступен в коде, он удаляется из <b>WeakSet</b> автоматически.<br />"
    },
    {
      "question": "Как устроено прототипное наследование в JavaScript и как оно работает?",
      "id": "q-19-203e87d7",
      "answer": "▪ через <b>proto</b> - ссылка на объект прототипа<br />"
    },
    {
      "question": "Что такое функции в JavaScript и для чего они используются?",
      "id": "q-20-406c8358",
      "answer": "▪ функция - это блок кода, который выполняет определённую задачу, и её можно многократно вызывать в разных частях кода."
    },
    {
      "question": "Какие существуют способы объявления функций в JavaScript и чем они отличаются?",
      "id": "q-21-6d32f146",
      "answer": "1. <b>Function Declaration</b><br />2. <b>Function Expression</b><br />3. <b>Arrow Function</b><br />4. <b>IIFE</b><br />"
    },
    {
      "question": "Что такое анонимные функции, и какие из способов объявления функций поддерживают их?",
      "id": "q-22-bfbe0ee0",
      "answer": "▪ Это функция без имени, которая создается в моменте и используется сразу в нужном контексте, например, для передачи в качестве аргумента, колбэка или внутри методов.<br />▪ поддерживается:<br />1. <b>Function Expression</b><br />2. <b>Arrow Function</b><br />3. <b>IIFE</b><br />"
    },
    {
      "question": "Какие способы объявления функций поднимаются механизмом <b>hoisting</b> и как именно?",
      "id": "q-23-a0978bd3",
      "answer": "▪ все способы объявления функций поддерживают <b>hoisting</b>, но для способов отличных от  <b>Function Declaration</b> применяется еще <b>TDZ</b><br />"
    },
    {
      "question": "В чём отличие функций‑конструкторов от классов в JavaScript?",
      "id": "q-24-edf2a860",
      "answer": "1. классы это синтаксический сахар<br />2. на классы распространятеся <b>TDZ</b> в отлчии от функции-конструкторы который инициилизруются сразу<br />3. Class всегда работает в строгом режиме<br />"
    },
    {
      "question": "Что такое стрелочные функции в JavaScript и чем они отличаются от обычных функций?",
      "id": "q-25-462a43c1",
      "answer": "▪ Стрелочные функции - это синтаксический сахар для более короткого определения функций. Они имеют ряд особенностей, таких как отсутствие своего <b>this</b>, <b>arguments</b> и поддерживают <b>TDZ</b><br />"
    },
    {
      "question": "Что такое Immediately Invoked <b>Function Expression</b> (<b>IIFE</b>) и для чего она используется?",
      "id": "q-26-27ac294d",
      "answer": "▪ <b>IIFE</b> - это функция, которая определяется и немедленно вызывается. Она используется для создания изолированной области видимости<br />"
    },
    {
      "question": "Что такое функции-генераторы в JavaScript?",
      "id": "q-27-5966d491",
      "answer": "▪ вид функций, позволяющий приостанавливать и возобновлять их выполнение, а также возвращать промежуточные значения в процессе работы<br />"
    },
    {
      "question": "Что такое функции обратного вызова (<b>callback</b>) в JavaScript и зачем они нужны?",
      "id": "q-28-2be131e3",
      "answer": "▪ это функции, которые передаются в качестве аргумента другой функции и вызываются внутри этой функции после выполнения определённого действия или при наступлении определённого события.<br />"
    },
    {
      "question": "Что такое мемоизация функций и в каких случаях она полезна?",
      "id": "q-29-5a934c7c",
      "answer": "▪ техника оптимизации, при которой результаты вызова функции запоминаются в зависимости от переданных аргументов.<br />▪ Трудоёмкие вычисления, повторяющиеся вызовы и тд<br />"
    },
    {
      "question": "Что означает, что функции в JavaScript — объекты первого класса (first‑class)?",
      "id": "q-30-289a1d67",
      "answer": "▪ это функции, которые можно:<br />1. Присваивать переменной.<br />2. Передавать в качестве аргумента другой функции.<br />3. Возвращать из другой функции."
    },
    {
      "question": "Что такое рекурсия и когда её применять на практике?",
      "id": "q-31-aeabef71",
      "answer": "▪ функция вызывает сама себя<br />"
    },
    {
      "question": "Что такое объект <b>arguments</b> в JavaScript и в каких способах объявления он недоступен? Почему?",
      "id": "q-32-686dec91",
      "answer": "▪ это встроенный в функции объект, который содержит массивоподобный список всех аргументов, переданных в функцию<br />▪ не поддерживается в <b>arrow function</b>, лучше использовать <b>rest-параметры</b> (остаточный оператор)<br />"
    },
    {
      "question": "Что такое rest‑параметры и оператор расширения (spread) в JavaScript и как их использовать?",
      "id": "q-33-e90f17b3",
      "answer": "▪ <b>Rest-параметры</b> позволяют объявить функцию, которая может принимать любое количество аргументов, сгруппированных в один массив, аналог <b>arguments</b><br />▪ <b>Spread-оператор</b> — позволяет раскрыть итерируемый объект в набор отдельных элементов или свойств там, где ожидается перечисление значений<br />"
    },
    {
      "question": "Что представляет собой ключевое слово <b>this</b> и как определяется его контекст в разных ситуациях?",
      "id": "q-34-8a432d00",
      "answer": "▪ <b>this</b> представляет собой ссылку на текущий контекст выполнения, который определяется способом вызова функции<br />1. В глобальной области видимости.<br />1. строгом режиме равен <b>undefined</b><br />2. браузера им является объект <b>window</b><br />3. в среде Node.js – объект global<br />1. В методе объекта.<br />▪ на контекст объекта<br />1. В функции-конструкторе.<br />▪ на контекст объекта созданный этой функцией оператором new<br />1. В стрелочных функциях.<br />▪ на контекст родителя<br />"
    },
    {
      "question": "Что такое замыкание (<b>closure</b>) и как оно работает?",
      "id": "q-35-e12d1ebe",
      "answer": "▪ замыкание - это механизм, при котором функция запоминает свое лексическое окружение, то есть контекст, в котором она была создана, и сохраняет доступ к этим переменным даже после завершения выполнения внешней функции, из которой она была вызвана.<br />"
    },
    {
      "question": "В чем разница между методами <b>call</b>(), <b>apply</b>() и <b>bind</b>() в JavaScript, и когда использовать каждый из них?",
      "id": "q-36-f9d7e3be",
      "answer": "▪ Методы <b>call</b>(), <b>apply</b>() и <b>bind</b>() в JavaScript используются для управления контекстом вызова функции<br />▪ <b>call</b>() - вызывает функцию немедленно, с указанным значением <b>this</b> и переданными аргументами по отдельности.<br />▪ <b>apply</b>() - вызывает функцию немедленно, с указанным значением <b>this</b> и переданными аргументами в виде массива.<br />▪ <b>bind</b>() возвращает новую функцию с указанным значением <b>this</b> и фиксированными аргументами (если они переданы), в отличии от других методов функция не вызывается сразу и может быть вызвана в дальнейшем уже с изменым контекстом<br />"
    },
    {
      "question": "В чём разница между синхронным и асинхронным кодом в JavaScript?",
      "id": "q-37-7b6cf6ad",
      "answer": "▪ Синхронный код<br />▪ Выполняется последовательно, инструкция за инструкцией<br />▪ блокирует выполнение дальнейшего кода до завершения текущей операции<br />▪ Асинхронный код<br />▪ операции выполняются в фоне, позволяя основному потоку продолжать выполнение без блокировки<br />"
    },
    {
      "question": "Что такое <b>Event Loop</b> в JavaScript и как он работает?",
      "id": "q-38-763b2d8c",
      "answer": "▪ <b>Event Loop</b> - механизм, обеспечивающий выполнение асинхронного кода в однопоточном окружении<br />▪ как работает:<br />1. Выполняется весь синхронный код<br />2. Выполняются все задачи из очереди микрозадач<br />3. Берется первая задача из очереди макрозадач и выполняется<br />4. При необходимости обновляется пользовательский интерфейс<br />5. Цикл возвращается к обработке очереди микрозадач<br />▪ При отсутствии задач <b>Event Loop</b> продолжает ожидание новых событий<br />"
    },
    {
      "question": "Что такое стек вызовов (<b>Call Stack</b>) и как он взаимодействует с асинхронным кодом?",
      "id": "q-39-a3ba6dc2",
      "answer": "▪ <b>Call Stack</b> - это структура данных, используемая движком JavaScript для отслеживания выполнения функций в программе. Он работает по принципу LIFO (Last In, First Out), то есть последняя вызванная функция обрабатывается первой.<br />"
    },
    {
      "question": "Что такое очереди задач: <b>macrotasks</b> и <b>microtasks</b>, и как они влияют на порядок выполнения кода?",
      "id": "q-40-84aff06d",
      "answer": "▪ Когда асинхронная задача попадает в <b>Call Stack</b>, она передается во внешнюю систему, которая после завершения добавляет её <b>callback</b> в macroTasks Queue или microTasks Queue. Когда <b>Call Stack</b> становится пустым, сначала обрабатываются задачи из macroTasks Queue, а затем из microTasks Queue"
    },
    {
      "question": "Приведите примеры микрозадач (<b>microtasks</b>) и макрозадач (<b>macrotasks</b>) в JavaScript?",
      "id": "q-41-a2b6c541",
      "answer": "▪ MicroTasks:<br />1. .<b>then()</b> .<b>catch()</b>  .<b>finally()</b><br />2. MutationObserver<br />3. queueMicrotask()<br />▪ Macrotasks:<br />1. <b>setTimeout</b> <b>setInterval</b><br />2. <b>DOM</b> Events<br />3. setImmediate<br />4. Сетевые запросы<br />"
    },
    {
      "question": "Как работают setImmediate() и queueMicrotask() и чем они отличаются?",
      "id": "q-42-497bdf0d",
      "answer": "▪ setImmediate(): помещает задачу в очередь макрозадач<br />▪ queueMicrotask(): помещает задачу в очередь микрозадач<br />"
    },
    {
      "question": "Что такое промисы (<b>Promise</b>) в JavaScript и какие у них есть состояния?",
      "id": "q-43-ec54699b",
      "answer": "▪ <b>Promise</b> — это объект в JavaScript, который представляет результат асинхронной операции<br />▪ у него есть 3 состояния<br />1. ожидание (<b>pending</b>)<br />2. выполнено (<b>fulfilled</b>)<br />3. отклонено (<b>rejected</b>)<br />"
    },
    {
      "question": "Как работают <b>Promise.all()</b>, <b>Promise.allSettled()</b>, <b>Promise.race()</b> и <b>Promise.any()</b>? Какие есть дополнительные статические методы промисов?",
      "id": "q-44-10400fc4",
      "answer": "▪ <b>Promise.all()</b> — ждет выполнения всех промисов, прерывается, если один промис отклонен<br />▪ <b>Promise.allSettled()</b> — ждет завершения всех промисов в независимости от их статуса<br />▪ <b>Promise.race()</b> — возвращает первый выполненный промис.<br />▪ <b>Promise.any()</b> — возвращает первый выполненный успешно промис, игнорируя ошибки<br />▪ <b>Promise.reject()</b> - cоздает промис, который немедленно переходит в состояние <b>rejected</b> с указанной причиной ошибки<br />▪ <b>Promise.resolve()</b> - cоздает промис, который немедленно переходит в состояние <b>fulfilled</b> с указанным значением<br />▪ <b>Promise.withResolvers()</b> - синтаксического сахар,  статический метод, который создает новый промис и одновременно возвращает объект, содержащий<br />1. сам promise,<br />2. функцию resolve для его успешного завершения,<br />3. функцию reject для его отклонения.<br />▪ <b>Promise.try()</b> - синтаксического сахар, способ безопасно «обернуть» синхронный код, который может выбросить ошибку, в <b>Promise</b>, аналог <b>Promise.resolve()</b>.<b>then</b>(() => {})<br />"
    },
    {
      "question": "Как работает метод .<b>then()</b> у промисов и что он возвращает?",
      "id": "q-45-972b67d8",
      "answer": "▪ Метод .<b>then()</b> для обработки выполнения промиса, возвращает новый промис.<br />▪ Он принимает два аргумента:<br />1. onFulfilled — функция, выполняемая при успешном разрешении промиса.<br />2. onRejected (опционально, типа <b>catch</b>, но как аргумент <b>then</b>) — функция для обработки ошибок.<br />"
    },
    {
      "question": "Какие механизмы обработки ошибок есть в JavaScript? Как работает <b>try...catch</b> и что делает <b>finally</b>?",
      "id": "q-46-f84c0144",
      "answer": "▪ механизмы обработки ошибок<br />1. аргумент onRejected в .<b>then()</b><br />2. try...<b>catch</b><br />3. throw<br />4. Обработка ошибок с помощью <b>Promise</b> и <b>catch()</b><br />▪ <b>try...catch...finally</b><br />1. <b>try()</b> - Включает код, выполнение которого может вызвать ошибку<br />2. <b>catch()</b> - Срабатывает только в том случае, если в try блоке возникает ошибка<br />3. <b>finally()</b> - Выполняется всегда, независимо от того, была ли ошибка или нет<br />"
    },
    {
      "question": "Что такое объект <b>Error</b> в JavaScript и какие его свойства чаще всего используются (<b>message</b>, <b>name</b>, <b>stack</b>)?",
      "id": "q-47-c772f771",
      "answer": "▪ Объект <b>Error</b> в  предназначен для создания ошибок и их обработки<br />▪ Основные свойства объекта <b>Error</b><br />1. <b>message</b>  -  текстовое сообщение об ошибке, переданное в конструктор объекта.<br />2. <b>name</b> - имя ошибки, по умолчанию это <b>Error</b>.<br />3. <b>stack</b>  - информацию о стеке вызовов.<br />"
    },
    {
      "question": "Что такое <b>async</b>/<b>await</b> и как они работают с промисами?",
      "id": "q-48-053269f6",
      "answer": "▪ синтаксический сахар для работы с промисами<br />▪ <b>async</b> Делает функцию асинхронной, что позволяет использовать внутри неё <b>await</b> и возвращает всегда promis<br />▪ <b>await</b> приостанавливает выполнение асинхронной функции до разрешения промиса и возвращает его результат<br />"
    },
    {
      "question": "Как работают таймеры <b>setTimeout</b> и <b>setInterval</b> и чем они отличаются?",
      "id": "q-49-4506e001",
      "answer": "▪ <b>setTimeout</b> - запускает функцию один раз после указанного времени задержки<br />▪ очистка - <b>clearTimeout</b><br />▪ <b>setInterval</b> - запускает функцию периодически с указанным интервалом времени до тех пор, пока таймер не будет остановлен<br />▪ очистка - <b>clearInterval</b><br />"
    },
    {
      "question": "Что такое <b>callback</b> hell (pyramid of doom) и как с ним бороться?",
      "id": "q-50-79b710bb",
      "answer": "▪ несколько вложенных обратных вызовов создают сложный код с глубокими отступами<br />▪ Решение:<br />1. <b>async</b>/<b>await</b><br />2. promises<br />3. модульность"
    },
    {
      "question": "Что такое состояние гонки (<b>race condition</b>) и как его избегать в JavaScript?",
      "id": "q-51-02ac5abc",
      "answer": "ситуация, возникающая при параллельном выполнении операций, когда результат зависит от неконтролируемого порядка их завершения"
    },
    {
      "question": "Что такое дебаунсинг (<b>debouncing</b>) и троттлинг (<b>throttling</b>) и когда их применять?",
      "id": "q-52-b1039cd3",
      "answer": "▪ это техники оптимизации для обработки событий<br />▪ Debouncing - предотвращает выполнение функции, пока события происходят часто, и позволяет её вызвать только один раз, через заданную задержку после того, как поток событий прекратился.<br />▪ Throttling - позволяет функции выполняться регулярно, но не чаще, чем раз в заданный интервал времени, даже если события происходят беспрерывно."
    },
    {
      "question": "Что такое цепочка промисов (<b>promise chaining</b>) и зачем она нужна?",
      "id": "q-53-a3f9682c",
      "answer": "▪ техника последовательного выполнения асинхронных операций с использованием цепочки промисов. Каждый .<b>then</b> передаёт результат следующему обработчику."
    },
    {
      "question": "Что такое «<b>deadlock</b>» (взаимная блокировка) и почему в JavaScript такое встречается редко?",
      "id": "q-54-c3048411",
      "answer": "▪ ситуация, при которой два или более процесса ждут друг друга, блокируя выполнение всех операций<br />▪ Избежание:<br />1. Упорядочивание захватов блокировок.<br />2. Использование таймаутов при ожидании блокировок.<br />3. Минимизация использования блокировок."
    },
    {
      "question": "Какие методы массивов (<b>map</b>, <b>filter</b>, <b>reduce</b> и др.) используются для работы с данными и чем они полезны?",
      "id": "q-55-6c7f9eb5",
      "answer": "▪ <b>map</b> - Применяет функцию к каждому элементу массива и возвращает новый массив с результатами.<br />▪ <b>forEach</b> - Применяет функцию для каждого элемента массива, но ничего не возвращает<br />▪ filtred - создает новый массив, содержащий только элементы, которые удовлетворяют заданному условию.<br />▪ <b>reduce</b> - преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору<br />▪ <b>reduce</b>Right - аналогичен <b>reduce</b>, но обход массива выполняется справа налево.<br />▪ <b>find</b> - возвращает первый элемент массива, который удовлетворяет заданному условию, или <b>undefined</b>, если такого элемента нет.<br />▪ <b>find</b>Index - возвращает индекс первого элемента, который удовлетворяет заданному условию, или -1, если такого элемента нет.<br />▪ <b>indexOf</b> - возвращает первый индекс указанного элемента в массиве или -1, если элемент не найден.<br />▪ <b>lastIndexOf</b> - возвращает последний индекс указанного элемента в массиве или -1, если элемент не найден.<br />▪ <b>includes</b> - проверяет, содержит ли массив указанный элемент, возвращает true или false.<br />▪ <b>some</b> - возвращает true, если хотя бы один элемент массива удовлетворяет условию.<br />▪ <b>every</b> - возвращает true, если все элементы массива удовлетворяют условию."
    },
    {
      "question": "Чем отличается <b>forEach</b> от <b>map</b> и когда использовать каждый?",
      "id": "q-56-bfb6f170",
      "answer": "▪ <b>forEach</b> - выполнить какую-либо операцию над элементами массива<br />▪ <b>map</b> - возвращает новый массив с преобразованными данными."
    },
    {
      "question": "Что делает метод <b>reduce</b> и когда он может заменить другие методы работы с массивами?",
      "id": "q-57-7277f170",
      "answer": "▪ преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору"
    },
    {
      "question": "Чем отличается копирование массива с помощью <b>slice</b>, оператора spread и <b>Array.from</b>()?",
      "id": "q-58-b4a79b52",
      "answer": "▪ <b>slice</b> - позволяет копировать часть массива (подмассив) с указанием границ индексов.<br />▪ spread-оператора - поддерживает объединение массивов и добавление новых элементов в процессе копирования.<br />▪ <b>Array.from</b>() - работает с массивоподобными объектами (например, <b>arguments</b> или <b>DOM</b>-коллекциями) и позволяет преобразовывать элементы при копировании."
    },
    {
      "question": "Что такое <b>DOM</b> и как он представляет структуру HTML‑документа?",
      "id": "q-59-9780e8b6",
      "answer": "▪ <b>Document Object Model</b> - это представление HTML-документа в виде структуры дерева. Каждый элемент HTML (тег) становится узлом дерева. <b>DOM</b> позволяет взаимодействовать с HTML-документом, изменять его структуру, содержимое и стили при помощи JavaScript"
    },
    {
      "question": "Сколько существует типов узлов <b>DOM</b> и какие это типы?",
      "id": "q-60-5e615b96",
      "answer": "▪ 12 типов узлов<br />1. <b>Element Node</b><br />2. <b>Text Node</b><br />3. <b>Comment Node</b><br />4. ...."
    },
    {
      "question": "Какие фазы распространения события в <b>DOM</b> существуют и что происходит на каждой?",
      "id": "q-61-68b825d7",
      "answer": "1. Фаза захвата (<b>Capturing phase</b>) - Событие распространяется сверху вниз по дереву <b>DOM</b>, начиная с корневого элемента (<b>window</b>) и проходя через всех предков целевого элемента.<br />2. Фаза цели (<b>Target phase</b>) - Событие достигает целевого элемента, на котором оно произошло. Обработчики, привязанные к целевому элементу, выполняются.<br />3. Фаза всплытия (<b>Bubbling phase</b>) - Событие поднимается обратно вверх по дереву <b>DOM</b> от целевого элемента к его предкам."
    },
    {
      "question": "Что такое <b>CSSOM</b> и чем он отличается от <b>DOM</b>?",
      "id": "q-62-40a48791",
      "answer": "▪ <b>CSS Object Model</b> - это объектная модель CSS, которая представляет стили CSS в виде структуры дерева. <b>CSSOM</b> создается браузером при разборе CSS-стилей (как встроенных, так и внешних). Она позволяет JavaScript взаимодействовать с CSS — например, получать или изменять стили элементов на странице."
    },
    {
      "question": "Как связаны <b>DOM</b> и <b>CSSOM</b> и как вместе используются браузером?",
      "id": "q-63-5f9602b0",
      "answer": "▪ <b>DOM</b> и <b>CSSOM</b> объединяются для создания render-three которое уже используется  для отрисовки страницы"
    },
    {
      "question": "Как оптимизировать работу <b>DOM</b> и <b>CSSOM</b> для повышения производительности?",
      "id": "q-64-a0b99cf3",
      "answer": "▪ <b>DOM</b><br />1. минимизация количества узлов и элементов<br />2. применять изменения в дереве разом для всего а не по одному<br />3. использования lazy loading<br />▪ <b>CSSOM</b><br />1. удаление ненужных стилей<br />2. уменьшения css файлов<br />3. минимизицаия сложности селекторов"
    },
    {
      "question": "Что такое <b>reflow</b>, <b>repaint</b> и <b>compositing</b> в браузере и чем они отличаются? Примеры?",
      "id": "q-65-ae1b272a",
      "answer": "▪ Reflow, Repaint, Compositing - процессы, связанные с рендерингом веб-страницы, которые происходят при изменениях в <b>DOM</b> и <b>CSSOM</b>.<br />▪ Reflow -  процесс, при котором браузер пересчитывает размеры и расположение элементов на странице<br />▪ Repaint - процесс, при котором браузер обновляет визуальное представление элементов без изменения их геометрии<br />▪ Compositing - процесс, при котором браузер объединяет слои, сформированные после рендеринга, в окончательную визуализацию страницы, чтобы отобразить её на экране."
    },
    {
      "question": "Что такое Shadow <b>DOM</b> и для чего он используется?",
      "id": "q-66-be446d25",
      "answer": "▪ технология, которая позволяет создавать инкапсулированные <b>DOM</b>-деревья в веб-компонентах."
    },
    {
      "question": "Какие проблемы решает Shadow <b>DOM</b> (инкапсуляция стилей, изоляция, переиспользование)?",
      "id": "q-67-2d633f8a",
      "answer": "1. Конфликты стилей<br />2. модульность?<br />3. изоляция"
    },
    {
      "question": "Что такое <b>BOM</b> (<b>Browser Object Model</b>) и какие возможности он предоставляет?",
      "id": "q-68-acd97bc8",
      "answer": "▪ <b>Browser Object Model</b> -  интерфейс, предоставляемый браузером для взаимодействия с окном браузера и его функциями"
    },
    {
      "question": "Какие основные компоненты <b>BOM</b> существуют и для чего они?",
      "id": "q-69-041a6203",
      "answer": "▪ компоненты<br />1. <b>window</b><br />2. <b>document</b><br />3. <b>navigator</b><br />4. <b>location</b><br />5. <b>history</b>"
    },
    {
      "question": "Что такое <b>render tree</b> и как он строится на основе <b>DOM</b> и <b>CSSOM</b>?",
      "id": "q-70-2eecb033",
      "answer": "1. Браузер комбинирует <b>DOM</b> и <b>CSSOM</b>, чтобы построить Render Tree.<br />2. Render Tree включает только видимые элементы и их стили:<br />3. Элементы с display: none исключаются из Render Tree.<br />4. Элементы с visibility: hidden остаются в Render Tree, так как занимают место, но не видимы.<br />5. Если <b>DOM</b> или <b>CSSOM</b> изменяются (например, через JavaScript), Render Tree пересчитывается."
    },
    {
      "question": "Как браузер рендерит документ: этапы от получения байтов до отображения?",
      "id": "q-71-7e823cdc",
      "answer": "1. Получает данные (байты) от сервера.<br />2. Разбирает и преобразует в токены (<, ИмяТега, Атрибут, ЗначениеАтрибута, >).<br />3. Превращает токены в узлы.<br />4. Превращает узлы в дерево <b>DOM</b>.<br />5. Создаёт дерево <b>CSSOM</b> из правил CSS.<br />6. Деревья <b>CSSOM</b> и <b>DOM</b> объединяются в дерево рендеринга (RenderTree).<br />7. Вычисляет, какие элементы видимы и их вычисленные стили:<br />1. Начиная с корня дерева <b>DOM</b><br />2. Невидимые элементы, такие как (meta, script, link) и display: none, исключаются из дерева рендеринга<br />3. Для каждого видимого узла находит соответствующие правила <b>CSSOM</b> и применяет их<br />8. Reflow: вычисляет макет каждого видимого элемента (положение и размер)<br />9. Repaint: рендерит пиксели на экране<br />10. Compositing:<br />1. После Repaint браузер объединяет различные слои (например, слои с эффектами, анимацией, позиционированными элементами) в итоговый кадр<br />2. Логика композитинга может включать отрисовку слоёв в правильном порядке, обработку прозрачности, тени и других визуальных эффектов<br />3. Завершается отправкой кадра на <b>GPU</b> для отображения"
    }
  ]
}