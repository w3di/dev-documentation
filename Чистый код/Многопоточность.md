# Многопоточность

### Мифы и реальность

- Многопоточность повышает быстродействие не всегда — только при существенном времени ожидания (I/O, ожидание ответов)
- Многопоточность меняет архитектуру: отделение «что» от «когда» сильно влияет на структуру системы
- Даже при использовании контейнеров (сервлеты, EJB) нужно понимать конкуренцию и уметь защищаться от гонок и взаимных блокировок
- Многопоточность даёт дополнительные затраты (код, сложность); ошибки часто не воспроизводятся и списываются на «случайность», хотя это системные дефекты

### Принцип единой ответственности для многопоточности

- Код многопоточности имеет свой цикл разработки, настройки и отладки; у него другие источники сбоев, чем у однопоточного кода
- Отделяй код, относящийся к многопоточности, от остального приложения
- Многопоточный код должен быть компактным и сосредоточен в одном месте; тестировать только его, без лишнего

### Ограничивай область видимости общих данных

- Два потока, изменяющие одно поле общего объекта, могут давать неверный результат; количество путей выполнения огромно даже для простого кода
- Чем больше мест, где обновляются общие данные, тем выше риск забыть защиту, нарушить DRY и не найти источник сбоя
- Жёстко ограничивай доступ к общим данным; серьёзно относись к инкапсуляции

### Избегай общего доступа, где возможно

- Не использовать общий доступ — самый простой способ избежать проблем: копии объектов, работа в одном потоке после слияния результатов
- Затраты на копирование часто окупаются за счёт отказа от блокировок; при сомнениях — померить
- Разбивай данные на независимые подмножества, с которыми потоки работают изолированно (в идеале — только локальные переменные, как в сервлетах с параметрами `doGet`/`doPost`)

### Знай библиотеку

- Используй потокобезопасные коллекции (например, `ConcurrentHashMap` вместо `HashMap` — почти всегда быстрее и поддерживает параллельные операции чтения/записи)
- Используй Executor Framework для выполнения несвязанных задач
- По возможности — неблокирующие решения
- Полезные примитивы: `ReentrantLock` (блокировка, устанавливаемая/освобождаемая в разных методах), `Semaphore` (классический семафор со счётчиком), `CountDownLatch` (ожидание заданного количества событий перед освобождением всех ожидающих потоков)
- Часть стандартных классов по умолчанию не потокобезопасна — изучай документацию используемых библиотек

### Знай модели выполнения

- Базовые понятия: связанный ресурс (ресурс с фиксированным размером/количеством), взаимное исключение (только один поток работает с общими данными), зависание (поток ждёт слишком долго или навсегда), взаимная блокировка (deadlock — потоки ждут друг друга бесконечно), обратимая блокировка (livelock — потоки активны, но не могут «разойтись»)
- **Производитель–потребитель**: производители кладут задания в очередь, потребители забирают; координация через сигналы «очередь не пуста» / «очередь не заполнена»; обе стороны ждут оповещений
- **Читатели–писатели**: общий ресурс в основном читается, иногда обновляется; нужен баланс между частотой обновлений и производительностью чтения; простая стратегия «писатель ждёт, пока нет читателей» может привести к зависанию писателей
- **Обедающие философы**: потоки конкурируют за ресурсы из ограниченного набора (каждому нужны два из общего пула); небрежное проектирование ведёт к deadlock, livelock, падению производительности
- Большинство практических задач — вариации этих трёх моделей; изучай алгоритмы и готовые решения заранее

### Зависимости между синхронизированными методами

- Общий объект с несколькими синхронизированными методами — признак неудачного проектирования; возможны тонкие ошибки
- Решения: блокировка на стороне клиента (клиент держит блокировку на весь вызов), блокировка на стороне сервера (один метод сервера блокирует и вызывает остальные), адаптер с блокировкой
- По возможности избегай использования нескольких синхронизированных методов одного общего объекта

### Критические секции — минимальный размер

- Критические секции должны быть защищены, но их должно быть как можно меньше
- Синхронизированные участки делай минимальными по размеру; большие блоки под одной блокировкой увеличивают конкуренцию и снижают производительность
- Защищай только то, что действительно должно быть защищено

### Корректное завершение

- Система, которая должна когда-то корректно завершиться, сложнее «вечно работающей»; взаимные блокировки и бесконечное ожидание сигнала — типичные проблемы
- Думай о корректном завершении на ранней стадии; на это уходит больше времени, чем кажется
- Изучи существующие подходы — задача сложнее, чем выглядит (например, пара производитель/потребитель при остановке)

### Тестирование: общие правила

- Непериодические сбои часто связаны с многопоточностью — не списывай их на «случайность» или «фазы Луны»
- Сначала убедись, что код корректен вне многопоточности: выноси логику в POJO и тестируй без потоков; не отлаживай обычные и многопоточные ошибки одновременно
- Реализуй переключение конфигураций: один поток / несколько / меняющееся число потоков; быстрые и медленные заглушки; возможность гонять тесты N раз
- Гоняй тесты с числом потоков больше числа ядер/процессоров — так чаще проявляются гонки и deadlock
- Тестируй на всех целевых платформах; политики планирования различаются, поведение одного и того же кода может отличаться

### Инструментовка для выявления ошибок

- Ошибки многопоточности редко воспроизводятся; нужно намеренно менять порядок выполнения
- В тестах используй вызовы вроде `wait()`, `sleep()`, `yield()`, смена приоритета — только в тестовой сборке, не в продакшене
- Ручная вставка в «подозрительные» места или автоматическая инструментовка (например, точка «jiggle» с случайным выбором: продолжение / пауза / yield) повышает шанс пройти по сбойному пути
- Цель — нарушить предсказуемость пути выполнения при разных запусках; комбинация тестов и случайного выбора увеличивает вероятность найти дефекты

### Многопоточность и производительность (из приложения)

- Многопоточность ускоряет I/O-ориентированные задачи: пока один поток ждёт ввода/вывода, другие используют процессор; для процессорно-ориентированных задач добавление потоков не поможет, если ядер не хватает
- Все ответственности (управление сокетами, обработка запросов, политика потоков, завершение работы) должны быть в разных классах; код управления потоками не должен делать ничего другого
- Изолируй многопоточную политику в одном классе (например, `ClientScheduler`) — при смене стратегии (поток на запрос → пул потоков через Executor) меняется только один класс

### Неблокирующие решения

- Атомарные классы (`AtomicInteger`, `AtomicBoolean`, `AtomicReference`) используют операцию CAS (Compare and Swap) процессора — обычно быстрее, чем `synchronized`
- `synchronized` устанавливает блокировку всегда, даже если конкуренции нет; CAS предполагает отсутствие конкуренции и обнаруживает конфликт, что обычно дешевле
- Для простых операций (инкремент, обновление ссылки) предпочитай атомарные классы вместо `synchronized`

### Потоково-небезопасные классы и составные операции

- Отдельные методы класса могут быть потокобезопасны, но последовательность из двух вызовов — нет (пример: `containsKey` + `put` на `HashTable` — между ними может вмешаться другой поток)
- Решения: клиентская блокировка (`synchronized` на стороне вызывающего), серверная блокировка (один метод `putIfAbsent` внутри), потокобезопасная коллекция (`ConcurrentHashMap.putIfAbsent`)
- Серверная блокировка предпочтительнее: сокращает дублирование, снижает вероятность ошибок, определяет единую политику, сокращает область видимости общих переменных

### Взаимная блокировка (deadlock)

- Четыре условия для deadlock: взаимное исключение, блокировка с ожиданием, отсутствие вытеснения, циклическое ожидание — достаточно нарушить одно, чтобы deadlock стал невозможен
- **Нарушение взаимного исключения**: ресурсы с многопоточным доступом (`AtomicInteger`), увеличение количества ресурсов, проверка доступности перед захватом
- **Нарушение блокировки с ожиданием**: если ресурс занят — освободи все захваченные ресурсы и начни заново; риск — истощение и livelock
- **Нарушение вытеснения**: потоки могут запрашивать друг у друга освобождение ресурсов
- **Нарушение циклического ожидания** (самая частая стратегия): все потоки захватывают ресурсы в едином глобальном порядке

### Итог по архитектуре и тестам

- Разбивай систему на POJO без знания о потоках и на небольшой слой, управляющий многопоточностью
- Сведи к минимуму число общих объектов и объём общего доступа; предпочитай архитектуру, где объекты сами поддерживают безопасный одновременный доступ, а не управление блокировками со стороны клиентов
- Не вызывай из одной заблокированной секции другую без чёткого понимания того, кто чем владеет
- Запускай многопоточный код во многих конфигурациях и на разных платформах с ранних стадий; тестируемость и модульность позволяют это делать
- Тесты методом Монте-Карло: случайные параметры, многократные запуски, разная нагрузка; сохраняй условия, при которых выявлен сбой
- Чистый и изолированный многопоточный код проще тестировать и правильно реализовать
