# Внутреннее строение JUnit

### Имена переменных и полей

- Префиксы области видимости в именах (например, `f` для полей) в современных средах избыточны — обходись без них
- Не дублируй имена полей класса в локальных переменных функции, если смысл другой — это создаёт неоднозначность; выбирай другие имена (например, `compactExpected` и `compactActual` вместо `expected` и `actual`)
- Если переменная по смыслу длина, а не индекс — называй длиной; единая терминология (длина везде или индекс везде) улучшает читаемость
- «Волшебные» +1 и −1 выноси туда, где они имеют явный смысл (например, `charFromEnd(s, i)` как `s.charAt(s.length() - i - 1)`), чтобы не разбрасывать магию по коду

### Имена функций

- Имя функции должно отражать реальное поведение: если она и проверяет условие, и форматирует, и сжимает — имя вроде `compact` скрывает побочные эффекты; лучше, например, `formatCompactedComparison`
- Имя должно хорошо читаться вместе с аргументом: `formatCompactedComparison(message)` яснее, чем `compact(message)`

### Условия в начале функции

- Сложное условие в начале функции выноси в метод с говорящим именем — так выражается намерение (например, `shouldNotCompact()` или `canBeCompacted()`)
- Положительные условия обычно понятнее отрицательных: `canBeCompacted()` читается проще, чем `shouldNotCompact()`; при необходимости инвертируй логику

### Одна ответственность функции

- Если функция и сжимает данные, и форматирует результат — раздели: одна функция только сжимает, другая только форматирует
- Функция не должна делать ничего сверх того, что подразумевает её имя

### Согласованность внутри функции

- В одной функции не смешивай стиль «часть результата в возвращаемом значении, часть в полях» без необходимости; если одни вспомогательные методы возвращают значение, а другие пишут в поля — это нарушение единой конвенции
- Рассмотри вариант, где вспомогательные методы возвращают значения, а не записывают в переменные экземпляра

### Скрытая временная связь (порядок вызовов)

- Если одна функция должна вызываться до другой (например, от неё зависят поля), эта связь должна быть очевидной
- Передача параметра «чтобы зафиксировать порядок вызова» плохо объясняет причину; следующий разработчик может «упростить» и сломать
- Надёжнее объединить связанные шаги в один метод (например, `findCommonPrefixAndSuffix()` вызывает `findCommonPrefix()` внутри), тогда порядок виден в коде

### Упрощение логики

- Если условие `if` на практике никогда не выполняется (инвариант не позволяет переменной попасть в нужный диапазон), ветка может быть лишней; проверив это тестами, такую ветку можно убрать и упростить функцию
- Когда функция по сути склеивает части строки, можно явно выразить это конкатенацией или цепочкой `append`, без лишних условных веток

### Структура модуля

- Группируй функции по смыслу: например, «анализ» (поиск префикса/суффикса) и «синтез» (сборка результата)
- Располагай определения так, чтобы функция была объявлена перед первым использованием (топологический порядок)
- Разбиение на маленькие функции с ясными именами делает алгоритм читаемым по шагам

### Рефакторинг как итерация

- Одна переработка нередко отменяется или меняется следующей — это нормально
- Рефакторинг — процесс проб и ошибок; итог важнее сохранения каждого промежуточного решения

### Правило бойскаута

- Оставляй код чище, чем он был до твоих изменений
- Нет модуля, который нельзя было бы улучшить; даже хороший код можно сделать чуть понятнее и проще
- Наша обязанность — оставить чужой код хотя бы немного лучше
