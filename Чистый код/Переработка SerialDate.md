# Переработка SerialDate

### Сначала — тесты

- Перед переработкой добейся приемлемого покрытия тестами; без этого рефакторинг опасен
- Закомментированные тесты, описывающие желаемое поведение, — хороший план переработки: включай их по одному и делай проходящими
- Непокрытый код и невызываемые методы — кандидаты на удаление или на новые тесты
- Ожидаемое поведение (например, без учёта регистра) стоит явно проверить тестом; если тест элементарен — добавь его
- Ошибки на границах (off-by-one, края диапазона) встречаются часто; добавь тесты на граничные случаи и при исправлении бага — тест, который бы его поймал
- Если по покрытию строка никогда не выполняется — проверь условие: возможно, алгоритм неверен
- После исправления бага добавь тест, чтобы он не вернулся

### Комментарии и заголовки

- История изменений в начале файла не нужна — её ведёт система контроля версий; удаляй
- Избыточные комментарии распространяют неточную информацию; удаляй, особенно если они повторяют сигнатуру или устарели
- Много «языков» в одном файле (Java, Javadoc, HTML) усложняют поддержку; в комментариях по возможности избегай сложной разметки
- Javadoc, который не добавляет пользы к сигнатуре, только загромождает; один содержательный момент (например, особое возвращаемое значение) можно оставить, но обновлять при изменении поведения

### Имена и уровень абстракции

- Имя класса не должно выдавать детали реализации; абстракция не должна называться по способу хранения данных
- Используй точные термины: «смещение» и «порядковый номер» — разное; путаница в названиях мешает пониманию
- Метод, возвращающий новый объект, а не меняющий текущий, лучше именовать так, чтобы это было очевидно (например, `plusDays` вместо `addDays`), иначе читатель может решить, что меняется сам объект
- Магические числа заменяй именованными константами или членами перечисления
- Константы и типы лучше передавать символическими именами (enum), а не числами — так безопаснее переименовывать и менять типы

### Константы и перечисления

- Наследование от класса-набора констант — устаревший приём; используй перечисления
- Перечисление даёт тип, убирает проверки «валидности кода» и разбросанные проверки диапазона
- Константы, относящиеся к одной конкретной реализации, не должны лежать в абстрактном классе — переноси их в класс этой реализации
- Если таблица или константа используется только в одном классе — держи её там
- Математические названия интервалов (замкнутый, открытый, полуоткрытый) часто понятнее, чем INCLUDE_FIRST / INCLUDE_SECOND

### Размещение кода и зависимости

- Базовый класс не должен знать конкретные реализации и создавать их напрямую; вынос создания в фабрику (Abstract Factory) избавляет от этой связи
- Информацию о границах реализации (мин/макс год и т.п.) лучше получать через фабрику или интерфейс, а не тащить константы реализации в абстрактный класс
- Метод, который по смыслу относится к другому типу (например, quarter для месяца), логичнее поместить в тот тип (например, в enum Month)
- Статический метод, работающий только с данными экземпляра, должен быть методом экземпляра
- Логическая зависимость от реализации должна быть отражена в коде: вынеси её в явный метод или тип, чтобы не зависеть от «скрытых» допущений
- Код, не зависящий от деталей реализации, можно поднять в базовый класс
- Логику разбора типа (строка → значение) часто уместно держать в самом типе (например, `Day.parse`, `Month.parse`) и при необходимости вынести тип в отдельный файл

### Удаление лишнего

- Неиспользуемые таблицы, поля, методы доступа — удаляй
- Дублирующие друг друга методы (один вызывает второй с флагом) — объедини или раздели по ясным намерениям; не передавай флаг только ради выбора формата вывода
- Вырожденный конструктор по умолчанию, если он не нужен — удали, компилятор сгенерирует сам
- Если метод используется только в тестах и по смыслу не нужен в продакшене — пересмотри тесты и при необходимости удали и метод, и тесты, проверяющие лишнее

### Читаемость алгоритмов

- Поясняющие переменные делают алгоритм понятнее; не жалей промежуточных имён
- Сначала пойми, что делает алгоритм, потом упрощай
- Повторяющиеся условия в цикле (несколько подряд if с похожей логикой) по возможности объедини (например, через `||`)
- Таблица, дублирующая поведение публичной функции, создаёт путаницу; сделай её приватной или убери дублирование
- Громоздкий `switch` по типу или варианту можно заменить полиморфизмом (например, enum с методом в каждом элементе)

### Согласованность и стиль

- Единая конвенция: не смешивай «метод возвращает значение» и «метод пишет в поле» без веской причины
- После рефакторинга приведи похожие методы к одному шаблону (одинаковая структура, именование)
- `final` у каждого параметра и переменной — вопрос стиля; польза может дублировать то, что уже ловят тесты; важнее единообразие в проекте

### Правило бойскаута

- Оставляй код чуть чище, чем нашёл
- Переработка занимает время, но следующий читатель разберётся быстрее; возможно, он сделает код ещё чище
