### Используйте исключения вместо кодов ошибок
- Вызывающая сторона должна проверять ошибки немедленно после вызова
- По этой причине при обнаружении ошибки лучше инициировать исключение
- Код вызова становится более понятным, а логика не скрывается за кодом обработки ошибок

### Начните с написания команды try-catch-finally
- Размещая код в секции `try`, вы утверждаете, что выполнение программы может прерваться в любой точке, а затем продолжиться в секции `catch`
- По этой причине написание кода, который может инициировать исключения, рекомендуется начинать с конструкции `try-catch-finally`
- Определив область видимости при помощи конструкции `try-catch`, мы можем использовать методологию TDD для построения остальной необходимой логики

### Используйте непроверяемые исключения
- Цена проверяемых исключений — нарушение принципа открытости-закрытости
- Если вы инициируете проверяемое исключение из метода своего кода, а `catch` находится тремя уровнями выше, то это исключение должно быть объявлено в сигнатурах всех методов между вашим методом и `catch`
- Следовательно, изменение на низком уровне программного продукта приводит к изменениям сигнатур на многих более высоких уровнях
- Изменённые модули приходится строить и развёртывать заново, притом что в программе не изменилось ничего существенного для них
- Проверяемые исключения иногда могут пригодиться при написании особо важных библиотек, но в общем случае разработки приложения проблемы, создаваемые зависимостями, перевешивают преимущества

### Передавайте контекст с исключениями
- Каждое исключение, инициируемое в программе, должно содержать достаточно контекстной информации для определения источника и местонахождения ошибки
- Создавайте содержательные сообщения об ошибках и передавайте их со своими исключениями
- Включайте в них сведения о сбойной операции и типе сбоя
- Если в приложении ведётся журнал, передайте информацию, достаточную для регистрации ошибки в секции `catch`

### Определяйте классы исключений в контексте потребностей вызывающей стороны
- Ошибки можно классифицировать по источнику, то есть по компоненту, в котором они произошли
- Также возможна классификация по типу: сбои устройств, сетевые сбои, ошибки программирования и так далее
- Однако при определении классов исключений в приложении думать необходимо прежде всего о том, как они будут перехватываться
- Создавая обёртку для стороннего вызова, вы сокращаете до минимума зависимость от него в своём коде
- В будущем вы можете переключиться на другую библиотеку без сколько-нибудь заметных проблем
- Обёртки также упрощают имитацию сторонних вызовов при тестировании кода
- Преимущество обёртки заключается в том, что вы не ограничиваетесь архитектурными решениями разработчика API
- Используйте разные классы исключений только в том случае, если вы намерены перехватывать одни исключения, разрешая прохождение других типов

### Определите нормальный путь выполнения
- Паттерн «Особый случай» (Fowler): программист создаёт класс или настраивает объект так, чтобы он обрабатывал особый случай за него
- Это позволяет избежать обработки исключительного поведения в клиентском коде
- Всё необходимое поведение инкапсулируется в объекте особого случая

### Не возвращайте null
- Одно из неправильных действий программистов, провоцирующих ошибки при обработке ошибок — возвращение `null`
- Возвращая `null`, мы практически создаём для себя лишнюю работу, а вызывающей стороне — лишние проблемы
- Если возникает желание вернуть `null` из метода, рассмотрите возможность выдачи исключения или возвращения объекта особого случая

### Не передавайте null
- Возвращать `null` из методов плохо, но передавать `null` при вызове ещё хуже
- По возможности избегайте передачи `null` в своём коде
- Исключение составляют методы сторонних API, при вызове которых без этого не обойтись
