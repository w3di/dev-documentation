# Системы

### Отделение конструирования системы от её использования

- Конструирование и использование системы — два разных процесса; фаза инициализации (создание объектов, склейка зависимостей) должна быть отделена от логики выполнения
- Смешивание инициализации с бизнес-логикой создаёт жёсткую привязку, усложняет тестирование и нарушает принцип единой ответственности
- Отложенная инициализация (lazy init) удобна, но если она разбросана по всему приложению — глобальная стратегия инициализации теряется, появляется дублирование и скрытые зависимости

### Способы отделения конструирования

- **Отделение main**: вся инициализация в `main` (или модуле, вызываемом из `main`); остальной код получает готовые объекты и ничего не знает о конструировании
- **Фабрика**: приложение контролирует момент создания объекта, не зная деталей реализации; зависимости направлены от реализации к приложению
- **Внедрение зависимостей (DI)**: класс не создаёт зависимости сам — он остаётся пассивным и предоставляет set-методы или аргументы конструктора; фактические зависимости задаются извне (конфигурация, DI-контейнер)
- DI-контейнеры поддерживают отложенную инициализацию через фабрики и посредники (proxy), не нарушая разделения ответственности

### Масштабирование

- Построить «правильную» систему с первого раза — миф; сегодня реализуются текущие потребности, завтра система перерабатывается и расширяется
- Архитектура программных систем может развиваться последовательно, если обеспечить правильное разделение ответственности
- Жёсткая привязка бизнес-логики к тяжеловесному контейнеру (как EJB2) затрудняет тестирование, повторное использование и делает изменения дорогими

### Поперечные области ответственности и аспекты

- Некоторые области (сохранение объектов, транзакции, безопасность, кэширование) пересекают границы объектов предметной области — это поперечные области ответственности
- Аспектно-ориентированное программирование (АОП) позволяет определять такое поведение декларативно, отдельно от основного кода
- Бизнес-логику записывать в POJO-объектах, сосредоточенных на предметной области, без зависимостей от инфраструктуры — это упрощает тестирование и сопровождение

### Испытание системной архитектуры

- Если логика предметной области написана в POJO и отделена от инфраструктурных областей, архитектуру можно развивать от простого к сложному
- Начинать можно с простой архитектуры без жёстких привязок, быстро реализовать потребности пользователей, а инфраструктуру добавлять по мере масштабирования
- Необходимо сохранять возможность «смены курса» — это не значит «разберёмся по ходу», но и не значит проектировать всё заранее (BDUF)
- Оптимальная архитектура: модульные области ответственности на базе POJO, интегрированные аспектами или аналогичными средствами с минимальным вмешательством

### Оптимизация принятия решений

- Модульность и разделение ответственности позволяют децентрализовать принятие решений
- Решения лучше откладывать до последнего момента — это позволяет принять их на базе максимума информации; преждевременное решение принимается на базе неполной информации

### Стандарты

- Стандарты упрощают повторное использование, привлечение опытных людей, связывание компонентов
- Но применять стандарт нужно когда он приносит очевидную пользу, а не потому что «так принято»; стандарты могут терять связь с реальными потребностями

### Предметно-ориентированные языки (DSL)

- Хороший DSL сводит к минимуму разрыв между концепциями предметной области и кодом
- DSL позволяет выразить все уровни абстракции от высокоуровневых политик до низкоуровневых деталей

### Заключение

- Чистым должен быть не только код, но и архитектура системы
- Агрессивная, всепроникающая архитектура скрывает логику предметной области и снижает гибкость
- Намерения разработчика должны быть чётко выражены на всех уровнях абстракции
- Используйте самое простое решение из всех возможных
