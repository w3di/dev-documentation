# Последовательное очищение

### Чистый код не пишется с первого раза

- Сначала пиши «грязный» код, затем последовательно очищай его
- Считать задачу выполненной, когда код «заработал», и переходить к следующей — непрофессионально
- Чёткое и ясное решение получается итерациями, а не одним проходом

### Когда останавливаться и рефакторить

- Если добавление следующей фичи (новый тип, новая опция) резко усложнит код — не добавляй, сначала переработай структуру
- Один и тот же паттерн в нескольких местах (parse, set, get для каждого типа) — сигнал вынести абстракцию: общий интерфейс или базовый класс
- Много типов со сходными методами — повод ввести общую концепцию (например, один контейнер с полиморфными объектами вместо нескольких контейнеров по типам)

### Не делай «большой рефакторинг» одним махом

- Глобальные изменения структуры «для улучшения» часто ломают программу; после них трудно восстановить работоспособность
- Вноси множество очень маленьких изменений; после каждого шага система должна по-прежнему работать
- Сначала налади работу (почини тесты), только потом переходи к следующему изменению
- Рефакторинг как кубик Рубика: много мелких шагов, каждый подготавливает следующий

### Тесты — основа безопасного рефакторинга

- Без автоматизированных тестов рефакторить опасно: нельзя убедиться, что поведение не изменилось
- Запускай тесты после каждого маленького изменения
- Имеет смысл иметь и модульные, и приемочные тесты — они ловят разные классы ошибок

### Убирай дублирование через абстракцию

- Несколько контейнеров под разные типы с одинаковой схемой использования — кандидат на один контейнер с полиморфными объектами
- Цепочка if/else или switch по типам — кандидат на замену одним полиморфным вызовом (один метод в интерфейсе, разная реализация)
- Передача в функцию нескольких связанных вещей (массив + индекс) — по возможности замени одним объектом (например, `Iterator`), чтобы упростить сигнатуры и перенос логики в другие классы

### Выноси связанный код в подходящее место

- Обработка ошибок и форматирование сообщений — в отдельный класс/модуль (например, класс исключения), а не размазывать по основному коду
- Логическое разбиение упрощает понимание и сопровождение; у каждого модуля — своя зона ответственности

### Поддерживать чистоту проще, чем вычищать потом

- Плохой код загнивает: модули проникают друг в друга, зависимости запутываются; вычищать это потом дорого и долго
- Беспорядок, устроенный недавно, вычистить легко; не откладывай «на потом»
- Постоянно следи за простотой и чистотой кода; не допускай накопления долга
