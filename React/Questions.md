#### 1. Virtual DOM и Reconciliation

1. Что такое Virtual DOM в React и зачем он нужен?
	- Virtual DOM - это абстрактное представление UI в виде дерева обычных JavaScript-объектов, которые отражают структуру реального DOM. React использует его, чтобы оптимизировать и контролировать обновления интерфейса.

2. Как работает Virtual DOM в React — от создания до обновления реального DOM?
	- Компонент возвращает JSX которое затем превращается в дерево Virtual DOM
	- При изменении состояния или пропсов React создаёт новое дерево VDOM
	- React сравнивает новое и старое дерево (алгоритм diff)
	- Вычисляется минимальный набор изменений (patch)
	- Реальный DOM обновляется точечно, на основе diff-а

3. Какие события в React приводят к пересозданию/обновлению Virtual DOM?
	- Изменение props компонента
	- Изменение контекста через `useContext`
	- Монтирование и размонтирование компонентов
	- Изменение состояния через `useState` или `useReducer`
	- Любые изменения данных, влияющие на вывод JSX

4. Где выполняется Virtual DOM в React (в какой среде/памяти)?
	- Virtual DOM работает в памяти JavaScript-движка, то есть в оперативной памяти (RAM) браузера, внутри JavaScript-окружения

5. Из каких структур данных состоит Virtual DOM в React?
	- Virtual DOM состоит из JavaScript-объектов, каждый из которых представляет один UI-элемент (аналог узла DOM)

6. Почему Virtual DOM эффективнее прямых манипуляций с DOM?
	- Прямые манипуляции с DOM вызывают дорогостоящие затраты браузера на layout/repaint
	- Virtual DOM работает с UI в памяти
	- Обновления происходят в памяти, что позволяет вычислять минимальный набор изменений (diffing) и применять их пакетно, снижая количество дорогостоящих операций с реальным DOM
7. Как работает алгоритм diffing в React при сравнении изменений в Virtual DOM и какова его сложность?
	- React использует эффективный алгоритм diffing с линейной сложностью O(n)
	- Сравнивает элементы сверху вниз и слева направо
	- Если у элементов разный type (например, div и span или разные компоненты), React полностью заменяет соответствующее поддерево
	- Если type совпадает, React сравнивает props и рекурсивно переходит к сравнению детей
	- При сравнении детей React ориентируется на позицию элементов и key:
		- Если ключи присутствуют, используется сопоставление по ним для эффективной обработки добавлений, удалений и перемещений
		- Без ключей сравнение идёт по индексу, что менее эффективно и может привести к лишним обновлениям

8. Что такое ключи (key) в React и как они влияют на сравнение элементов в списках?
	- Ключи (key) — это уникальные идентификаторы элементов списка, которые React использует для сопоставления элементов между старым и новым деревом
	- Если ключи присутствуют, React сопоставляет элементы по ним, что позволяет эффективно выявлять добавленные, удалённые перемещённые элементы
	- Без ключей React сравнивает элементы по их позиции (индексу) в массиве

#### 2. Fiber Architecture

9. Что такое архитектура React Fiber и чем она отличается от прежнего Stack Reconciler?
	- Прерываемость
	- Приоритезация
	- Инкрементальный рендеринг

10. В чём недостатки старого синхронного reconciler'а по сравнению с React Fiber?
	- Старый Virtual DOM работал синхронно и непрерываемо, что приводило к блокировкам UI при больших обновлениях
	- Отсутствие приоритезации обновлений: все обновления обрабатывались с одинаковым приоритетом
	- Нельзя было прервать, отложить или отменить рендеринг, что негативно влияло на отзывчивость интерфейса
	- Отсутствие инкрементального (пошагового) рендеринга
	- Отсутствие возможности прерывать и возобновлять рендеринг с учётом приоритетов

11. Почему React Fiber использует связный список для обхода дерева, а не рекурсию?
	- Связный список позволяет React:
		- Выполнять обход дерева итеративно, без глубокого рекурсивного стека, что снижает риск переполнения стека
		- Прерывать и возобновлять рендеринг
		- Управлять приоритетами задач и планировать работу по частям
	- Рекурсия же требует полного прохода и не позволяет прерывать работу посередине
12. Как используется связный список узлов в React Fiber для обхода дерева?
	- это структура из объектов FiberNode, где каждый узел содержит ссылки:
		- `child` — на первого потомка
		- `sibling` — на следующего брата (соседа)
		- `return` — на родителя
	- Так можно пройти всё дерево последовательно, переходя от родителя к первому ребёнку, потом к соседям, обходя дерево без рекурсии

13. Что такое FiberNode в React и как он устроен?
	- FiberNode — это объект, представляющий один узел дерева Fiber. Он содержит всю информацию, необходимую React для управления рендерингом и обновлением конкретного UI-элемента

14. Какие ключевые поля содержит объект FiberNode и что каждое из них означает?
	- `stateNode` — ссылка на реальный инстанс, связанный с этим узлом (DOM-элемент, экземпляр класса, или null для функциональных компонентов)
	- `return` — ссылка на родительский FiberNode, позволяющая подниматься вверх по дереву
	- `child` — ссылка на первый дочерний FiberNode, начало обхода детей
	- `sibling` — ссылка на следующий соседний FiberNode на том же уровне
	- `flags` — битовая маска, указывающая, какие операции (вставка, обновление, удаление) нужно выполнить с этим узлом
15. Как поля return, child и sibling в FiberNode обеспечивают безрекурсивный обход дерева Fiber?
	- Поле `child` позволяет спуститься вниз по дереву
	- поле `sibling` — перейти к соседнему узлу на том же уровне
	- поле `return` — подняться вверх к родителю после обхода всех детей
	- Вместе они реализуют итеративный обход дерева, заменяющий рекурсию, что даёт контроль над процессом рендеринга и позволяет прерывать и возобновлять работу

16. Какие бывают типы флагов (flags) в FiberNode и какие операции они обозначают?
	- `flags` — это битовая маска, которая сообщает React, какие действия нужно выполнить над узлом на этапе commit. Основные флаги:
		- `Placement` — узел нужно вставить в DOM (новый элемент)
		- `Update` — узел нужно обновить (например, props или DOM-атрибуты)
		- `Deletion` — узел нужно удалить из DOM
		- `ChildDeletion` — удалить одного или нескольких потомков
		- `Ref` — обновить ref
		- `Passive` — выполнить эффекты `useEffect`

17. Что такое двойная буферизация (double buffering) в React Fiber и зачем она нужна?
	- Двойная буферизация в Fiber — это хранение двух деревьев (current и working) для безопасного обновления UI без блокировок: изменения делают в рабочем дереве, а после завершения заменяют текущее

#### 3. Fiber Render Process

18. Что такое work loop в React Fiber и как он организует процесс рендеринга?
	- Work loop в React Fiber — это основной цикл, в котором React пошагово обходит дерево Fiber, создаёт/обновляет FiberNode'ы и готовит дерево к коммиту. Он лежит в основе инкрементального, прерываемого рендеринга

19. Как связный список в React Fiber позволяет прерывать и возобновлять рендеринг?
	- обход дерева — это итеративный процесс с явным хранением текущей позиции, это позволяет просто сохранить состояние обхода (текущий узел), остановить цикл и освободить основной поток для других задач, при следующем вызове React продолжит обход с сохранённого узла, а не начинает заново или не уходит в глубокую рекурсию
20. Как обновляется UI в React Fiber: полный цикл от setState до отрисовки?
	- **Инициирование обновления**
		- создаётся объект обновления, который добавляется в очередь обновлений соответствующего FiberNode
	- **Приоритезация**
		- Обновление получает приоритет через систему Lanes
	- **Планирование задачи (Scheduler)**
		- Scheduler решает, когда запускать работу: сразу (высокий приоритет) или отложить (низкий)
	- **Render-фаза (Reconciliation)** - эта фаза прерываема и инкрементальна, может быть приостановлена и возобновлена
		- Создаётся новое дерево work-in-progress (рабочее дерево Fiber) на основе текущего
		- React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов
	- **Завершение render-фазы**
		- После обхода дерева React формирует полный список эффектов для commit-фазы
	- **Commit-фаза (синхронная, непрерываемая)**
		- Фаза размонтирования эффектов
			- Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		- Mutation этап
			- React применяет изменения в DOM: удаление, вставка, обновление
		- Выполняются функции `useLayoutEffect`
		- Выполняются функции `useEffect`
	- **Обновление текущего дерева**
		- Рабочее дерево work-in-progress становится текущим (current), старое может быть удалено или повторно использовано
21. Какие фазы включает процесс обновления в React Fiber?
	- Reconciliation (render фаза) - Прерываемая и инкрементальная
	- Commit фаза - Синхронная и непрерываемая

22. Чем отличаются фазы в Fiber и какую роль они играют в обновлении UI?
	- Reconciliation (render фаза) - отвечает за подготовку и планирование изменений
	- commit фаза - за их окончательное применение и взаимодействие с DOM

23. Что происходит в React в фазе Render (reconciliation)?
	- Создаётся новое дерево work-in-progress на основе текущего
	- React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов
	- После обхода дерева React формирует полный список эффектов для commit-фазы
	- Фаза может быть прервана и возобновлена, чтобы избежать блокировки основного потока

24. Что происходит в React в фазе Commit?
	- Фаза размонтирования эффектов
		- Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
	- Mutation этап
		- React применяет изменения в DOM: удаление, вставка, обновление
	- Выполняются функции `useLayoutEffect`
	- Выполняются функции `useEffect`
	- Commit-фаза не прерывается, чтобы гарантировать консистентность DOM
25. Что такое Effect List в React Fiber и для чего он используется?
	- это связанный список узлов Fiber с помеченными изменениями, которые React последовательно применяет к DOM и запускает соответствующие эффекты в фазе commit

26. Как в React формируется и используется Effect List?
	- Во время render-фазы React при обходе work-in-progress дерева помечает каждый FiberNode с изменениями специальными флагами
	- Эти помеченные узлы собираются в Effect List — связанный список эффектов, которые нужно применить
	- В commit-фазе React последовательно проходит по Effect List и выполняет соответствующие операции

#### 4. Priority System and Scheduling

27. Как работает система приоритетов в React Fiber и как она влияет на рендеринг?
	- Каждое обновление получает приоритет — через механизм Lanes
	- React сначала обрабатывает более приоритетные задачи (например, ввод), менее важные — откладывает

28. Что такое модель приоритетов Lane в React и как она работает?
	- Lane-модель — система приоритизации обновлений в React Fiber, где каждое обновление относится к одной или нескольким lanes — битовым флагам разного приоритета

29. Какие типы (lanes) существуют (`SyncLane`, `InputContinuousLane`, `DefaultLane` и др.)?
	- `SyncLane` — максимальный приоритет, обновления должны выполниться сразу (например, `flushSync`)
	- `InputContinuousLane` — приоритет интерактивного ввода, чтобы UI был отзывчивым
	- `DefaultLane` — обычные фоновые обновления

30. Что такое Scheduler в React и за что он отвечает?
	- Это планировщик задач React, который решает, когда и с каким приоритетом запускать работу по обновлению UI. Он координирует выполнение render-фазы, позволяя прерывать низкоприоритетные задачи ради более важных
31. Как Scheduler в React выбирает приоритет задач?
	- Scheduler использует lanes и сопоставляет их с уровнями приоритетов
	- Задачи с более высоким приоритетом прерывают текущие и запускаются раньше

32. Что делает `flushSync` и как он обходит приоритезацию?
	- `flushSync` — функция, которая запускает обновление синхронно, игнорируя систему приоритетов и асинхронность Scheduler. Она принудительно выполняет render и commit сразу, чтобы обновление UI произошло немедленно
33. Что такое конкурентный рендеринг (Concurrent Features) в React и чем он отличается от синхронного?
	- Concurrent Mode - новый способ работы React с рендерингом, при котором React не блокирует основной поток на долгое время, а разбивает работу на небольшие части (инкрементальный рендеринг)
	- Позволяет React приостанавливать, возобновлять и приоритезировать работу по обновлению интерфейса

34. Что такое time slicing в React и зачем он нужен?
	- механизм в React Fiber, который разбивает работу по рендерингу на небольшие части. React выполняет эти части по очереди, прерываясь по тайм-ауту, чтобы дать браузеру возможность обрабатывать пользовательские события и другие задачи
	- Time slicing реализуется за счёт итеративного обхода дерева Fiber с сохранением состояния, чтобы при возобновлении рендеринга продолжить с того места, где остановились
35. Как React прерывает и возобновляет рендеринг (time slicing)?
	- React разбивает работу рендера на небольшие задачи — единицы работы (units of work)
	- При достижении лимита времени текущая задача прерывается, текущее состояние обхода (nextUnitOfWork) сохраняется
	- В следующий момент React возобновляет обход с сохранённой позиции, позволяя браузеру обрабатывать важные события между этими фрагментами работы

36. Как React Suspense использует механизм прерывания рендера?
	- Suspense позволяет React прервать рендеринг компонента, если он «зависает» на асинхронной операции (например, загрузке данных или кода)
	- React отменяет текущую работу по рендеру, показывает fallback UI, а затем возобновляет рендеринг, когда асинхронная операция завершена

#### 5. Server-Side Rendering and Hydration

37. Как в React работает гидратация (hydration) после серверного рендеринга (SSR)?
	- Сервер присылает готовую страницу с уже заполненным HTML
	- Браузер показывает этот HTML — пользователь сразу видит контент, даже если JS ещё не загрузился
	- После загрузки JS React берёт этот HTML и «подключает» к нему свою логику: навешивает обработчики событий, создаёт внутренние структуры для управления состоянием
	- React не рисует заново весь UI, а работает поверх уже существующего DOM, делая его интерактивным

38. Что такое selective hydration в React и как она ускоряет загрузку?
	- Selective hydration — это стратегия, при которой React не гидратирует сразу всё дерево, а по частям и с приоритетом. Например, сначала гидратируются видимые пользователю интерактивные части, а остальные — позже или при взаимодействии
39. Что такое React Server Components и чем они отличаются от клиентских?
	- Server Components — это React-компоненты, которые рендерятся только на сервере. Они не попадают в клиентский бандл, не запускают JS в браузере и позволяют значительно уменьшить размер кода на клиенте. Серверные компоненты могут напрямую обращаться к базе данных или файловой системе и отправлять готовый HTML, облегчая загрузку и повышая производительность

40. Что такое серверные функции (Server Actions) в React и когда их использовать?
	- Серверные функции (Server Actions) — это функции, которые выполняются на сервере по вызову из React-компонента. Они могут обрабатывать данные, выполнять бизнес-логику или работать с API, при этом не отправляя клиенту лишний JavaScript

41. Что означает директива `use client` в React и когда её использовать?
	- строчка в начале файла которая указывает, что компонент должен рендериться и работать на клиенте

42. Что означает директива `use server` в React и когда её использовать?
	- строчка в начале файла указывает, что функция или компонент выполняется только на сервере
43. Что можно делать в серверных компонентах React, чего нельзя в клиентских?
	- доступ к базе данных, файловой системе, секретам
	- использовать серверные зависимости (например, fs, pg, bcrypt)

44. Что можно делать в клиентских компонентах React, чего нельзя в серверных?
	- использовать:
		- браузерные API
		- Хуки react
		- обработчики событий
		- манипулировать с DOM
45. Что такое Streaming SSR в React и как он работает?
	- Streaming SSR — это возможность React отдавать HTML по мере готовности дерева пока React рендерит все по частям
	- Работает через `renderToPipeableStream` (Node.js) или `renderToReadableStream` (Edge/Cloud)

46. Что такое hydration mismatch в React и почему он возникает?
	- Hydration mismatch — это ситуация, когда HTML, пришедший с сервера (SSR) не совпадает с тем, что React "ожидает" при клиентской гидратации
47. Как избежать hydration mismatch в приложениях React с SSR?
	- Соблюдать одинаковую логику рендера на сервере и клиенте:
		- не использовать случайные значения (`Math.random()`, `Date.now()`)
		- `window`, `document` и любые browser-only API
		- Использовать `useEffect`, а не `useLayoutEffect` для client-only логики
48. Почему важно, чтобы SSR и клиентский рендер в React генерировали одинаковый DOM?
	- React при гидратации подключается к существующему серверному HTML и ожидает, что структура совпадёт. Если DOM не совпадает — происходит hydration mismatch, React показывает предупреждения и может перерисовать большие участки UI

49. Что происходит на клиенте при hydration mismatch в React?
	- React покажет warning, а иногда — перерисует весь DOM узел

50. Как `useLayoutEffect` может повлиять на гидратацию (hydration) после SSR в React?
	- `useLayoutEffect` выполняется до отрисовки, только на клиенте — и может синхронно изменить DOM, не совпадающий с HTML от сервера, что приводит к hydration mismatch
51. Как SSR в React помогает уменьшить Time to First Byte (TTFB)?
	- SSR позволяет серверу сразу отправить полностью сформированный HTML, благодаря чему браузер начинает отображать контент сразу после получения первого байта без задержек на загрузку и выполнение JS

52. Как в React/Next.js избежать отправки лишнего JavaScript на клиент?
	- Использовать Server Components, которые рендерятся только на сервере и не попадают в клиентский бандл
	- Применять `use client` директиву строго там, где нужна интерактивность
	- Делать код-сплиттинг и динамический импорт для загрузки JS только при необходимости
	- Минимизировать зависимости и не импортировать клиентские библиотеки в серверные компоненты
	- Использовать selective hydration, чтобы загружать JS по частям и с приоритетом
53. Как работают Suspense и ленивая загрузка серверных данных и компонентов в React/Next.js?
	- Серверные компоненты могут использовать асинхронные функции (например, `await fetch()`) прямо внутри тела компонента. React ждёт их завершения или отдаёт fallback, обеспечивая эффективный ленивый рендеринг и загрузку
	- После загрузки данных React «дозаписывает» оставшийся HTML по стриму (Streaming SSR), обеспечивая эффективный ленивый рендеринг и быструю первую отрисовку
	- На клиенте Suspense переключается между fallback и готовым UI по мере завершения загрузки, поддерживая плавный переход

54. Какие хуки доступны в React Server Components?
	- `useId` - Генерация стабильных ID

#### 6. Performance Optimization

55. Как React избегает лишних ререндеров?
	- Virtual DOM и сравнение (reconciliation)
	- Мемоизация с `React.memo`
	- Хуки `useMemo` и `useCallback`
	- Контроль ключей (key) в списках

56. Как работает batching обновлений состояния в React?
	- это механизм объединения нескольких обновлений состояния (state updates) в один цикл рендера
	- внутри обработчика вызывается несколько setState или обновлений, React объединяет (batch) их и выполняет один рендер после завершения обработчика

57. Как Fiber улучшает отзывчивость UI (например, при анимациях)?
	- Приоритизация обновлений
	- Прерываемость рендера
	- благодаря time slicing и прерывистому рендеру, браузер может своевременно обновлять кадры анимаций и избегать "фризов"

#### 7. Advanced Patterns and Features

58. Как архитектура React Fiber учитывает асинхронные операции при обновлении UI?
	- Fiber сам по себе не выполняет асинхронные операции, но он управляет их результатами и обновлением UI с учётом приоритетов

59. Как работает Suspense для данных в React?
	- Suspense для данных приостанавливает рендер компонента, если данные ещё не готовы, бросая Promise. React показывает fallback UI, пока Promise не разрешится, после чего рендер возобновляется с готовыми данными
60. Что такое API `use()` в React и для чего оно нужно?
	- `use()` — это React API для чтения значения ресурса, такого как Promise или контекст

61. Для чего нужен `use()` в React и какие ресурсы он читает?
	- Чтобы "подписаться" на Promise или контекст и получить их значение, интегрируясь с Suspense и Error Boundaries

62. Как работает `use()` с Promise и контекстом в React?
	- Если передан Promise, React "приостанавливает" рендер компонента до его разрешения (Suspense fallback показывается)
	- Если Promise отклонён — срабатывает ближайший Error Boundary
	- Если передан контекст — `use()` возвращает его значение, как `useContext`, но может использоваться в условных и циклах
63. Где доступен `use()` в React (SSR или CSR) и когда его применять?
	- Работает и на сервере, и на клиенте, но преимущественно используется для чтения ресурсов в Client Components

64. Как новый хук `use()` взаимодействует с Fiber?
	- `use()` интегрируется с механизмом Suspense в Fiber: при ожидании Promise Fiber приостанавливает рендер и переключается на fallback, а после разрешения возобновляет рендер с полученными данными

65. Как использовать `use()` для чтения контекста вместо `useContext`?
	- Использование `use` с контекстом способ читать значение контекста, аналогичный `useContext`, но с преимуществом возможности вызывать `use` внутри условных блоков и циклов

66. Почему нельзя просто await в Client Components вместо `use()`?
	- `await` нельзя использовать напрямую в теле функционального компонента — он синхронный и блокирует. `use()` позволяет React управлять состоянием ожидания асинхронного результата в рамках Fiber и Suspense

#### 8. Debugging and Internals

67. В чём разница между `useLayoutEffect` и `useEffect` с точки зрения Fiber?
	- `useLayoutEffect` — синхронный, блокирующий эффект, полезен для измерений DOM и синхронных манипуляций. выполняется в phase commit, после того, как React применил изменения к DOM, но до того, как браузер обновил экран
	- `useEffect` — асинхронный, неблокирующий, выполняется после отрисовки, оптимален для сетевых запросов, подписок и не критичных к времени операций. выполняется после фазы commit и после того, как браузер отрисовал обновлённый UI
68. Как React делит работу на чанки и приостанавливает рендеринг для более важных задач?
	- React Fiber разбивает работу рендеринга на небольшие части (чанки). При этом рендеринг приостанавливается (interruptible rendering), если появляется задача с более высоким приоритетом (например, пользовательский ввод)

69. Как React обрабатывает "зависшие" компоненты (например, при загрузке данных)?
	- При загрузке данных, если компонент возвращает Promise, React приостанавливает его рендеринг, показывая запасной UI (fallback) через Suspense. Когда данные загружены, React продолжает рендеринг компонента с этими данными

70. Что такое Selective Hydration в React на клиенте?
	- Selective Hydration — это техника, при которой React при гидратации на клиенте сначала гидратирует только самые важные или видимые части UI, а остальные части гидратируются позже, по мере необходимости
71. В чём разница между срочными (urgent) и отложенными (non-urgent) обновлениями в React, и как это связано с приоритетами Scheduler?
	- Срочные (urgent) обновления — это события с высоким приоритетом, как ввод пользователя или клики, которые React должен обработать немедленно
	- Отложенные (non-urgent) обновления — менее важные задачи, например, обновление неактивных компонентов, которые можно выполнить позже
	- Scheduler React управляет этими приоритетами, позволяя прерывать низкоприоритетные задачи для срочных, поддерживая отзывчивость UI

72. Что такое interruptible rendering в React и зачем он нужен?
	- Interruptible rendering — возможность React прерывать текущий процесс рендеринга в любой момент, чтобы переключиться на более приоритетную работу, а затем продолжать с места остановки
73. Почему React Server Components не имеют состояния и хуков?
	- Server Components рендерятся на сервере и не имеют жизненного цикла или интерактивности, поэтому состояние и хуки им не нужны

74. Как React Server Components уменьшают размер клиентского бандла?
	- Server Components не включаются в клиентский бандл JavaScript — они полностью рендерятся на сервере и передают клиенту уже готовый HTML

75. Как работают `React.lazy` и Suspense для динамического импорта компонентов?
	- `React.lazy` динамически импортирует компонент (через `import()`), возвращая промис
	- Пока компонент загружается — Suspense показывает fallback UI
	- После загрузки компонент рендерится как обычно
76. Какие варианты fallback UI поддерживает React Suspense и как работает вложенность?
	- Fallback — любой React-элемент, показываемый во время загрузки
	- Вложенные Suspense показывают самый близкий fallback для загрузки в своей области

77. Какие основные этапы монтирования, обновления и размонтирования компонентов в функциональном React?
	- Монтирование: рендер + запуск эффектов с пустым массивом зависимостей (`useEffect(() => {}, [])`)
	- Обновление: повторный рендер + эффекты с изменившимися зависимостями
	- Размонтирование: вызов очисток эффектов (функций, возвращаемых из `useEffect`)

78. Как компоненты ведут себя в разных режимах рендера (синхронном и конкурентном)?
	- Sync: рендер блокирует UI до конца
	- Concurrent: рендер можно приостанавливать, приоритеты обновлений

#### 9. Component Patterns and State Management

79. Как реализуется однонаправленный поток данных в React?
	- Однонаправленный поток данных в React означает, что данные всегда идут сверху вниз — от родительских компонентов к дочерним через props
	- Родитель хранит состояние и передаёт его дочерним, которые могут только читать эти props, но не менять их напрямую. Изменения состояния происходят в родителе через коллбэки, переданные вниз

80. Что такое "lifting state up" и как его правильно использовать?
	- это когда состояние, нужное нескольким компонентам, поднимается к их ближайшему общему родителю. Вместо того чтобы каждый компонент держал своё локальное состояние и пытался синхронизировать его, состояние централизуется в одном компоненте-родителе, а дочерним передаются через props и коллбэки для изменения

81. В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?
	- Контролируемые компоненты — это компоненты, где состояние формы полностью управляется React через state и обновляется через обработчики (`onChange`). Значение поля всегда берётся из состояния, а не из DOM
	- Неконтролируемые компоненты — это компоненты, где состояние формы хранится непосредственно в DOM, а React лишь получает доступ через ref. React не управляет значением, а читает его при необходимости
	- Контролируемые компоненты позволяют сразу валидировать, управлять вводом, делать условный рендер элементов формы

#### 10. React Features and APIs

82. Как и зачем применять `React.Fragment`?
	- Позволяет сгруппировать несколько элементов без добавления лишнего DOM-узла

83. Когда и как правильно использовать порталы в React?
	- Используйте порталы, когда UI-элемент должен визуально выходить за пределы текущей иерархии DOM — например, модальные окна, тултипы, всплывающие меню, уведомления

84. Как работает `ReactDOM.createPortal` и как он участвует в Fiber-дереве?
	- `ReactDOM.createPortal` рендерит элемент в другой DOM-узел, но оставляет его частью того же Fiber-дерева. Компонент внутри портала получает контексты, участвует в рендеринге, Suspense, ErrorBoundary и сохраняет порядок событий
85. Как ведёт себя React при вложенных Suspense и цепочках fallback (suspense cascade)?
	- При вложенных Suspense, React строит цепочку fallback'ов: если inner Suspense переходит в состояние ожидания (suspend), React показывает его fallback
	- Если fallback-контент тоже вызывает suspend (например, ленивый компонент или async server компонент), React поднимается к ближайшему родительскому Suspense выше по компонентному дереву (не по DOM) и рендерит уже его fallback. Этот процесс продолжается вверх, пока не найдётся fallback, который можно отрендерить синхронно
	- Это называется suspense cascade — поведение предсказуемо, и важно, что цепочка строится по дереву компонентов, а не по DOM

86. Какие особенности управления событиями и фокусом возникают при работе с порталами?
	- События всплывают по React-дереву, а не по DOM — обработчики работают как обычно, несмотря на другой DOM-узел
	- Фокусом нужно управлять вручную: при открытии модалки ставить фокус в портал, при закрытии — возвращать на исходный элемент
87. Какие аргументы принимает `ReactDOM.createPortal`?
	- `children` — React-элементы, которые нужно отрендерить (JSX, компоненты, строки, фрагменты и т.п.)
	- `domNode` — DOM-узел, куда будет помещён этот контент. Этот узел должен уже существовать в DOM
	- `key` (опционально) — уникальный ключ (строка или число) для идентификации портала, особенно при рендере списков порталов

88. Какие стандартные атрибуты и API React помогают создавать доступный UI?
	- `aria-*` (`aria-label`, `aria-labelledby`, `aria-describedby`, `aria-hidden`) для описания элементов для скринридеров
	- `tabIndex` - для настройки порядка табуляции и возможности фокусировки
89. Как правильно реализовать контролируемые и неконтролируемые компоненты форм?
	- Контролируемые компоненты: значение хранится в состоянии (`useState`), обновляется через `onChange`. React полностью управляет вводом
	- Неконтролируемые компоненты: значение хранится в DOM, доступ через ref. React не управляет вводом напрямую

90. Как в React обрабатывать события `onChange` и `onSubmit` в формах?
	- `onChange`: обновляет состояние для контролируемых компонентов
	- `onSubmit`: отменяет стандартное поведение и обрабатывает данные из состояния или ref
91. Как сделать простую валидацию без сторонних библиотек?
	- выполняется прямо в обработчике `onSubmit` или `onChange` — проверяем значения на нужные условия с сохранением ошибок в состоянии
	- HTML-атрибуты валидации `required`, `minLength`, `pattern`

92. Как реализовать анимации с помощью CSS в React-приложении?
	- Создаёшь CSS-классы с `transition` (для плавных переходов свойств) или `@keyframes` (для сложных анимаций)
93. Как работает система SyntheticEvent в React?
	- SyntheticEvent — это обёртка над нативными событиями браузера, которую React создаёт для обеспечения кроссбраузерного и одинакового API при работе с событиями

94. В чём основные отличия между Synthetic Events и нативными событиями браузера?
	- **Кроссбраузерность**
		- SyntheticEvent предоставляет единый интерфейс, который одинаково работает во всех браузерах. Нативные события могут иметь отличия в свойствах и поведении между браузерами
	- **Поведение всплытия**
		- События в React всплывают по React-иерархии компонентов, даже если DOM-структура другая (например, при использовании createPortal). Нативные события всплывают по DOM-дереву
	- **Совместимость с React API**
		- Только SyntheticEvent работает корректно с системой приоритетов событий в concurrent режиме. Нативные события об этом "не знают"
	- **API одинаково везде**
		- У SyntheticEvent всегда есть стандартные свойства (`type`, `target`, `currentTarget`, `preventDefault()`, `stopPropagation()` и т.п.), даже если браузер этого не поддерживает напрямую
95. Как ведёт себя React Strict Mode в режиме разработки и зачем он нужен?
	- В Strict Mode компоненты и хуки специально монтируются, размонтируются и монтируются заново в режиме разработки. Это имитация двойного вызова жизненных циклов для выявления побочных эффектов

96. Почему компоненты и хуки вызываются повторно в Strict Mode?
	- React повторно вызывает функции компонентов и эффекты, чтобы проверить, правильно ли они чистят ресурсы и не вызывают неожиданных сайд-эффектов при монтировании/размонтировании

97. Как Strict Mode помогает улучшить качество кода и отловить ошибки?
	- Такая проверка помогает заранее выявлять баги, неправильное управление эффектами и состояние, делая код более устойчивым и предсказуемым перед продакшен-сборкой

98. Как включить React Strict Mode в приложении?
	- обернуть компонент в `<React.StrictMode>`
99. Как получить доступ к React Context без хуков?
	- через компонент `<MyContext.Consumer>`. В него передают функцию, которая получает текущее значение контекста

100. Какие проблемы с производительностью возникают при частых обновлениях контекста?
	- При изменении значения в провайдере все дочерние компоненты использующие контекст перерендериваются, даже если используют лишь часть данных или не затронуты логикой

101. Как JSX трансформируется в вызовы `React.createElement`?
	- JSX — это синтаксический сахар, который во время сборки транспилируется в вызовы `React.createElement`

102. Что такое ReactElement и чем он отличается от компонента?
	- ReactElement — это обычный объект, который описывает элемент React: тип (тег или компонент), пропсы и детей. Это «план» для реального DOM. Он не является компонентом и не содержит логики — это результат вызова компонента или JSX

#### 11. React 18+ Features

103. Как Automatic Batching в React 18 работает с промисами и таймерами?
	- В React 18 Automatic Batching работает со всеми асинхронными операциями. Когда несколько setState вызываются внутри промиса или setTimeout, React автоматически объединяет их в один рендер, что значительно улучшает производительность

104. В чем разница между React 17 и React 18 batching?
	- React 17: batching работал только в обработчиках событий React (`onClick`, `onChange` и т.д.)
	- React 18: batching работает везде, включая промисы, таймеры, сетевые запросы и любые другие асинхронные операции

105. Как `flushSync` обходит Automatic Batching?
	- `flushSync` принудительно выполняет обновление синхронно, игнорируя Automatic Batching. Это полезно когда нужно немедленно применить изменения, например, для измерений DOM или интеграции с внешними библиотеками

106. Что такое React Compiler и какую роль он играет в оптимизации React-кода?
	- React Compiler — это инструмент, который автоматически оптимизирует React код во время компиляции. Он анализирует код и применяет оптимизации, которые раньше требовали ручного написания `useMemo`, `useCallback` и других оптимизаций

107. Как React Compiler оптимизирует код?
	- React Compiler автоматически мемоизирует компоненты и функции, удаляет ненужные ререндеры, оптимизирует пропсы и состояния. Он делает это на уровне компиляции, что более эффективно чем ручные оптимизации

## Hooks

108. Какие правила использования хуков React нужно соблюдать?
	- Вызывайте их на верхнем уровне в теле компонента функции
	- Вызывайте их на верхнем уровне в теле пользовательского хука
	- Не вызывайте хуки внутри условий или циклов
	- Не называйте хуки после условного return оператора
	- Не вызывайте хуки в обработчиках событий
	- Не вызывайте хуки в компонентах класса
	- Не вызывайте хуки внутри функций, переданных в `useMemo`, `useReducer`, или `useEffect`

### useState

109. Для чего нужен `useState`?
	- Чтобы создать локальное состояние в функциональном компоненте

110. Что возвращает `useState`?
	- Массив из двух элементов: текущее значение и функция для его обновления

111. Как изменить состояние `useState`?
	- Вызов `setState(newValue)` или `setState(prev => computeNext(prev))`

112. Как обновлять состояние на основе предыдущего значения?
	- `setState(prev => computeNext(prev))`

113. Почему setState асинхронен, и как это влияет на обновления?
	- batching группирует обновления, чтобы не делать лишнюю работу. Поэтому state не обновляется сразу после вызова setState

114. Что произойдет, если вызвать setState с тем же значением?
	- React использует `Object.is` для сравнения. Если значение не изменилось — ререндер не произойдёт
115. Как работает shallow compare в `useState`?
	- Shallow сравнение — `Object.is(prev, next)`. Для объектов и массивов — сравниваются только ссылки

116. Как работает `useState` при повторных рендерах?
	- React сохраняет значение в ячейке хука. Инициализация выполняется один раз — при первом рендере

117. Как правильно обновлять состояние, если оно — объект или массив?
	- Иммутабельно: `setState(prev => ({ ...prev, updated: true }))`
118. Почему нельзя вызывать `useState` условно?
	- Потому что порядок вызовов хуков должен быть стабильным между рендерами

119. В чем отличие `useState` от `useReducer`?
	- `useState` — для простого состояния. `useReducer` — для сложной логики и вложенных структур. `useReducer` даёт больше контроля и лучше масштабируется

120. Как ведет себя `useState` при размонтировании компонента?
	- Хук отрабатывает только при монтировании. После анмаунта setState ничего не делает
121. Как сделать ленивую инициализацию состояния в `useState`?
	- `useState(() => computeExpensiveInitial())`

122. В чем разница между `useState(someFunction())`, `useState(someFunction)`, `useState(() => someFunction())`?
	- `someFn()` — вызов сразу, значение — результат
	- `someFn` — функция как значение, не вызовется
	- `() => someFn()` — ленивый вызов, только при первом рендере
123. Можно ли мемоизировать setState с помощью `useCallback`?
	- Можно, но не нужно. setState стабилен, ссылка не меняется

124. Что произойдёт, если передать пропсы как начальное значение в `useState`, а затем эти пропсы изменятся?
	- Ничего не произойдёт. Начальное значение читается только при монтировании. Для синхронизации с пропсами нужен `useEffect`

125. Как синхронизировать значение `useState` с передаваемыми компоненту пропсами?
	- Чтобы синхронизировать state с пропсами, нужно использовать `useEffect` с подпиской на нужные пропсы
126. Что будет если `useState` при значении объекта через setState присвоить этот же объект?
	- `setObj((obj) => obj)` - ничего не будет так как ссылка такая же
	- `setObj((obj) => {...obj})` - произойдет перерендер так как ссылку уже будет другой

127. Как избежать stale-значений при обновлении состояния в async-колбэках или таймерах?
	- Использовать функциональный `setState(prev => ...)`
128. Почему setState внутри `useEffect` может зациклить рендер?
	- Если setState вызывается без условий, и обновляемое состояние входит в deps, произойдёт бесконечный цикл

129. Как работает batching в React 18 и какие кейсы нарушают его (например, setTimeout, промисы)?
	- React batch'ит несколько вызовов setState в один ререндер
	- после 18 версии всё, что запущено внутри одного "tick" (микро/макрозадачи), будет батчиться
	- `flushSync` принудительно ререндерит компонент игнорируя batch(инг)


---

### useEffect и useLayoutEffect

130. Для чего нужен `useEffect`?
	- `useEffect` позволяет выполнять побочные эффекты

131. Когда вызывается `useEffect`?
	- После рендера, асинхронно, уже после того как браузер нарисовал DOM

132. Какие параметры принимает `useEffect` и что они означают?
	- `callback: () => void` — основная функция с эффектом
	- `deps: any[]` — массив зависимостей (опционально)

133. Что возвращает `useEffect`?
	- Ничего сам по себе (undefined). Но колбэк может вернуть функцию очистки — она вызовется при размонтировании или перед следующим выполнением эффекта

134. Как работает массив зависимостей?
	- React сравнивает зависимости (по `Object.is`). Эффект выполняется только если хотя бы одна зависимость изменилась. Если массив пустой — выполнится один раз при монтировании
135. Что будет, если не указать зависимости?
	- Эффект будет выполняться после каждого рендера

136. Как выполнить эффект только при монтировании компонента?
	- Передать пустой массив зависимостей

137. Как использовать `useEffect` с асинхронными функциями?
	- Нельзя сделать сам `useEffect` async, но можно в callback создать асинхронную функцию и вызвать ее
138. Что такое функция очистки (cleanup)?
	- Это функция, которую может возвращать callback. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента
	- Используется для отмены подписок, таймеров, abort-controllers и т.п.

139. Когда вызывается функция очистки?
	- Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента
140. Как отменять асинхронные операции в `useEffect`?
	- `AbortController` для запросов
	- флаг переменную

141. Чем `useEffect` отличается от `useLayoutEffect`?
	- `useEffect`: вызывается асинхронно, после рендера и отрисовки
	- `useLayoutEffect`: вызывается синхронно, до отрисовки браузером и может блокировать отрисовку
142. Что такое "useEffect первого рендера" и "useEffect обновления"? Как их различать?
	- useEffect первого рендера: выполняются один раз при монтировании (`useEffect(() => {...}, [])`)
	- useEffect обновления: выполняются при изменении зависимостей (`useEffect(() => {...}, [a, b])`)

143. Как избежать гонки состояний (race conditions) в асинхронных эффектах?
	- Используй `AbortController`, флаги `isMounted`
144. Почему нельзя делать await напрямую в `useEffect(callback)`?
	- Потому что `useEffect` должен возвращать либо undefined, либо функцию очистки. async функция всегда возвращает Promise, что нарушает контракт

145. Как правильно использовать эффекты с подписками на внешние источники (WebSocket, Observer, EventListener)?
	- Создай подписку в `useEffect`
	- Вернуть функцию очистки, чтобы отписаться при размонтировании или повторном вызове
146. Что произойдёт, если не использовать функцию очистки при подписке?
	- Повторные подписки → дублирование событий
	- неактуальные колбэки
	- Утечка ресурсов

147. Чем отличается порядок выполнения нескольких `useEffect` в одном компоненте?
	- Они выполняются сверху вниз, в порядке объявления. Это важно, если между ними есть зависимость
148. Как влияет Strict Mode на вызовы `useEffect`? Как это влияет на эффекты с побочками?
	- `useEffect` вызывается дважды (монтирование → размонтирование → повторное монтирование)
	- Цель — поймать ошибки в нечистых эффектов, например, без cleanup


### useRef

149. Для чего нужен `useRef`?
	- Также — для доступа к DOM-элементам
	- Чтобы хранить значения, которые не вызывают ререндер при изменении

150. Какие варианты использования `useRef` в React?
	- Доступ к DOM
	- Хранение значения между рендерами
	- Предыдущее значение
	- Флаг "монтирован"
	- Таймеры, id, внешние инстансы

151. Как получить доступ к DOM-элементу с помощью `useRef`?
	- Прокинуть в атрибут ref html тега переменную которой присвоили `useRef()`

152. Что хранится в `.current`?
	- В поле `.current` хранится текущее значение, которое туда положили. По умолчанию — значение, переданное в `useRef(initialValue)`

153. Можно ли изменять `.current`?
	- Да, через `ref.current = newValue`

154. Вызывает ли изменение `.current` перерендер?
	- `useRef` не триггерит повторный рендер, в отличие от `useState`
155. Как использовать `useRef` для хранения значений между рендерами?
	- Любое значение, присвоенное `ref.current`, мутабельно, доступно для использования и сохраняется между перерендерами

156. Чем `useRef` отличается от `useState`?
	- `useRef` не вызывает ререндер при изменении
	- `useState` — триггерит ререндер

157. Как использовать `useRef` для хранения предыдущего значения?
	- Любое значение, присвоенное `ref.current`, мутабельно, доступно для использования и сохраняется между перерендерами

158. Как `useRef` помогает избежать лишнего рендера в `onScroll`, `onResize` и других частых ивентах?
	- При `onScroll`, `onResize` и подобных событиях состояние часто обновляется, но повторный рендер при каждом изменении — дорог. `useRef` позволяет сохранять значения между рендерами, не вызывая лишних повторных рендеров.

159. Можно ли использовать `useRef` как глобальный стейт? Почему это плохая идея?
	- Можно, но не нужно, так как:
		- `useRef` — локален компоненту
		- не вызывает ререндер
		- не реактивен — другие компоненты не узнают об изменении

160. Как связать `useRef` и `forwardRef` для передачи доступа к DOM наружу?
	- `forwardRef` нужен, чтобы пробросить ref от родителя к DOM-элементу внутри компонента.
---

### `useMemo`

161. Что такое хук `useMemo` в React и для чего он используется?
	- `useMemo` — это хук, который мемоизирует результат вычисления между рендерами, чтобы не пересчитывать заново, если зависимости не изменились

162. Какие аргументы принимает `useMemo` и что они означают?
	- Функция, которая возвращает значение
	- Массив зависимостей (deps)

163. Что возвращает `useMemo` при успешной мемоизации?
	- Результат выполнения переданной функции — мемоизированное значение

164. Когда имеет смысл применять `useMemo` в React-компонентах?
	- Дорогие вычисления
	- Передача стабильной ссылки в зависимости
	- Оптимизация рендеров дочерних компонентов

165. В каких случаях `useMemo` не приносит пользы и может навредить?
	- Преждевременная мемоизация нагружает память и CPU
	- Если вычисление дешёвое
	- Если часто меняются зависимости и значение всегда пересчитывается
	- Если нет проблем с производительностью
166. Как устроена мемоизация в `useMemo` под капотом?
	- React запоминает результат выполнения функции
	- При следующем рендере сравнивает зависимости
	- Если зависимости не изменились (`Object.is`) — возвращает кэш, иначе — пересчитывает

167. Что произойдёт в `useMemo`, если не указать массив зависимостей?
	- Функция будет перевычисляться при каждом рендере

168. В каких случаях `useMemo` может ухудшить производительность приложения?
	- Если мемоизируется дешёвая логика
	- Если зависимости часто меняются
	- Если много `useMemo` — меньше GC, больше памяти

169. Как `useMemo` сравнивает зависимости: по ссылке или по значению?
	- По ссылке, через `Object.is()`

170. Как `useMemo` ведёт себя в конкурентном рендеринге (Concurrent Mode)?
	- В Concurrent Mode `useMemo` ведёт себя также, как и другие React-хуки: результат мемоизации сохраняется только после коммита. Если рендер был прерван, результат `useMemo` не сохраняется, и при следующем рендере функция будет вызвана снова
171. Чем `useMemo` отличается от мемоизации вне React (например, `lodash.memoize`)?
	- `useMemo` — это hook, встроенный в React-цикл рендеринга и зависящий от зависимостей и жизненного цикла компонента. Он автоматически сбрасывается при размонтировании компонента
	- В отличие от него, `lodash.memoize` — это императивная мемоизация, работающая вне контекста React и требующая ручного контроля над кэшем. Она сохраняет результат в глобальном или внешнем кэше и не зависит от ререндеров

172. Как `useMemo` влияет на использование памяти и работу сборщика мусора?
	- Каждый `useMemo` сохраняет результат в кэше до тех пор, пока компонент не размонтируется или зависимости не изменятся. Если `useMemo` используется без нужды (например, для дешёвых вычислений), это может увеличить потребление памяти, замедлить сборку мусора и создать лишнюю нагрузку на CPU из-за отслеживания зависимостей

173. Как `useMemo` взаимодействует с режимом Suspense в React?
	- В режиме Suspense, если рендер компонента прерывается из-за "зависания" на промисе (например, в data fetching), `useMemo` работает аналогично Concurrent Mode: результат не кэшируется, пока не произойдёт успешный коммит. Это значит, что функция в `useMemo` может вызываться повторно при каждом новом рендере, до тех пор, пока Suspense не завершит ожидание

174. Какие ошибки возникают при неправильном указании зависимостей в `useMemo`?
	- Если зависимости `useMemo` указаны неправильно (например, не указаны значения, от которых зависит вычисление), могут возникнуть баги со stale values: мемоизированное значение будет пересчитываться реже, чем нужно, и может стать неактуальным. Это приводит к неконсистентному UI, неверным данным или логике

---

### `useCallback`

175. Что такое хук `useCallback` в React и для чего он используется?
	- `useCallback` — это хук, который мемоизирует функцию, чтобы она сохраняла стабильную ссылку между рендерами, если не изменились зависимости

176. Какие аргументы принимает `useCallback` и что они означают?
	- Колбэк-функция (возвращается как есть, не вызывается)
	- Массив зависимостей

177. Что возвращает `useCallback` и когда ссылка на функцию остаётся стабильной?
	- Мемоизированную функцию

178. Когда имеет смысл применять `useCallback` в React-компонентах?
	- Когда нужно передать функцию в memoized-компонент
	- В `useEffect` / `useMemo` / `setInterval` — когда функция зависит от стабильности ссылки
	- Для оптимизации компонентов, избегающих лишнего рендера по ссылке на колбэк

179. В каких случаях `useCallback` бесполезен и не даёт выигрыша?
	- Если компонент не зависит от стабильности функции
	- Если функция пересоздаётся каждый раз из-за нестабильных зависимостей
	- Если перерисовки и так дешёвые
180. Что произойдёт, если колбэк в `useCallback` зависит от внешних значений, но их нет в зависимостях?
	- баг: внутри функции будут устаревшие значения (stale closure)

181. Чем отличается `useCallback` от `useMemo`?
	- `useCallback`:
		- Мемоизирует функцию
		- Возвращает саму функцию
	- `useMemo`:
		- Мемоизирует значение
		- Возвращает результат вызова

182. Когда стоит предпочесть `useCallback` вместо обычного объявления функции в компоненте?
	- Когда функция передаётся вниз (в props) и нужно избежать лишнего рендера дочернего `React.memo` компонента
	- Когда функция участвует в зависимостях эффекта, и нужна стабильная ссылка

183. Можно ли заменить `useCallback` с помощью `useMemo`? Почему это не рекомендуется?
	- Да, но не рекомендуется из-за неочевидности

184. Как избежать stale-замыканий (устаревших значений) при использовании `useCallback`?
	- Чтобы избежать stale closure, необходимо указывать в массиве зависимостей все значения, на которые ссылается колбэк: пропсы, стейт и любые переменные из внешней области. Это гарантирует, что функция будет пересоздана при изменении нужных данных и всегда работать с актуальными значениями
185. Как `useCallback` ведёт себя в конкурентном рендеринге (Concurrent Mode)?
	- `useCallback` — не сохраняется между прерванными рендерами, пока не завершится коммит
	- Но после успешного коммита, возвращаемая функция будет стабильна, если зависимости не поменялись

186. Почему нельзя мемоизировать колбэк с пустым массивом зависимостей, если внутри используются пропсы/состояние?
	- Пустой массив зависимостей фиксирует колбэк навсегда после первого рендера. Если в теле функции используются внешние значения, они будут захвачены однажды и больше не обновятся. Это приведёт к использованию устаревших данных и нарушит ожидаемое поведение компонента

187. Можно ли комбинировать `useCallback` с `useMemo` и когда это оправдано?
	- Комбинация возможна и уместна, когда требуется создать мемоизированную структуру, содержащую функции, и сохранить стабильность всей структуры между рендерами

188. Чем `useCallback` отличается от простого объявления функции внутри компонента?
	- Функция, объявленная внутри компонента без `useCallback`, пересоздаётся при каждом рендере и всегда имеет новую ссылку. `useCallback` позволяет сохранить ссылку на функцию между рендерами при условии, что зависимости не изменились


---

### useId

189. Для чего используется хук `useId` в React и какие задачи он решает?
	- нужен для генерации уникального, стабильного ID, который синхронизируется между сервером и клиентом
	- полезен для привязки label ↔ input, `aria-describedby`, и в компонентах, рендерящихся и на сервере, и на клиенте

190. Как работает `useId` и почему его ID стабильны между рендерами?
	- React генерирует уникальный, стабильный префикс независимо от количества ререндеров

191. Можно ли использовать `useId` в серверных компонентах React (RSC)?
	- Да. `useId` безопасен для Server Components и работает и на сервере, и на клиенте. Это одна из его задач — избежать mismatch при гидратации

192. Как `useId` помогает при серверном рендеринге (SSR) избежать mismatch?
	- `useId` гарантирует одинаковый ID на обеих сторонах (в отличие от `Math.random()`, uuid), потому что React сам контролирует генерацию и встраивает метаданные в HTML

193. Чем `useId` отличается от генерации ID через `Math.random()` и сторонние библиотеки?
	- Стабильный между рендерами
	- Работает при SSR-гидратации
	- безопасен для accessibility
194. Можно ли использовать `useId` для генерации ключей (key) в списках React?
	- Нет. Ключи в списках должны быть детерминированы по данным, иначе при изменении порядка или количества элементов React будет пере-монтировать всё

195. Что будет, если использовать `useId` в компоненте, который часто ререндерится?
	- `useId` стабилен — он выдаёт одно и то же значение между рендерами, пока компонент не размонтируется

196. Какие проблемы `useId` решает в контексте доступности (a11y)?
	- Для доступности важно, чтобы label имел `htmlFor={id}`, а input — `id={sameId}`. Если ID разные на сервере и клиенте — атрибут for указывает не туда → screen reader не сможет связать label и поле. `useId` даёт одинаковый ID и решает эту проблему

197. Как `useId` ведёт себя при гидратации после SSR?
	- React знает, как синхронизировать ID, сгенерированные на сервере и клиенте, чтобы избежать ошибок. Это происходит через встроенные маркеры в HTML, которые позволяют React восстановить правильный `state` без mismatch

198. Как `useId` генерирует стабильные ID в конкурентном режиме (Concurrent Mode)?
	- `useId()` генерирует стабильный уникальный ID, который:
	- Не зависит от порядка рендера и не сбивается даже при конкурентных прерываниях (concurrent rendering), т.к. не использует счётчики, как `useRef` или инкремент

199. Есть ли ограничения по количеству вызовов `useId` в одном компоненте?
	- Нет, жёстких ограничений нет — можно вызывать `useId` сколько угодно раз, и каждый вызов `useId()` вернёт уникальный ID, даже в одном компоненте
200. Как `useId` ведёт себя при гидратации SSR в сочетании с React Suspense?
	- React гарантирует, что `useId()` возвращает одинаковое значение на сервере и клиенте. Это особенно важно при использовании Suspense, где часть дерева может быть отложена, что меняет порядок вызова хуков
	- ID детерминированный, стабилен даже при Suspense, `startTransition`, и других асинхронных рендерах

---


useContext

201. Для чего нужен хук `useContext` в React и что он возвращает?
	- Чтобы получать значение из контекста

202. Как создать и экспортировать контекст в React?
	- `export const ThemeContext = React.createContext(null);`

203. Как использовать `useContext` для получения значения из контекста?
	- `const theme = useContext(ThemeContext);`

204. Можно ли использовать `useContext` вне компонента? Почему?
	- Нельзя. `useContext` — это хук, он должен вызываться внутри функционального компонента или другого хука

205. Как `useContext` работает при обновлении значения в провайдере?
	- Если значение контекст меняется, все потомки, использующие `useContext`, перерисуются
	- React сравнивает по `Object.is`

206. Как избежать лишних рендеров при использовании `useContext`?
	- Мемоизировать value
	- Разделить контексты: один для данных, другой для диспатча (Pattern: StateContext + DispatchContext)
	- Вынести `useContext` ближе к месту, где нужен

207. Можно ли использовать несколько контекстов одновременно? Как это делать?
	- Да. Просто вложив провайдеры друг в друга

208. Когда использовать `useContext`, а когда — глобальные стейты типа `Redux` или `Zustand`?
	- Используй `useContext` для UI-состояния и небольших кусков, `Redux`/`Zustand` — если данные масштабируются и делятся между многими частями приложения

209. Как работает `useContext` с серверным рендерингом (SSR)?
	- Неизвестно (нужна доработка раздела)

210. Какие ограничения и подводные камни есть у `useContext`?
	- Все потребители перерисуются при любом изменении value
	- Плохая производительность при больших объектах в value
	- Нельзя вызывать вне компонента
	- Мутирование объекта в value не вызовет ререндер

211. Как работает обновление контекста при вложенных провайдерах с одинаковым типом?
	- Если компонент обернут во вложенные `<Context.Provider>` одного и того же контекста, то `useContext(Context)` всегда читает ближайший вверх по дереву Provider

212. Как `useContext` влияет на производительность в больших приложениях?
	- При любом изменении value в Provider, все компоненты, читающие этот контекст (через `useContext`), перерисовываются, даже если они используют только часть value
	- Это связано с тем, что React делает сравнение по `Object.is(value)` на уровне Provider

213. Как обрабатывать ошибки при чтении контекста вне провайдера?
	- Создай обёртку-хук:

	```javascript
	function useStrictContext() {
		  const context = useContext(MyContext);
		  if (!context) {
	    throw new Error('useMyContext должен вызываться внутри <MyContext.Provider>');
		  }
		  return context;
		}
	```

214. Какие альтернативы `useContext` для глобального состояния и когда их лучше применять?
	- `Zustand`, `Redux` + RTK, Recoil
	- `useContext` хорошо работает для:
		- UI-состояния
		- локальных настроек
		- небольшого шаринга между родителем и потомками

---

useReducer

215. Что такое `useReducer` и для чего он нужен?
	- Это хук для управления сложным или предсказуемым состоянием

216. Какие параметры принимает `useReducer` и что они означают?
	- `reducer`: Редюсер — чистая функция, которая определяет логику обновления состояния. Редюсер принимает два аргумента – состояние и действие, и возвращает следующее состояние. Состояние и действие могут быть любых типов
	- `initialArg`: Значение на основе которого вычисляется начальное состояние. Значение начального состояния может быть любого типа. То как из него будет вычисляться начальное состояние, зависит от аргумента init
	- `init`(опционально): функция-инициализатор, возвращающая начальное состояние. Если не указана — состояние устанавливается в initialArg. Если указана — используется результат init(initialArg)

217. Чем отличается `useReducer` от `useState`?
	- `useState` → императивный: напрямую задаёшь новое значение
	- `useReducer` → декларативный: ты диспатчишь событие (dispatch(`action`)), и редьюсер решает, как изменится состояние
	- `useReducer` легче масштабировать

218. Как устроена редьюсер-функция? Какие параметры она принимает?
	- Редьюсер — это чистая функция:
	- `(`state`, `action`) => newState`, где:
		- `state` — текущее состояние
		- `action` — объект, описывающий событие
	- Возвращает новое состояние. Не мутирует предыдущее

219. Что возвращает `useReducer`?
	- Массив из двух значений:
		- `state` — текущее состояние
		- `dispatch` — функция, которая запускает редьюсер

220. Что такое функция dispatch?
	- `dispatch(`action`)` — это функция, которая передаёт `action` в редьюсер и вызывает пересчёт нового состояния

221. Как задать начальное состояние в `useReducer` и сделать ленивую инициализацию?
	- Через `initFn`
	- `initialArg` — любое значение (можно undefined)
	- `initFn(initialArg)` - возвращает начальное состояние (вызывается один раз)

222. Как работает dispatch в `useReducer`? Можно ли вызывать его асинхронно?
	- `dispatch` синхронно ставит обновление в очередь, но повторный рендер происходит асинхронно (в режиме батчинга React)
	- `dispatch` сам не поддерживает async/await, но можно вызывать его из `useEffect`, async function, setTimeout и т.д

223. Как использовать `useReducer` с асинхронными операциями?
	- Асинхронность обрабатывается вне редьюсера, а сам редьюсер — синхронный

224. Как использовать `useReducer` вместе с `useContext` для глобального стейта?
	- Создаёшь контекст, в который кладёшь `[`state`, dispatch]`
	- Оборачиваешь `Context.Provider` вокруг `<App>`
	- Любой компонент может использовать `useContext(Context)` - получает `state` и dispatch

225. Как React 18+ улучшает работу с `useReducer` (например, конкурентный режим и приоритеты обновлений)?
	- Обновления через dispatch теперь участвуют в automatic batching
226. Что происходит, если вызвать dispatch после размонтирования компонента?
	- Никакой ошибки не будет, но dispatch вызовет ничего — компонент уже не существует
	- Решение — проверять isMounted через useRef или отменять побочные эффекты в cleanup

227. Почему редьюсер должен быть чистой функцией? Какие проблемы возникают при мутации?
	- Редьюсер обязан быть чистой функцией, потому что React полагается на сравнение по ссылке, чтобы понять, произошло ли изменение состояния. Если внутри редьюсера мутировать объект и возвращать ту же ссылку, React не обнаружит изменения и не перерендерит компонент
228. Как избежать вызова dispatch после размонтирования компонента?
	- В `useEffect` можно установить флаг при монтировании и сбросить его в cleanup
	- Перед вызовом dispatch проверять этот флаг

229. Можно ли использовать несколько редьюсеров в одном компоненте?
	- Да, можно, каждый useReducer управляет своей частью данных и не зависит от других
230. Как обновлять части состояния, если `state` — объект или массив, чтобы избежать мутаций?
	- Вместо мутаций создавать новую версию объекта или массива, копируя неизменённые части

231. В чём различия между `useReducer` и `Redux`-подходом?
	- `useReducer` — это локальный инструмент, предназначенный для управления сложным состоянием внутри одного компонента или изолированной части UI. `Redux` — это глобальный store, ориентированный на управление состоянием всего приложения

-----
### useTransition

232. Что делает `useTransition` и как отличить его поведение от обычного обновления?
	- Без `startTransition` обновление может блокировать весь рендер; с `startTransition` — критичные части UI обновятся сразу, а «тяжёлые» — позже

233. Как `startTransition` влияет на приоритет обновлений в React?
	- React снижает приоритет запускаемых внутри `startTransition` обновлений до TransitionLane (в React scheduler), т.е. это concurrent и прерываемые обновления, в отличие от синхронных (DefaultLane, SyncLane) — они могут быть отложены, отменены или заблокированы Suspense

234. Что происходит, если вызвать `startTransition` внутри уже идущего `startTransition`?
	- Никакого дополнительного эффекта не будет — вложенные `startTransition` не стекуются и не создают вложенные транзакции. Все вложенные обновления также будут иметь TransitionLane, то есть они остаются низкоприоритетными

235. Как React решает, когда прервать отложенный ререндер?
	- Во время рендера React использует cooperative scheduling. Если текущий transition-рендер занимает слишком много времени (time slicing), он может быть прерван, чтобы отрисовать более приоритетные обновления (например, ввод). После прерывания запускается повторный рендер с учётом новых данных

236. Как `isPending` синхронизирован между render-фазами?
	- `isPending` — это значение, возвращаемое из `useTransition`, оно обновляется при старте и завершении transition-обновлений. Он не гарантирует точное состояние рендера, так как обновляется асинхронно и может отставать на один тик. Это флаг для UI-индикации, не для логики

237. Как отменяется отложенное обновление, если пришёл новый input?
	- Если во время transition приходит новый ввод, React прерывает текущий рендер и перезапускает его с актуальными данными. Предыдущая версия не применяется. Это возможно благодаря тому, что transition — прерываемый рендер

238. Почему `useTransition` не вызывает повторного рендера сразу?
	- Обновления внутри `startTransition` попадают в очередь с низким приоритетом. React может отложить их выполнение, если есть более важные дела

239. Как `useTransition` взаимодействует с Suspense?
	- Если отложенное обновление внутри `startTransition` приводит к загрузке (`<Suspense>` fallback), React отрендерит fallback UI. Так как это transition, fallback будет временным, и пользователь может продолжать взаимодействие

240. Как `useTransition` работает с `React.memo`, и влияет ли отложенное состояние на сравнение props?
	- Если переданные props приходят из `useDeferredValue` или `useTransition`'а (через `state`), то `React.memo` сравнивает их обычным shallowEqual
    
### useDeferredValue

241. Что делает `useDeferredValue` и в чём отличие от `useTransition`?
	- `useDeferredValue(value)` возвращает отложенную версию value, которая обновляется с низким приоритетом
	- В отличие от `useTransition`, который оборачивает setState, `useDeferredValue` применяется к уже вычисленному значению

242. Что произойдёт, если `useDeferredValue` применяется к primitive, object, array, function?
	- `useDeferredValue` работает с любыми типами
	- Для объектов/массивов/функций важно, что сравнение идёт по ссылке, не по содержимому

243. Как работает сравнение значений prev vs deferred – shallow или deep?
	- React сравнивает по ссылке (reference equality)

244. Когда `useDeferredValue` может не вызвать повторного рендера?
	- Когда value изменился, но новое значение === предыдущему (для примитивов — по значению, для объектов — по ссылке)
	- Также, если deferredValue всё ещё "догоняет" старое значение и не успел обновиться

245. Как работает с `React.memo` — что попадёт в areEqual(prevProps, nextProps)?
	- `React.memo` сравнивает deferredValue, а не оригинальный value

246. Что происходит, если исходное значение меняется чаще, чем deferred успевает обновиться?
	- deferredValue может "зависнуть" на старом значение
	- React может пропустить промежуточные значения и применит только последнее, когда появится «окно» времени
	- Это поведение делает его похожим на автоматический дебаунс

247. Как использовать `useDeferredValue` с Suspense и fallback UI?
	- `useDeferredValue` можно применять к данным, загружаемым через Suspense
	- Отложенный переход позволит сначала показать fallback, не блокируя основной поток
	- Часто комбинируется с `useMemo` и `React.lazy`

248. Может ли `useDeferredValue` вызывать tearing или лаги?
	- Да, если value и deferredValue попадают в разные рендеры компонентов
	- Важно избегать чтения value и deferredValue одновременно в одном компоненте, чтобы не получить рассинхрон

### useSyncExternalStore

249. Что делает `useSyncExternalStore` и в каких случаях он необходим?
	- `useSyncExternalStore` — это хук React, позволяющий синхронизировать состояние React-компонента с внешним (не React) стором или API
	- Его основная задача — гарантировать, что подписка и чтение состояния извне происходит синхронно и без рассинхронизации. Это особенно важно для Concurrent Mode и SSR

250. Какие аргументы принимает `useSyncExternalStore` и что он возвращает?
	- `subscribe` — функция подписки на изменения внешнего стора. Она принимает коллбек, который вызывается при изменении данных, и возвращает функцию отписки
	- `getSnapshot` — функция, которая синхронно возвращает актуальный снимок (snapshot) состояния из стора. React вызывает её при рендере, чтобы получить текущее состояние
	- `getServerSnapshot?` — опциональная функция, которая возвращает snapshot для серверного рендера. Используется при SSR для генерации начального состояния, чтобы клиент и сервер были синхронизированы
	- Возвращает текущее состояние (snapshot), которое получено из getSnapshot (или из getServerSnapshot при серверном рендере)

251. Почему нельзя использовать `useState`/`useEffect` для подписки на внешний store?
	- `useState` + `useEffect` создают асинхронные обновления, которые могут привести к рассинхронизации UI
	- При SSR `useEffect` не вызывается, поэтому компонент на сервере и клиенте может получить разное состояние
	- React не может гарантировать согласованность между рендером и подпиской

252. Какие проблемы решает `useSyncExternalStore`?
	- Обеспечивает, что React читает актуальное состояние синхронно во время рендера
	- Позволяет корректно подписываться на внешние изменения и автоматически отписываться при размонтировании или изменении подписки
	- Обеспечивает согласованность состояния между серверным рендером и клиентской гидрацией
253. Как работает `getSnapshot` и когда он должен быть стабилен?
	- `getSnapshot` — функция, которая возвращает текущее значение из внешнего стора
	- Она должна быть чистой и стабильной: при отсутствии изменений — возвращать одно и то же значение (сравнение через `Object.is`)
	- Если данные в сторе не изменились — возвращать тот же объект/примитив, чтобы избежать лишних ререндеров
	- Если `getSnapshot` возвращает новый объект при каждом вызове — React будет ререндерить компонент бесконечно

254. Что произойдёт, если `getSnapshot` возвращает новое значение при каждом вызове?
	- Приведёт к бесконечному циклу ререндеров

255. Как работает подписка — синхронно или асинхронно?
	- Подписка через `subscribe` вызывается синхронно при изменениях в сторе
	- React при получении уведомления вызывает `getSnapshot` и запускает ререндер
	- Подписка должна возвращать функцию отписки
256. В чём разница между `subscribe` и `getSnapshot` по таймингу?
	- `subscribe` — устанавливает слушателя изменений. Вызывается один раз при монтировании или обновлении хука. subscribe говорит React, когда вызвать getSnapshot
	- `getSnapshot` — вызывается при каждом рендере и при оповещении о событии изменения, чтобы получить актуальное значение

257. Как работает SSR-поддержка через `useSyncExternalStoreWithSelector`?
	- В SSR используется третий аргумент `getServerSnapshot` — возвращает начальное значение стора на сервере
	- При SSR `getServerSnapshot` вызывается только на сервере и при гидрации клиента
	- Если `getServerSnapshot` не передан, SSR рендер выбросит ошибку

258. Что происходит, если snapshot меняется во время рендера?
	- React запускает повторный рендер
	- Это связано с Concurrent Mode: React может дважды вызвать `getSnapshot` — перед и после применения изменений

259. Какие ошибки возникают при нестабильном snapshot или unsubscribe?
	- Бесконечные ререндеры
	- Если `subscribe` объявлен внутри компонента и меняется на каждом рендере, React будет переподписываться слишком часто, снижая производительность
	- Неправильный unsubscribe приведёт к утечке ресурсов
    
### useInsertionEffect

260. Чем `useInsertionEffect` отличается от `useEffect` и `useLayoutEffect`?
	- `useInsertionEffect` вызывается — до того, как React вставит DOM-узлы и выполнит `useLayoutEffect`. Это самый ранний эффект, нужен для синхронной вставки стилей перед любой отрисовкой

261. Почему `useInsertionEffect` нужен для библиотек CSS-in-JS?
	- `useInsertionEffect` позволяет вставить стили до запуска любых layout-эффектов, тем самым гарантируя, что компоненты отрендерятся уже с правильными стилями

262. Что произойдёт, если внутри `useInsertionEffect` сделать `setState`?
	- React бросит ошибку или предупредит, потому что вызов обновления состояния в `useInsertionEffect` может привести к бесконечным циклам рендера и рассинхронизации фаз рендера
	- `useInsertionEffect` предназначен только для побочных эффектов, не меняющих состояние компонента

263. Почему нельзя читать DOM внутри `useInsertionEffect`?
	- В момент вызова `useInsertionEffect` DOM ещё не обновлён новым рендером
	- Чтение DOM может вернуть устаревшие данные или привести к ошибкам, поскольку React только начинает фазу commit, но ещё не применил изменения к DOM

264. Как `useInsertionEffect` влияет на порядок вставки CSS и приоритет specificity?
	- `useInsertionEffect` гарантирует, что стили вставляются раньше всех других эффектов, включая `useLayoutEffect`. Это обеспечивает правильный порядок `<style>`-тегов в `<head>`, что важно для корректного применения CSS-правил с нужным приоритетом (specificity)

265. Что произойдёт, если `useInsertionEffect` недоступен (например, SSR)?
	- `useInsertionEffect` не вызывается на сервере, так как там нет DOM
    
### useImperativeHandle

266. Как работает `useImperativeHandle` и зачем он нужен?
	- Позволяет кастомизировать объект, который родитель получит через ref

267. Почему важно передавать второй аргумент в `forwardRef`, а не использовать `useRef` напрямую?
	- В React 18 и ниже ref не приходит как проп — его нужно явно проксировать через `forwardRef`
	- В React 19 `forwardRef` не нужен и ref можно прокидывать обычным пропсом

268. Можно ли в `useImperativeHandle` возвращать функции, которые используют stale props/`state`?
	- Да, можно, если правильно указать зависимости

269. В каких случаях стоит избегать `useImperativeHandle` вообще?
	- Нет необходимости инкапсулировать доступ к DOM
	- Нужное поведение — декларативное, а не императивное
	- Применяется, когда это единственный способ выразить поведение: scroll, focus, animation trigger и т.д

270. Что произойдёт, если ref в `forwardRef` null или изменится тип?
	- Если ref === null, `useImperativeHandle` не выполнится — React ничего не запишет
	- Если ref изменит тип (например, с `useRef()` на колбэк-реф), React:
		- сначала вызовет cleanup предыдущего handle (если был)
		- потом вызовет createHandle для нового рефа
    
### useDebugValue

271. Как работает `useDebugValue` и влияет ли он на продакшн-бандл?
	- `useDebugValue(value, formatFn?)` — это хук, который используется исключительно для отладки в React DevTools
	- Не влияет на поведение компонента, не вызывает побочные эффекты, удаляется на продакшн-сборке

### `useOptimistic`

272. Что делает `useOptimistic` и как он связан с `Server Action`s?
	- `useOptimistic(`state`, `updateFn`)` позволяет временно подменять `state` UI-объектом, отражающим предполагаемый результат асинхронного действия, пока оно не завершится
	- `useOptimistic` позволяет сразу обновить UI, пока `Server Action` выполняется
	- После завершения `Server Action` (успешного или с ошибкой), произойдёт сброс optimistic `state`, и UI обновится с новыми реальными данными
273. Как выглядит типичная схема: optimistic update → реальный результат → reconcile?
	- Пользователь отправляет данные
	- `addOptimistic`(message) вызывается, UI сразу обновляется через `updateFn`
	- В фоне стартует `Server Action` (или любой async logic).
	- Когда async завершился:
		- Если SSR — сервер возвращает новый `state`.
		- Если CSR — клиент получает новые данные.
	- UI «reconciles» — т.е. сбрасывается optimisticState → `state`
274. Как отменить optimistic `state` при отмене запроса или ошибке?
	- Нет прямого API для отмены optimistic update вручную — React автоматически сбрасывает optimistic `state`
		- произойдёт новый render с обновлённым `state` (например, после fetch),
		- компонент размонтируется.
275. Можно ли использовать `useOptimistic` без form и `Server Action`s?
	- Да. `useOptimistic` — универсальный хук, он не зависит от form или `Server Action`s, может использоваться в `startTransition`, `onClick`, `onSubmit`, внутри обычного async-обработчика.
276. Что произойдёт, если optimistic value конфликтует с новым реальным `state`?
	- При следующем ререндере UI заменит optimistic `state` новым `state`, полученным извне
	- Конфликтов не будет — `useOptimistic` не делает дифф между ними.
277. Как `useOptimistic` влияет на Suspense и конкурентный рендеринг?
	- `useOptimistic` полностью совместим с Concurrent Mode.
	- Он может использоваться внутри `startTransition` для немутирующего UI-обновления.
	- Работает как низкоприоритетный рендер и не блокирует основной рендер.
	- Если используется в дереве с <Suspense>, то optimistic UI отрендерится до suspense-фолбека.
278. Как работает `updateFn` и почему важно возвращать новый объект, а не мутировать?
	- `updateFn`(`state`, `optimisticValue`) должен возвращать новый `state`.
	- React ожидает иммутабельность — мутирование `state` не вызовет правильного рендера и может сломать работу.
279. Может ли `useOptimistic` быть использован с внешними `state` management (`Redux`/`Zustand`)?
	- Да, но `useOptimistic` — локальный хук, он не управляет внешним хранилищем.
	- Он не должен напрямую мутировать `Zustand`/`Redux` `state`.
	- Оптимистичное состояние может быть только для UI, а после успешного запроса обновляется реальный стор:
    
### `useActionState`

280. Чем `useActionState` отличается от обычного `useState` + `useEffect`?
	- `useActionState` объединяет в себе управление локальным состоянием и вызов асинхронной формы-ориентированной функции (`action`), обновляя состояние по результату `action`.
	- В отличие от `useState` + `useEffect`, где нужно вручную слушать изменения и обновлять состояние, `useActionState` автоматически синхронизирует состояние с результатом последнего вызова `action`.
281. Для чего нужен `useActionState`?
	- Управление состоянием, которое обновляется в результате отправки формы или вызова асинхронного `action`.
	- Синхронизация UI с результатом серверной функции (`Server Action`) при прогрессивной гидратации и взаимодействии.
	- Облегчение написания интерактивных форм и асинхронных действий без громоздких эффектов.
282. Какие аргументы принимает `useActionState`?
	- - `action`Fn: асинхронная функция или `Server Action`, вызываемая при отправке формы. Получает первым аргументом текущий (или предыдущий) `state`, затем `formData`.
	- initialState начальное значение состояния до первой отправки формы.
	- permalink (опционально): URL для прогрессивного улучшения на динамических страницах (редиректы до гидратации).
283. Что возвращает `useActionState`?
	- Состояние (`state`) — это значение, которое возвращает переданная функция после выполнения. Изначально оно равно initialState, а потом обновляется при каждом вызове.
	- Функция действия (`action`) — обёртка над твоей функцией. Её можно передать как `action`={...} в форму или вызывать вручную. Она принимает `formData` и вызывает переданную функцию с prevState и `formData`.
	- Флаг `isPending` — указывает, выполняется ли сейчас `action`. Автоматически становится true при запуске и false после завершения, даже если внутри используется await.
284. Как `useActionState` помогает обрабатывать формы и асинхронные действия?
	- Возвращает изменяемый `state`, который отражает результат последнего выполненного `action`.
	- Возвращает модифицированный `action` (formAction), который следует использовать в <form `action`={formAction}> или в кнопке с formAction.
	- Автоматически управляет состоянием ожидания (`isPending`) для UI.
	- Обновляет `state` после завершения `action`, вызывая ререндер компонента
285. Что делает `action`(prevState, `formData`) и как использовать `formData` внутри?
	- `action` — функция с подписью (prevState, `formData`) => newState | Promise<newState>.
	- prevState — текущее состояние формы/компонента до отправки.
	- `formData` — объект FormData с данными формы, передаваемый при отправке.
	- Внутри `action` можно обрабатывать `formData`, вычислять новое состояние на основе предыдущего, возвращать результат синхронно или асинхронно.
286. Как работает взаимодействие с `Server Action`s?
	- При использовании с `Server Action`s `useActionState` позволяет получить результат выполнения серверной функции и сразу обновить локальное состояние.
	- При этом форма может быть интерактивной до полной гидратации, так как React уже знает, как обновлять состояние на основе ответа сервера.
	- - permalink позволяет задать URL для прогрессивного улучшения на серверных маршрутах.
287. Что происходит, если `action` возвращает ошибку — влияет ли это на UI?
	- Если `action` выбрасывает ошибку (reject), `useActionState` не обновит состояние.
	- Ошибка не перехватывается внутри хука — нужно обрабатывать её вручную (например, try/catch внутри `action` или обрабатывать ошибки глобально).
	- В UI состояние останется прежним, и `isPending` перейдёт в false.
	- Для отображения ошибок лучше использовать отдельный `state` или структуру данных, возвращаемую из `action`.
288. Можно ли вызвать setState внутри `action` напрямую?
	- Нет. `action` — чистая функция, которая должна возвращать новое состояние.
	- Вызовы локальных React setState вне компонента из `action` невозможны.
	- Все обновления состояния происходят через возвращаемое значение `action` и механизм `useActionState`.
289. Как сбрасывается `state`, если отправка формы отменена или изменилась?
	- Если отправка отменена (например, переход на другую страницу), состояние `useActionState` остаётся текущим до следующей успешной отправки.
	- Если меняется initialState при повторном рендере, он игнорируется после первого действия — состояние сохраняется между отправками.
	- Для сброса состояния нужно либо использовать отдельную логику, либо заново размонтировать компонент
290. Как `useActionState` влияет на retry, Suspense и optimistic UI?
	- `useActionState` автоматически обновляет состояние по результату `action`, что упрощает retry — достаточно повторить вызов `action`.
	- Поддержка Suspense и progressive hydration реализуется через серверные механизмы React и `Server Action`s.
	- Для сложного optimistic UI лучше использовать `useOptimistic` или сторонние подходы, так как `useActionState` ориентирован на результат `action`, а не промежуточное состояние.
291. Как синхронизировать состояние `useActionState` с пропсами?
	- `useActionState` не синхронизируется с пропсами автоматически. Он использует initialState только один раз при инициализации и больше не реагирует на его изменени
	- Для синхронизации с внешними данными (пропсами или глобальным стором) нужно либо использовать локальный `useState` и синхронизировать его вручную через `useEffect`, либо вообще не использовать `useActionState` и управлять стейтом внешне