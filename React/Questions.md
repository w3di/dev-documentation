
#### **1. Virtual DOM (Базовые принципы)**

1. Что такое Virtual DOM?
	1. Virtual DOM - это **абстрактное представление UI** в виде дерева **обычных JavaScript-объектов**, которые отражают структуру реального DOM. React использует его, чтобы **оптимизировать и контролировать обновления интерфейса**.
2.  Как работает Virtual DOM?
	1. Компонент возвращает JSX → превращается в дерево Virtual DOM.
	2. При изменении состояния/пропсов React создаёт новое дерево VDOM.
	3. React сравнивает новое и старое дерево (алгоритм diff).
	4. Вычисляется минимальный набор изменений (патчи)
	5. Реальный DOM обновляется **точечно**, на основе diff-а.
3. Что может спровоцировать обновление Virtual DOM?
	1. Изменение `props` компонента
	2. Изменение контекста через `useContext`
	3. Монтирование и размонтирование компонентов
	4. Изменение состояния через `useState`/`useReducer`
	5. Любые изменения данных, влияющие на вывод JSX
4. В чем минусы Virtual DOM над Fiber?
	1. Старый Virtual DOM работал синхронно и непрерываемо, что приводило к блокировкам UI при больших обновлениях.
	2. Отсутствие приоритезации обновлений: все обновления обрабатывались с одинаковым приоритетом.
	3. Нельзя было **прервать, отложить или отменить рендеринг**, что негативно влияло на отзывчивость интерфейса.
	4. Отсутствие инкрементального (пошагового) рендеринга
	5. Отсутствие возможности прерывать и возобновлять рендеринг с учётом приоритетов.
5. Где работает Virtual DOM?
	1. Virtual DOM работает в памяти JavaScript-движка, то есть в оперативной памяти (RAM) браузера, внутри JavaScript-окружения
6. Из чего состоит Virtual DOM?
	1. Virtual DOM состоит из JavaScript-объектов, каждый из которых представляет **один UI-элемент** (аналог узла DOM)
7. Почему Virtual DOM эффективнее прямых манипуляций с DOM?
	1. Прямые манипуляции с DOM вызывают дорогостоящие затраты браузера на layout/repaint.
	2. Работать с UI в памяти,
	3. Обновления происходят в памяти, что позволяет вычислять минимальный набор изменений (diffing) и применять их пакетно, снижая количество дорогостоящих операций с реальным DOM
8. Как работает алгоритм **diffing** в React для сравнивания изменения в Virtual DOM?
	1. React использует эффективный алгоритм diffing с линейной сложностью O(n)
	2. Сравнивает элементы сверху вниз и слева направо.
	3. Если у элементов **разный `type`** (например, `div` и `span` или разные компоненты), React полностью заменяет соответствующее поддерево.
	4. Если `type` совпадает, React сравнивает **props** и рекурсивно переходит к сравнению **детей**.
	5. При сравнении детей React ориентируется на позицию элементов и `key
		1. Если ключи присутствуют, используется сопоставление по ним для эффективной обработки добавлений, удалений и перемещений.
		2. Без ключей сравнение идёт по индексу, что менее эффективно и может привести к лишним обновлениям.
9. Как ключи (`key`) влияют на процесс сравнения элементов?
	1. Ключи (`key`) — это уникальные идентификаторы элементов списка, которые React использует для сопоставления элементов между старым и новым деревом
	2. Если ключи присутствуют, React сопоставляет элементы по ним, что позволяет эффективно выявлять: - добавленные, удалённые перемещённые элементы.
	3. Без ключей React сравнивает элементы **по их позиции (индексу)** в массиве
#### **2. Fiber: Архитектура и структура**
1. Что такое React Fiber и чем он отличается от Stack Reconciler?
	1. Прерываемость
	2. Приоритезация
	3. Инкрементальный рендеринг
2. Почему Fiber использует связный список, а не рекурсивный обход?
	1. Связный список позволяет React:
		1. Выполнять обход дерева итеративно, без глубокого рекурсивного стека, что снижает риск переполнения стека
		2. Прерывать и возобновлять рендеринг
		3. Управлять приоритетами задач и планировать работу по частям
	2. Рекурсия же требует полного прохода и не позволяет прерывать работу посередине.
3. Как работает связный список в контексте Fiber?
	1. это структура из объектов FiberNode, где каждый узел содержит ссылки:
		1. child — на первого потомка,
		2. `sibling` — на следующего брата (соседа),
		3. `return` — на родителя.  
    2. Так можно пройти всё дерево последовательно, переходя от родителя к первому ребёнку, потом к соседям, обходя дерево без рекурсии.
4. Что такое work loop в React Fiber и как он организует рендеринг?
	1. **Work loop в React Fiber** — это основной цикл, в котором React **пошагово обходит дерево Fiber**, создаёт/обновляет `FiberNode`'ы и готовит дерево к коммиту. Он лежит в основе **инкрементального, прерываемого рендеринга**.
5. Как связный список Fiber позволяет прерывать и возобновлять рендеринг?
	1. обход дерева — это итеративный процесс с явным хранением текущей позиции, это позволяет просто сохранить состояние обхода (текущий узел), остановить цикл и освободить основной поток для других задач, при следующем вызове React продолжит обход с сохранённого узла, а не начинает заново или не уходит в глубокую рекурсию
6. Какие бывают типы флагов (`flags`) в `FiberNode` и какие операции они обозначают?
	1. `flags` — это битовая маска, которая сообщает React, какие действия нужно выполнить над узлом на этапе **commit**. Основные флаги:
		1. Placement — узел нужно **вставить** в DOM (новый элемент).
    	2. Update`** — узел нужно **обновить** (например, props или DOM-атрибуты).
		3. Deletion — узел нужно **удалить** из DOM.
		4. ChildDeletion — удалить одного или нескольких потомков.
		5. Ref — обновить ref.
		6. Passive — выполнить эффекты `useEffect`.
7. Как работает система приоритетов в React Fiber и как она влияет на рендеринг?
	1. Каждое обновление получает приоритет — через механизм `Lanes`.
	2. React сначала обрабатывает **более приоритетные задачи** (например, ввод), менее важные — откладывает.
8. Что такое FiberNode и как он устроен?
	1. FiberNode — это объект, представляющий один узел дерева Fiber. Он содержит всю информацию, необходимую React для управления рендерингом и обновлением конкретного UI-элемента
9. Какие ключевые поля содержит объект FiberNode и что каждое из них означает?
	1. stateNode — ссылка на реальный инстанс, связанный с этим узлом (DOM-элемент, экземпляр класса, или null для функциональных компонентов).
	2. return — ссылка на родительский FiberNode, позволяющая подниматься вверх по дереву.
	3. child — ссылка на первый дочерний FiberNode, начало обхода детей.
	4. sibling — ссылка на следующий соседний FiberNode на том же уровне.
	5. flags — битовая маска, указывающая, какие операции (вставка, обновление, удаление) нужно выполнить с этим узлом.
10. Как взаимодействуют FiberNode поля `return`, `child` и `sibling` для обхода дерева Fiber без рекурсии?
	1. Поле `child` позволяет спуститься вниз по дереву
	2. поле `sibling` — перейти к соседнему узлу на том же уровне
	3. поле `return` — подняться вверх к родителю после обхода всех детей.
	4. Вместе они реализуют итеративный обход дерева, заменяющий рекурсию, что даёт контроль над процессом рендеринга и позволяет прерывать и возобновлять работу.
11. Что такое двойная буферизация (double buffering) в Fiber?
	1. Двойная буферизация в Fiber — это хранение двух деревьев (current и working) для безопасного обновления UI без блокировок: изменения делают в рабочем дереве, а после завершения заменяют текущее.
12. Как обновляется UI в React Fiber (полный цикл от `setState` до отрисовки)?
	1. Инициирование обновления
		1. создаётся объект обновления, который добавляется в очередь обновлений соответствующего `FiberNode`.
	2. Приоритезация
		1. Обновление получает приоритет через систему **Lanes**.  
	3. Планирование задачи (Scheduler)
		1. Scheduler решает, когда запускать работу: сразу (высокий приоритет) или отложить (низкий).
	4. Render-фаза (Reconciliation) - эта фаза прерываема и инкрементальна, может быть приостановлена и возобновлена.
		1. Создаётся новое дерево `work-in-progress` (рабочее дерево Fiber) на основе текущего.
		2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие `FiberNode`'ы, собирает список эффектов
	5. Завершение render-фазы
		1. После обхода дерева React формирует полный список эффектов для commit-фазы.
	6. Commit-фаза (синхронная, непрерываемая)
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (`cleanup`) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции `useLayoutEffect`
		4. Выполняются функции `useEffect`
	7. Обновление текущего дерева
		1. Рабочее дерево `work-in-progress` становится текущим (`current`), старое может быть удалено или повторно использовано
13. Какие фазы есть в Fiber?
	1. Reconciliation (render фаза) - Прерываемая и инкрементальная.
	2. Commit фаза - Синхронная и непрерываемая.
14. Чем отличаются эти фазы и какую роль они играют в обновлении UI?
	1. render-фаза отвечает за подготовку и планирование изменений, commit-фаза — за их окончательное применение и взаимодействие с DOM.
15. Что происходит в фазе **Render**?
	1. . Создаётся новое дерево `work-in-progress` на основе текущего.
	2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие `FiberNode`'ы, собирает список эффектов
	3. После обхода дерева React формирует полный список эффектов для commit-фазы.
	4. Фаза может быть прервана и возобновлена, чтобы избежать блокировки основного потока
16. Что происходит в фазе **Commit**?
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (`cleanup`) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции `useLayoutEffect`
		4. Выполняются функции `useEffect
		5. Commit-фаза не прерывается, чтобы гарантировать консистентность DOM
17. Что такое Effect List?
	1. это связанный список узлов Fiber с помеченными изменениями, которые React последовательно применяет к DOM и запускает соответствующие эффекты в фазе commit.
18. Как формируется и используется **Effect List**?
	1. Во время render-фазы React при обходе `work-in-progress` дерева помечает каждый `FiberNode` с изменениями специальными флагами
	2. Эти помеченные узлы собираются в Effect List — связанный список эффектов, которые нужно применить.
	3. В commit-фазе React последовательно проходит по Effect List и выполняет соответствующие операции
19. Что такое **Lane-модель** и как она работает?
	1. Lane-модель — система приоритизации обновлений в React Fiber, где каждое обновление относится к одной или нескольким lanes — битовым флагам разного приоритета.
20. Какие типы (lanes) существуют (`SyncLane`, `InputContinuousLane`, `DefaultLane` и др.)?
	1. SyncLane — максимальный приоритет, обновления должны выполниться сразу (например, flushSync).
	2. InputContinuousLane — приоритет интерактивного ввода, чтобы UI был отзывчивым.
	3. DefaultLane — обычные фоновый обновления.
21. Что такое Scheduler?
	1. Это планировщик задач React, который решает, когда и с каким приоритетом запускать работу по обновлению UI. Он координирует выполнение render-фазы, позволяя прерывать низкоприоритетные задачи ради более важных
22. Как **Scheduler** выбирает приоритет задач?
	1. Scheduler использует lanes и сопоставляет их с уровнями приоритетов.
	2. Задачи с более высоким приоритетом прерывают текущие и запускаются раньше
23. Что делает `flushSync` и как он обходит приоритезацию?
	1. `flushSync` — функция, которая запускает обновление синхронно, игнорируя систему приоритетов и асинхронность Scheduler. Она принудительно выполняет render и commit сразу, чтобы обновление UI произошло немедленно
24. Что такое **Concurrent Mode** и как он меняет рендеринг?
	1. Concurrent Mode - новый способ работы React с рендерингом, при котором React не блокирует основной поток на долгое время, а разбивает работу на небольшие части (инкрементальный рендеринг).
	2. Позволяет React **приостанавливать, возобновлять и приоритезировать** работу по обновлению интерфейса.
25. Что такое time slicing?
	1. механизм в React Fiber, который разбивает работу по рендерингу на небольшие части. React выполняет эти части по очереди, прерываясь по тайм-ауту, чтобы дать браузеру возможность обрабатывать пользовательские события и другие задачи.
	2. Time slicing реализуется за счёт итеративного обхода дерева Fiber с сохранением состояния, чтобы при возобновлении рендеринга продолжить с того места, где остановились.
26. Как React прерывает и возобновляет рендеринг (time slicing)?
	1. React разбивает работу рендера на небольшие задачи — единицы работы (`units of work`).
	2. При достижении лимита времени текущая задача прерывается, текущее состояние обхода (`nextUnitOfWork`) сохраняется.
	3. В следующий момент React возобновляет обход с сохранённой позиции, позволяя браузеру обрабатывать важные события между этими фрагментами работы
27. Как Suspense использует механизм прерывания?
	1. Suspense позволяет React прервать рендеринг компонента, если он «зависает» на асинхронной операции (например, загрузке данных или кода).
	2. React отменяет текущую работу по рендеру, показывает fallback UI, а затем возобновляет рендеринг, когда асинхронная операция завершена.
#### **6. Гидртация и SSR в React**
20. Как работает гидратация (hydration) после SSR?
	1. Сервер присылает готовую страницу с уже заполненным HTML
	2. Браузер показывает этот HTML — пользователь сразу видит контент, даже если JS ещё не загрузился.
	3. После загрузки JS React берёт этот HTML и «подключает» к нему свою логику: навешивает обработчики событий, создаёт внутренние структуры для управления состоянием.
	4. React не рисует заново весь UI, а работает поверх уже существующего DOM, делая его интерактивным.
21. Что такое **selective hydration** и как она ускоряет загрузку?
	1. Selective hydration — это стратегия, при которой React не гидратирует сразу всё дерево, а по частям и с приоритетом. Например, сначала гидратируются видимые пользователю интерактивные части, а остальные — позже или при взаимодействии.
22. Что такое Server Components?
	1. Server Components — это React-компоненты, которые рендерятся только на сервере. Они не попадают в клиентский бандл, не запускают JS в браузере и позволяют значительно уменьшить размер кода на клиенте. Серверные компоненты могут напрямую обращаться к базе данных или файловой системе и отправлять готовый HTML, облегчая загрузку и повышая производительность
23. Что такое серверные функции?
	1. Серверные функции (Server Actions) — это функции, которые выполняются на сервере по вызову из React-компонента. Они могут обрабатывать данные, выполнять бизнес-логику или работать с API, при этом не отправляя клиенту лишний JavaScript
24. Что такое деректива use client?
	1. строчка в начале файла которая указывает, что компонент должен рендериться и работать на клиенте.
25. Что такое деректива use server?
	1. строчка в начале файла указывает, что функция или компонент выполняется только на сервере.
26. Что можно делать в сервеных компонентах чего нельзя в клиентских?
	1. доступ к базе данных, файловой системе, секретам
	2. использовать серверные зависимости (например, `fs`, `pg`, `bcrypt`)
27. Что можно делать в клиентский компонентах чего нельзя в серверных?
	1. использовать:
		1. браузерные API
		2. Хуки react
		3. обработчики событий
		4. манипулировать с DOM
28. Что такое Streaming SSR и как он работает?
	1. Streaming SSR — это возможность React отдавать HTML по мере готовности дерева пока React рендерит все по частям
	2. Работает через `renderToPipeableStream` (Node.js) или `renderToReadableStream` (Edge/Cloud).
29. Что такое **hydration mismatch**? 
	1. **Hydration mismatch** — это ситуация, когда HTML, пришедший с сервера (SSR) не совпадает с тем, что React "ожидает" при клиентской гидратации.
30. Как избежать hydration mismatch?
	1. **Соблюдать одинаковую логику рендера** на сервере и клиенте.
		1. не использовать случайные значения (`Math.random()`, `Date.now()`),
		2. `window`, `document` и любые browser-only API.
		3. Использовать `useEffect`, а не `useLayoutEffect` для client-only логики
31. Почему важно, чтобы SSR и клиентский рендер генерировали одинаковый DOM?
	1. React при гидратации **подключается к существующему серверному HTML** и ожидает, что структура совпадёт. Если DOM не совпадает — происходит **hydration mismatch**, React показывает предупреждения и может перерисовать большие участки UI
32. Что произойдёт при hydration mismatch?
	1. React покажет warning, а иногда — перерисует весь DOM узел
33. как useLayoutEffect может влиять на hydration?
	1. `useLayoutEffect` выполняется **до отрисовки**, только на клиенте — и может **синхронно изменить DOM**, не совпадающий с HTML от сервера, что приводит к hydration mismatch
34. Как SSR помогает уменьшить Time to First Byte (TTFB)
	1. SSR позволяет серверу сразу отправить полностью сформированный HTML, благодаря чему браузер начинает отображать контент сразу после получения первого байта без задержек на загрузку и выполнение JS
35. Как избежать отправки лишнего JS на клиент
	1. Использовать Server Components, которые рендерятся только на сервере и не попадают в клиентский бандл.
	2. Применять `use client` директиву строго там, где нужна интерактивность.
	3. Делать код-сплиттинг и динамический импорт для загрузки JS только при необходимости.
	4. Минимизировать зависимости и не импортировать клиентские библиотеки в серверные компоненты.
	5. Использовать selective hydration, чтобы загружать JS по частям и с приоритетом.
36. Как работает Suspense и lazy loading серверных данных и компонентов?
	1. Серверные компоненты могут использовать асинхронные функции (например, `await fetch()`) прямо внутри тела компонента. React ждёт их завершения или отдаёт fallback, обеспечивая эффективный ленивый рендеринг и загрузку.
	2. После загрузки данных React «дозаписывает» оставшийся HTML по стриму (Streaming SSR), обеспечивая эффективный ленивый рендеринг и быструю первую отрисовку.
	3. На клиенте Suspense переключается между fallback и готовым UI по мере завершения загрузки, поддерживая плавный переход.
37. Какими хуками можно пользоваться в серверных компонентах?
	1. useId - Генерация стабильных ID
#### **7. Оптимизации**
22. Как React избегает лишних ререндеров?
	1. Virtual DOM и сравнение (reconciliation)
	2. Мемоизация с `React.memo`
	3. Хуки `useMemo` и `useCallback`
	4. Контроль ключей (`key`) в списках
23. Как работает **batching** обновлений?
	1. это механизм объединения нескольких обновлений состояния (state updates) в один цикл рендера
	2. внутри обработчика вызывается несколько `setState` или обновлений, React объединяет (batch) их и выполняет **один рендер** после завершения обработчика
24. Как Fiber улучшает отзывчивость UI (например, при анимациях)?
	1. Приоритизация обновлений
	2. Прерываемость рендера
	3. благодаря time slicing и прерывистому рендеру, браузер может своевременно обновлять кадры анимаций и избегать "фризов".
#### **8. Продвинутые сценарии**
25. Как Fiber обрабатывает асинхронные операции?
	1. Fiber сам по себе не выполняет асинхронные операции, но он управляет их результатами и обновлением UI с учётом приоритетов
26. Как работает **Suspense для данных**?
	1. Suspense для данных приостанавливает рендер компонента, если данные ещё не готовы, бросая Promise. React показывает fallback UI, пока Promise не разрешится, после чего рендер возобновляется с готовыми данными.
27. Что такое use()?
	1. `use()` — это React API для чтения значения ресурса, такого как Promise или контекст
28. для чего нужен use()?
	1. Чтобы "подписаться" на Promise или контекст и получить их значение, интегрируясь с Suspense и Error Boundaries.
29. как работает use()?
	1. Если передан Promise, React "приостанавливает" рендер компонента до его разрешения (Suspense fallback показывается).
	2. Если Promise отклонён — срабатывает ближайший Error Boundary.
	3. Если передан контекст — `use()` возвращает его значение, как `useContext`, но может использоваться в условных и циклах.
30. где работает use()? ssr или csr?
	1. Работает и на сервере, и на клиенте, но преимущественно используется для чтения ресурсов в Client Components
31. Как новый хук `use()` взаимодействует с Fiber?
	1. `use()` интегрируется с механизмом Suspense в Fiber: при ожидании Promise Fiber приостанавливает рендер и переключается на fallback, а после разрешения возобновляет рендер с полученными данными.
32. как использовать use() с контекстом?
	1. Использование `use` с контекстом способ читать значение контекста, аналогичный `useContext`, но с преимуществом возможности вызывать `use` внутри условных блоков и циклов.
33. Почему нельзя просто `await` в Client Components вместо use()?
	1. `await` нельзя использовать напрямую в теле функционального компонента — он синхронный и блокирует. `use()` позволяет React управлять состоянием ожидания асинхронного результата в рамках Fiber и Suspense.
#### **9. Отладка и внутренности**
 1. В чём разница между `useLayoutEffect` и `useEffect` с точки зрения Fiber?
	 1. - `useLayoutEffect` — синхронный, блокирующий эффект, полезен для измерений DOM и синхронных манипуляций. выполняется в **phase commit**, **после того, как React применил изменения к DOM**, но **до того, как браузер обновил экран**
    2. `useEffect` — асинхронный, неблокирующий, выполняется после отрисовки, оптимален для сетевых запросов, подписок и не критичных к времени операций. выполняется **после фазы commit и после того, как браузер отрисовал обновлённый UI**
2. Как React делит работу на чанки и приостанавливает рендеринг для более важных задач?
	1. React Fiber разбивает работу рендеринга на небольшие части (чанки). При этом рендеринг **приостанавливается** (interruptible rendering), если появляется задача с более высоким приоритетом (например, пользовательский ввод)
3. Как React обрабатывает "зависшие" компоненты (например, при загрузке данных).
	1. При загрузке данных, если компонент возвращает Promise, React **приостанавливает его рендеринг**, показывая запасной UI (fallback) через Suspense. Когда данные загружены, React продолжает рендеринг компонента с этими данными
4. что такое Selective Hydration?
	1. Selective Hydration — это техника, при которой React при гидратации на клиенте сначала  гидратирует только самые важные или видимые части UI, а остальные части гидратируются позже, по мере необходимости.
5. Разница между срочными (urgent) и отложенными (non-urgent) обновлениями и Как это связано с приоритетами в Scheduler.
	1. Срочные (urgent) обновления — это события с высоким приоритетом, как ввод пользователя или клики, которые React должен обработать немедленно.
	2. Отложенные (non-urgent) обновления — менее важные задачи, например, обновление неактивных компонентов, которые можно выполнить позже.  
	3. Scheduler React управляет этими приоритетами, позволяя прерывать низкоприоритетные задачи для срочных, поддерживая отзывчивость UI.
6. что такое interruptible rendering?
	1. Interruptible rendering — возможность React прерывать текущий процесс рендеринга в любой момент, чтобы переключиться на более приоритетную работу, а затем продолжать с места остановки
7. Почему Server Components не имеют состояния и хуков?
	1. Server Components рендерятся на сервере и не имеют жизненного цикла или интерактивности, поэтому состояние и хуки им не нужны
8. Как server Components уменьшают размер бандла.
	1. Потому что Server Components не включаются в клиентский бандл JavaScript — они полностью рендерятся на сервере и передают клиенту уже готовый HTML
9. Как работают `React.lazy` и `Suspense` для динамического импорта компонентов?
	1. React.lazy` динамически импортирует компонент (через `import()`), возвращая промис.
	2. Пока компонент загружается — `Suspense` показывает fallback UI.
	3. После загрузки компонент рендерится как обычно.
10. Какие бывают варианты fallback UI и как работает вложенность в `Suspense`?
	- Fallback — любой React-элемент, показываемый во время загрузки.
	- Вложенные Suspense показывают самый близкий fallback для загрузки в своей области.
11. Какие основные этапы монтирования, обновления и размонтирования компонентов в функциональном React?
	1. Монтирование: рендер + запуск эффектов с пустым массивом зависимостей (`useEffect(() => {}, [])`).
	2. Обновление: повторный рендер + эффекты с изменившимися зависимостями.
	3. Размонтирование: вызов очисток эффектов (функций, возвращаемых из `useEffect`
12. Как компоненты ведут себя в разных режимах рендера (синхронном и конкурентном)?
	1. Sync: рендер блокирует UI до конца.
	2. Concurrent: рендер можно приостанавливать, приоритеты обновлений.
---
### 6. Контроль UI через props и состояние
1. Как реализуется однонаправленный поток данных в React?
	- Однонаправленный поток данных в React означает, что данные всегда идут сверху вниз — от родительских компонентов к дочерним через props
	- Родитель хранит состояние и передаёт его дочерним, которые могут только читать эти props, но не менять их напрямую. Изменения состояния происходят в родителе через коллбэки, переданные вниз
2. Что такое “lifting state up” и как его правильно использовать?
	- это когда состояние, нужное нескольким компонентам, поднимается к их ближайшему общему родителю. Вместо того чтобы каждый компонент держал своё локальное состояние и пытался синхронизировать его, состояние централизуется в одном компоненте-родителе, а дочерним передаются через props и коллбэки для изменения.
3. В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?
	- **Контролируемые компоненты** — это компоненты, где состояние формы полностью управляется React через `state` и обновляется через обработчики (`onChange`). Значение поля всегда берётся из состояния, а не из DOM.
	- **Неконтролируемые компоненты** — это компоненты, где состояние формы хранится непосредственно в DOM, а React лишь получает доступ через  ref. React не управляет значением, а читает его при необходимости.
	- Контролируемые компоненты позволяют сразу валидировать, управлять вводом, делать условный рендер элементов формы.

---

1. Как и зачем применять `React.Fragment`?
	- Позволяет сгруппировать несколько элементов без добавления лишнего DOM-узла.

---

### 9. ReactDOM.createPortal

1. Когда и как правильно использовать порталы в React?
	- Используйте порталы, когда UI-элемент должен визуально выходить за пределы текущей иерархии DOM — например, модальные окна, тултипы, всплывающие меню, уведомления
2. Какие особенности управления событиями и фокусом возникают при работе с порталами?
	- События всплывают по React-дереву, а не по DOM — обработчики работают как обычно, несмотря на другой DOM-узел
	- Фокусом нужно управлять вручную: при открытии модалки ставить фокус в портал, при закрытии — возвращать на исходный элемент.
3. Какие аргументы принимает cratePortal?
	1. children** — React-элементы, которые нужно отрендерить (JSX, компоненты, строки, фрагменты и т.п.).
	2. domNode** — DOM-узел, куда будет помещён этот контент. Этот узел должен уже существовать в DOM.
	3. key** (опционально) — уникальный ключ (строка или число) для идентификации портала, особенно при рендере списков порталов.
---

### 10. Управление фокусом и доступность (a11y)

1. Какие стандартные атрибуты и API React помогают создавать доступный UI?
	- aria-* (`aria-label`, `aria-labelledby`, `aria-describedby`, `aria-hidden`) для описания элементов для скринридеров.
	- tabIndex - для настройки порядка табуляции и возможности фокусировки.

---

### 11. Работа с формами

- Как правильно реализовать контролируемые и неконтролируемые компоненты форм?
	1. Контролируемые компоненты:** значение хранится в состоянии (`useState`), обновляется через `onChange`. React полностью управляет вводом.
	2. **Неконтролируемые компоненты:** значение хранится в DOM, доступ через `ref`. React не управляет вводом напрямую.
- Как обрабатывать события `onChange` и `onSubmit` в формах?
	- **onChange:** обновляет состояние для контролируемых компонентов.
	- o**nSubmit:** отменяет стандартное поведение и обрабатывает данные из состояния или `ref`.
- Как сделать простую валидацию без сторонних библиотек?
	- выполняется прямо в обработчике `onSubmit` или `onChange` — проверяем значения на нужные условия с сохранением ошибок в состоянии
	- HTML-атрибуты валидации `required`, `minLength`, `pattern`
---

### 12. Анимации без сторонних библиотек
- Как реализовать анимации с помощью CSS?
	- Создаёшь CSS-классы с `transition` (для плавных переходов свойств) или `@keyframes` (для сложных анимаций).
---

### 13. Event Delegation и Synthetic Events

- Как работает система `SyntheticEvent` в React?
	- `SyntheticEvent` — это обёртка над нативными событиями браузера, которую React создаёт для обеспечения **кроссбраузерного** и **одинакового API** при работе с событиями.
- В чём основные отличия между Synthetic Events и нативными событиями браузера?
	1. **Кроссбраузерность**  
	    1. `SyntheticEvent` предоставляет единый интерфейс, который одинаково работает во всех браузерах. Нативные события могут иметь отличия в свойствах и поведении между браузерами.
	2. **Поведение всплытия**  
	    События в React всплывают **по React-иерархии компонентов**, даже если DOM-структура другая (например, при использовании `createPortal`). Нативные события всплывают **по DOM-дереву**.
	3. **Совместимость с React API**  
	    1. Только `SyntheticEvent` работает корректно с системой приоритетов событий в concurrent режиме. Нативные события об этом "не знают".
	4. **API одинаково везде**  
	    1. У `SyntheticEvent` всегда есть стандартные свойства (`type`, `target`, `currentTarget`, `preventDefault()`, `stopPropagation()` и т.п.), даже если браузер этого не поддерживает напрямую.
---

### 14. Strict Mode и его влияние

- Как ведёт себя Strict Mode?
	- В Strict Mode компоненты и хуки специально монтируются, размонтируются и монтируются заново _в режиме разработки_. Это имитация двойного вызова жизненных циклов для выявления побочных эффектов
- Почему компоненты и хуки вызываются повторно в Strict Mode?
	- React повторно вызывает функции компонентов и эффекты, чтобы проверить, правильно ли они чистят ресурсы и не вызывают неожиданных сайд-эффектов при монтировании/размонтировании
- Как  Strict Mode  помогает улучшить качество кода и отловить ошибки?
	- Такая проверка помогает заранее выявлять баги, неправильное управление эффектами и состояние, делая код более устойчивым и предсказуемым перед продакшен-сборкой
- Как настроить Strict Mode?
	- обернуть компонент в `<React.StrictMode>`.

---

### 16. Context API (без хуков)
- Как получить доступ к контексту без хуков?
	через компонент `<MyContext.Consumer>`. В него передают функцию, которая получает текущее значение контекста.
- Какие проблемы с производительностью возникают при частых обновлениях контекста?
	- При изменении значения в провайдере все дочерние компоненты использующие контекст перерендериваются, даже если используют лишь часть данных или не затронуты логикой/

---

### 17. JSX под капотом

- Как JSX трансформируется в вызовы `React.createElement`?
	- JSX — это синтаксический сахар, который во время сборки транспилируется в вызовы `React.createElement`
- Что такое `ReactElement` и чем он отличается от компонента?
	- `ReactElement` — это обычный объект, который описывает элемент React: тип (тег или компонент), пропсы и детей. Это «план» для реального DOM. Он не является компонентом и не содержит логики — это результат вызова компонента или JSX. 

---
**Правила хуков**:

**useState**

1. Для чего нужен `useState`?
2. Что возвращает `useState`?
3. Как изменить состояние `useState`?
4. Как обновлять состояние на основе предыдущего значения?
5. Какие способы есть для обновления на основе предыдущего состояния?
6. Почему `setState` асинхронен, и как это влияет на обновления?
7. Что произойдет, если вызвать `setState` с тем же значением?
8. Как работает shallow compare в `useState`?
9. Как работает `useState` при повторных рендерах?
10. Как правильно обновлять состояние, если оно — объект или массив?
11. Почему нельзя вызывать `useState` условно?
12. В чем отличие `useState` от `useReducer`?
13. Как ведет себя `useState` при размонтировании компонента?
14. Как сделать ленивую инициализацию состояния в `useState`?
15. В чем разница между `useState(someFunction())`, `useState(someFunction)`, `useState(() => someFunction())`?
16. Можно ли мемоизировать `setState` с помощью `useCallback`?
17. Что произойдёт, если передать пропсы как начальное значение в `useState`, а затем эти пропсы изменятся?

---

**useEffect** и useLayoutEffect

- Для чего нужен `useEffect`?
- Когда вызывается `useEffect`?
- какие параметры принимает useEffect?
- Что возвращает useEffect?
- Как работает массив зависимостей?
- Что будет, если не указать зависимости?
- Как задать эффект только при монтировании?
- Как использовать `useEffect` с асинхронными функциями?
- Что такое функция очистки (cleanup)?
- Когда вызывается функция очистки?
- Как отменять асинхронные операции в useEffect?
- Чем `useEffect` отличается от `useLayoutEffect`?

---

**useRef**

- Для чего нужен `useRef`?
- Варианты использования useRef?
- Как получить доступ к DOM-элементу с помощью `useRef`?
- Что хранится в `.current`?
- Можно ли изменять `.current`?
- Вызывает ли изменение `.current` перерендер?
- Как использовать `useRef` для хранения значений между рендерами?
- Чем `useRef` отличается от `useState`?
- Как использовать `useRef` для хранения предыдущего значения?
---

**useMemo**
- Что такое `useMemo`?
- Какие аргументы принимает `useMemo`?
- Что возвращает `useMemo`?
- Когда применять `useMemo`?
- Когда `useMemo` бесполезен?
- Как работает мемоизация в `useMemo`?
- Что произойдёт, если не указать массив зависимостей?
- Когда `useMemo` может навредить производительности?
- Как `useMemo` сравнивает зависимости (по ссылке или по значению)?

---

**useCallback**

- Что такое `useCallback`?
- Какие аргументы принимает `useCallback`?
- Что возвращает `useCallback`?
- Когда применять `useCallback`?
- Когда `useCallback` бесполезен?
- Что будет, если функция в useCallback зависит от внешних значений, а они не указаны в зависимостях?
- Чем отличается `useCallback` от `useMemo`?
- Когда стоит предпочесть `useCallback` вместо обычной функции?
- можно ли заменить useCallback c помощью useMemo?


---

**useId**

- Для чего используется `useId`?
- Как работает `useId`?
- можно ли использвоать хук useId в серверных компонентах?
- Как `useId` помогает при серверном рендеринге (SSR)?
- В чём отличие `useId` от генерации ID через `Math.random()` или другие способы?
- Можно ли использовать `useId` для генерации ключей в списках?
- Что будет, если использовать `useId` в компоненте, который ререндерится много раз?
- Какие проблемы решает `useId` в контексте accessibility (например, для `label` и `input`)?
- Как `useId` ведёт себя при гидратации SSR?

---


**useContext**

- Для чего нужен `useContext`?
- Как создать и экспортировать контекст в React?
- Как использовать `useContext` для получения значения из контекста?
- Можно ли использовать `useContext` вне компонента? Почему?
- Как `useContext` работает при обновлении значения в провайдере?
- Как избежать лишних рендеров при использовании `useContext`?
- Можно ли использовать несколько контекстов одновременно? Как это делать?
- Когда использовать `useContext`, а когда — глобальные стейты типа Redux или Zustand?
- Как работает `useContext` с серверным рендерингом (SSR)?
- Какие ограничения и подводные камни есть у `useContext`?

---

**useReducer**

- Что такое `useReducer` и для чего он нужен?
- Чем отличается `useReducer` от `useState`?
- Как устроена редьюсер-функция? Какие параметры она принимает?
- Что возвращает `useReducer`?
- Что такое функция dispatch?
- Как задать начальное состояние и как сделать ленивую инициализацию?
- Как работает dispatch? Можно ли вызывать dispatch асинхронно?
- Как использовать `useReducer` с асинхронными операциями?
- Как использовать `useReducer` вместе с `useContext` для глобального стейта?
- Как React 18+ улучшает работу с `useReducer` (например, конкурентный режим и приоритеты обновлений)?
- Что происходит, если вызвать dispatch после размонтирования компонента?


-----
- useTransition
    
- useDeferredValue
    
- useSyncExternalStore
    
- useInsertionEffect
    
- useImperativeHandle
    
- useDebugValue
    
- useEvent
    
- useOptimistic
    
- useActionState