## 1. Virtual DOM и Reconciliation
1. Что такое Virtual DOM в React и зачем он нужен?
	- Virtual DOM - это абстрактное представление UI в виде дерева обычных JavaScript-объектов, которые отражают структуру реального DOM. React использует его, чтобы оптимизировать и контролировать обновления интерфейса.
2. Как работает Virtual DOM в React — от создания до обновления реального DOM?
	- Компонент возвращает JSX которое затем превращается в дерево Virtual DOM
	- При изменении состояния или пропсов React создаёт новое дерево VDOM
	- React сравнивает новое и старое дерево (алгоритм diff)
	- Вычисляется минимальный набор изменений (patch)
	- Реальный DOM обновляется точечно, на основе diff-а
3. Какие события в React приводят к пересозданию/обновлению Virtual DOM?
	- Изменение props компонента
	- Изменение реактивных состояния
	- Изменении контекста
4. Где выполняется Virtual DOM в React (в какой среде/памяти)?
	- Virtual DOM работает в памяти JavaScript-движка, то есть в оперативной памяти (RAM) браузера, внутри JavaScript-окружения
5. Из каких структур данных состоит Virtual DOM в React?
	- Virtual DOM состоит из JavaScript-объектов, каждый из которых представляет один UI-элемент (аналог узла DOM)
6. Почему Virtual DOM эффективнее прямых манипуляций с DOM?
	- Прямые манипуляции с DOM вызывают дорогостоящие затраты браузера на layout/repaint
	- Virtual DOM работает с UI в памяти
	- Обновления происходят в памяти, что позволяет вычислять минимальный набор изменений (diffing) и применять их пакетно, снижая количество дорогостоящих операций с реальным DOM
7. Как работает алгоритм diffing в React при сравнении изменений в Virtual DOM и какова его сложность?
	- React использует эффективный алгоритм diffing с линейной сложностью O(n)
	- Сравнивает элементы сверху вниз и слева направо
	- Если у элементов разный type (например, div и span или разные компоненты), React полностью заменяет соответствующее поддерево
	- Если type совпадает, React сравнивает props и рекурсивно переходит к сравнению детей
	- При сравнении детей React ориентируется на позицию элементов и key:
		- Если ключи присутствуют, используется сопоставление по ним для эффективной обработки добавлений, удалений и перемещений
		- Без ключей сравнение идёт по индексу, что менее эффективно и может привести к лишним обновлениям, а также к потере состояния компонентов
8. Что такое ключи (key) в React и как они влияют на сравнение элементов в списках?
	- Ключи (key) — это стабильные идентификаторы для элементов при повторном рендере, с ключами React сравнивает элементы по идентификаторам и может переиспользовать их вместо удаления и создания
	- Без ключей React сравнивает элементы по их позиции (индексу) в массиве, что может приводить не только к лишним обновлениям, но и к потере состояния компонентов
9. Как подбирать key при наличии дублирующихся данных (одинаковые названия) и отсутствии уникальных идентификаторов?
	1. для  статичных списков можно использовать индекс
	2. для динамических списков создавать уникальный ключ через комбинацию данных и индекса

#### 2. Fiber Architecture
10. Что такое архитектура React Fiber и чем она отличается от прежнего Stack Reconciler?
	- React Fiber - это архитектура React, которая превращает дерево компонентов в связанные узлы
	- Прерываемость
	- Приоритезация
	- Инкрементальный рендеринг
11. В чём недостатки старого синхронного reconciler'а по сравнению с React Fiber?
	- синхронный
	- Отсутствие приоритезации обновлений
	- Нельзя было прервать, отложить или отменить рендеринг, что негативно влияло на отзывчивость интерфейса
	- Отсутствие инкрементального (пошагового) рендеринга
12. Почему React Fiber использует связный список для обхода дерева, а не рекурсию?
	- Связный список позволяет React:
		- Выполнять обход дерева итеративно, без глубокого рекурсивного стека, что снижает риск переполнения стека
		- Прерывать и возобновлять рендеринг
		- Управлять приоритетами задач и планировать работу по частям
	- Рекурсия же требует полного прохода и не позволяет прерывать работу посередине
13. Как используется связный список узлов в React Fiber для обхода дерева?
	- это структура из объектов FiberNode, где каждый узел содержит ссылки:
		- child — на первого потомка
		- sibling — на следующего брата (соседа)
		- return — на родителя
	- Так можно пройти всё дерево последовательно, переходя от родителя к первому ребёнку, потом к соседям, обходя дерево без рекурсии
14. Что такое FiberNode в React и как он устроен?
	- FiberNode — это объект, представляющий один узел дерева Fiber. Он содержит всю информацию, необходимую React для управления рендерингом и обновлением конкретного UI-элемента
15. Какие ключевые поля содержит объект FiberNode и что каждое из них означает?
	- stateNode — ссылка на реальный инстанс, связанный с этим узлом (DOM-элемент, экземпляр класса, или null для функциональных компонентов)
	- return — ссылка на родительский FiberNode, позволяющая подниматься вверх по дереву
	- child — ссылка на первый дочерний FiberNode, начало обхода детей
	- sibling — ссылка на следующий соседний FiberNode на том же уровне
	- flags — битовая маска, указывающая, какие операции (вставка, обновление, удаление) нужно выполнить с этим узлом
16. Как поля return, child и sibling в FiberNode обеспечивают безрекурсивный обход дерева Fiber?
	- Поле child позволяет спуститься вниз по дереву
	- поле sibling — перейти к соседнему узлу на том же уровне
	- поле return — подняться вверх к родителю после обхода всех детей
	- Вместе они реализуют итеративный обход дерева, заменяющий рекурсию, что даёт контроль над процессом рендеринга и позволяет прерывать и возобновлять работу
17. Какие бывают типы флагов (flags) в FiberNode и какие операции они обозначают?
	- flags — это битовая маска, которая сообщает React, какие действия нужно выполнить над узлом на этапе commit. Основные флаги:
		- Placement — узел нужно вставить в DOM (новый элемент)
		- Update — узел нужно обновить (например, props или DOM-атрибуты)
		- Deletion — узел нужно удалить из DOM
		- ChildDeletion — удалить одного или нескольких потомков
		- Ref — обновить ref
		- Passive — выполнить эффекты useEffect
		- PassiveEffect — специфичный флаг для эффектов, указывающий на необходимость обработки пассивных эффектов
	- Кроме перечисленных, существуют и другие специфичные флаги для различных операций, но это детали внутренней реализации React
18. Что такое двойная буферизация (double buffering) в React Fiber и зачем она нужна?
	- Двойная буферизация в Fiber — это хранение двух деревьев (current и working) для безопасного обновления UI без блокировок: изменения делают в рабочем дереве, а после завершения заменяют текущее

#### 3. Fiber Render Process
19. Что такое work loop в React Fiber и как он организует процесс рендеринга?
	- Work loop в React Fiber — это основной цикл, в котором React пошагово обходит дерево Fiber, создаёт/обновляет FiberNode'ы и готовит дерево к коммиту. Он лежит в основе инкрементального, прерываемого рендеринга
20. Как связный список в React Fiber позволяет прерывать и возобновлять рендеринг?
	- обход дерева — это итеративный процесс с явным хранением текущей позиции, это позволяет просто сохранить состояние обхода (текущий узел), остановить цикл и освободить основной поток для других задач, при следующем вызове React продолжит обход с сохранённого узла, а не начинает заново или не уходит в глубокую рекурсию
21. Как обновляется UI в React Fiber: полный цикл от setState до отрисовки?
	- Инициирование обновления
		- создаётся объект обновления, который добавляется в очередь обновлений соответствующего FiberNode
	- Приоритезация
		- Обновление получает приоритет через систему Lanes
	- Планирование задачи (Scheduler)
		- Scheduler решает, когда запускать работу: сразу (высокий приоритет) или отложить (низкий)
	- Render-фаза (Reconciliation) - эта фаза прерываема и инкрементальна, может быть приостановлена и возобновлена
		- Создаётся новое дерево work-in-progress (рабочее дерево Fiber) на основе текущего
		- React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов
	- Завершение render-фазы
		- После обхода дерева React формирует полный список эффектов для commit-фазы
	- Commit-фаза (синхронная, непрерываемая)
		- Фаза размонтирования эффектов
			- Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
			- Очистка эффектов выполняется строго в порядке "снизу-вверх" (children → parent), чтобы избежать утечек или несогласованного состояния
		- Mutation этап
			- React применяет изменения в DOM: удаление, вставка, обновление
		- Выполняются функции `useLayoutEffect`
		- Выполняются функции `useEffect`
	- Обновление текущего дерева
		- Рабочее дерево work-in-progress становится текущим (current), старое может быть удалено или повторно использовано
22. Какие фазы включает процесс обновления в React Fiber?
	- Reconciliation (render фаза) - Прерываемая и инкрементальная
	- Commit фаза - Синхронная и непрерываемая
23. Чем отличаются фазы в Fiber и какую роль они играют в обновлении UI?
	- Reconciliation (render фаза) - отвечает за подготовку и планирование изменений
	- commit фаза - за их окончательное применение и взаимодействие с DOM
24. Что происходит в React в фазе Render (reconciliation)?
	- Создаётся новое дерево work-in-progress на основе текущего
	- React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов
	- После обхода дерева React формирует полный список эффектов для commit-фазы
	- Фаза может быть прервана и возобновлена, чтобы избежать блокировки основного потока
25. Что происходит в React в фазе Commit?
	- Фаза размонтирования эффектов
		- Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		- Очистка эффектов выполняется строго в порядке "снизу-вверх" (children → parent), чтобы избежать утечек или несогласованного состояния
	- Mutation этап
		- React применяет изменения в DOM: удаление, вставка, обновление
	- Выполняются функции `useLayoutEffect`
	- Выполняются функции `useEffect`
	- Commit-фаза не прерывается, чтобы гарантировать консистентность DOM
26. Что такое Effect List в React Fiber и для чего он используется?
	- Ранее Effect List — однонаправленный связанный список узлов Fiber с помеченными изменениями для commit-фазы (поля firstEffect, nextEffect, lastEffect)
	- В React 18/19 явный Effect List больше не используется
	- Теперь React помечает изменения через flags и subtreeFlags в каждом FiberNode
	- Во время commit-фазы React делает DFS обход дерева и выполняет эффекты только у узлов с помеченными флагами
	- Такой подход поддерживает concurrent rendering, прерываемый render и снижает накладные расходы
27. Как в React формируется и используется Effect List?
	- Во время render-фазы React помечает каждый FiberNode с изменениями через флаги (Placement, Update, Deletion, Passive и др.)
	- В commit-фазе React обходит дерево DFS и выполняет операции у узлов с установленными флагами
	- Effect List теперь implicit (через флаги), а не явный связанный список

#### 4. Priority System and Scheduling
28. Как работает система приоритетов в React Fiber и как она влияет на рендеринг?
	- Каждое обновление получает приоритет — через механизм Lanes
	- React сначала обрабатывает более приоритетные задачи (например, ввод), менее важные — откладывает
29. Что такое модель приоритетов Lane в React и как она работает?
	- Lane-модель — система приоритизации обновлений в React Fiber, где каждое обновление относится к одной или нескольким lanes — 32-битовым флагам разного приоритета
	- Один FiberNode может иметь несколько обновлений, каждое с разными lanes, и React объединяет их по приоритету
30. Какие типы (lanes) существуют (SyncLane, InputContinuousLane, DefaultLane и др.)?
	- SyncLane — максимальный приоритет, обновления должны выполниться сразу (например, flushSync)
	- InputContinuousLane — приоритет интерактивного ввода, чтобы UI был отзывчивым
	- DefaultLane — обычные фоновые обновления
31. Что такое Scheduler в React и за что он отвечает?
	- Это планировщик задач React, который решает, когда и с каким приоритетом запускать работу по обновлению UI. Он координирует выполнение render-фазы, позволяя прерывать низкоприоритетные задачи ради более важных
	- Scheduler учитывает, что один FiberNode может иметь несколько обновлений с разными lanes, и объединяет их по приоритету
32. Как Scheduler в React выбирает приоритет задач?
	- Scheduler использует lanes и сопоставляет их с уровнями приоритетов
	- Задачи с более высоким приоритетом прерывают текущие и запускаются раньше
33. Что делает flushSync и как он обходит приоритезацию?
	- flushSync — функция, которая запускает обновление синхронно, игнорируя систему приоритетов и асинхронность Scheduler. Она принудительно выполняет render и commit сразу, чтобы обновление UI произошло немедленно
34. Что такое конкурентный рендеринг (Concurrent Features) в React и чем он отличается от синхронного?
	- Concurrent Mode - новый способ работы React с рендерингом, при котором React не блокирует основной поток на долгое время, а разбивает работу на небольшие части (инкрементальный рендеринг)
	- Позволяет React приостанавливать, возобновлять и приоритезировать работу по обновлению интерфейса
	- Важно: не все функциональности React автоматически конкурентные — для использования concurrent возможностей нужно применять concurrent API, такие как startTransition, Suspense, и создавать приложение с concurrent root (например, через createRoot вместо ReactDOM.render)
35. Что такое time slicing в React и зачем он нужен?
	- механизм в React Fiber, который разбивает работу по рендерингу на небольшие части. React выполняет эти части по очереди, прерываясь по тайм-ауту, чтобы дать браузеру возможность обрабатывать пользовательские события и другие задачи
	- Time slicing реализуется за счёт итеративного обхода дерева Fiber с сохранением состояния, чтобы при возобновлении рендеринга продолжить с того места, где остановились
36. Как React прерывает и возобновляет рендеринг (time slicing)?
	- React разбивает работу рендера на небольшие задачи — единицы работы (units of work)
	- При достижении лимита времени текущая задача прерывается, текущее состояние обхода (nextUnitOfWork) сохраняется
	- В следующий момент React возобновляет обход с сохранённой позиции, позволяя браузеру обрабатывать важные события между этими фрагментами работы
37. Как React Suspense использует механизм прерывания рендера?
	- Suspense позволяет React прервать рендеринг компонента, если он «зависает» на асинхронной операции (например, загрузке данных или кода)
	- React отменяет текущую работу по рендеру, показывает fallback UI, а затем возобновляет рендеринг, когда асинхронная операция завершена

#### 5. Initial Render и Hydration
86. Что такое initial render в React?
	1. Initial render — первый рендер компонента или всего приложения. Это момент, когда компонент впервые попадает в дерево.
86. Чем отличается initial render от обычного render в React?
	1. Initial render монтирует компонент впервые: создаёт DOM, вставляет его, выполняет mount-эффекты.
	2. Обычный render происходит при изменении props или state: React пересчитывает JSX, сравнивает его с текущим деревом и вносит только нужные изменения в DOM.
86. Что такое hydration?
	- hydration — это процесс, при котором React подключает JavaScript-логику к уже существующему HTML, сгенерированному на сервере (SSR или React Server Components).
	- hydration = превращение "статичного HTML" в "живое React-приложение" без перерисовки DOM.
86. Чем hydration отличается от initial render  в React?
	1. initial render создаёт DOM с нуля, а hydration использует уже существующий HTML и лишь прикрепляет к нему реактовскую логику без пересоздания DOM
86. Как в React работает гидратация (hydration) после серверного рендеринга (SSR)?
	- Сервер рендерит HTML и отправляет готовую страницу.
	- Браузер сразу показывает HTML — пользователь видит контент до загрузки JS.
	- Когда JS-бандлы загрузились, React запускает гидратацию:
	    - создаёт Fiber-дерево, соответствующее существующему DOM
	    - сверяет свою ожидаемую структуру с HTML, отрендеренным сервером
	    - навешивает обработчики событий
	    - восстанавливает состояние и внутренние ссылки между Fiber-узлами
	- React не перерисовывает DOM, если всё совпадает. Он просто «подключается» к существующей разметке.
	- Если совпадение нарушено — возникает hydration mismatch и React может перерисовать узел.
86. Что такое hydration mismatch в React и почему он возникает?
	- Hydration mismatch в React — это ситуация, когда HTML, сгенерированный на сервере (SSR или RSC), не совпадает с тем, что React ожидает при гидратации на клиенте. Это возникает из-за использования в серверном рендере случайных значений,
86. Почему важно, чтобы SSR и клиентский рендер в React генерировали одинаковый DOM?
	- React при гидратации подключается к существующему серверному HTML и ожидает, что структура совпадёт. Если DOM не совпадает — происходит hydration mismatch, React показывает предупреждения и может перерисовать большие участки UI
86. Что происходит на клиенте при hydration mismatch в React?
	- React показывает предупреждения и иногда полностью перерисовывает участок DOM, чтобы синхронизировать клиентский и серверный деревья
86. Как избежать hydration mismatch в приложениях React с SSR?
	- Соблюдать одинаковую логику рендера на сервере и клиенте:
		- не использовать случайные значения (`Math.random()`, `Date.now()`)
		- избегать любых nondeterministic значений на сервере
		- `window`, `document` и любые browser-only API
		- условия, зависящие от client-only окружения, переносить в useEffect
		- Использовать `useEffect`, а не `useLayoutEffect` для client-only логики
86. Как `useLayoutEffect` может повлиять на hydration после SSR в React?
	- выполняется сразу после рендера на клиенте и может синхронно изменить DOM, создавая расхождения с серверным HTML
86. Что такое Streaming hydration и как он работает?
	1. Streaming hydration — это когда сервер отправляет HTML потоком (stream), а React гидратирует его по мере поступления.
	2. Как работает:
		1. React начинает SSR.
		2. Первые готовые куски HTML отправляются в браузер сразу.
		3. Браузер отображает частичный контент.
		4. React продолжает отправлять остальной HTML, включая части после `Suspense`.
		5. Когда JS готов, React гидратирует куски по мере их появления в DOM.
86. Что такое selective hydration в React?
	- Selective hydration — это подход, при котором React гидратирует не всё дерево сразу, а отдельные части, в зависимости от важности и приоритетов.
	- React запускает гидратацию узлов тогда, когда:
		- пользователь взаимодействует с элементом (клик, ввод, фокус)
		- компонент становится видимым во viewport
		- у узла высокий приоритет в планировщике (scheduler)
		- загрузился нужный JS-чанк
86. Что такое createRoot, hydrateRoot и legacy ReactDOM.render?
	1. `reateRoot` — создаёт корень для React 18+, поддерживает Concurrent Mode
	2. `hydrateRoot` — вариант для гидратации серверного HTML (SSR). Вместо создания нового DOM React подключается к уже существующему,
	3. `ReactDOM.render` — устаревший метод, не поддерживает Concurrent Mode и новые возможности React 18

#### 6. React Server Components
86. Что такое React Server Components и чем они отличаются от клиентских?
	- React Server Components - это компоненты, которые рендерятся  на сервере. Они не попадают в клиентский бандл, не запускают JavaScript в браузере и могут напрямую работать с серверными ресурсами
	- RSC не имеют состояния, эффектов, event listeners
	- Клиент получает серверный payload (RSC payload), а не HTML
	- Клиентское дерево собирается из RSC-пейлоада и клиентских компонентов
86. Как React Server Components уменьшают размер клиентского бандла?
	- Server Components не включаются в клиентский бандл JavaScript - они полностью рендерятся на сервере и передают клиенту уже готовый HTML
86. Что такое React Server Components payload?
	1. RSC payload - это сериализованные структурированные данные дерева серверных компонентов с их пропсами и состоянием, которые сервер отправляет клиенту. На клиенте этот payload используется React для построения виртуального дерева FiberNodes: серверные компоненты остаются серверными, а интерактивные клиентские компоненты подключаются поверх него.
86. Что означает директива `use client` в React и когда её использовать?
	1. `use client` — пометка в начале файла, делающая компонент клиентским: он попадает в бандл, рендерится в браузере и может использовать хуки, эффекты и DOM.
86. Что означает директива `use server` в React и когда её использовать?
	1. `use server` — пометка для функции, делающая её Server Action: вызовы сериализуются и выполняются только на сервере
86. Что такое серверные функции (Server Actions) в React и когда их использовать?
	- Серверные функции (Server Actions) в React — это функции, которые выполняются сервере, даже если они вызываются из клиентских компонентов. Они позволяют выполнять серверную логику без переноса этого кода на клиент и без отправки лишнего JavaScript.
86. Что такое cache в React и когда его использовать?
	- `cache` функция для Server Components, создающая мемоизированную версию асинхронной функции. Позволяет кэшировать результаты по аргументам, уменьшать количество вызовов для одинаковых данных и делиться snapshot-ами между компонентами. Используется для запросов к API, БД или тяжёлых вычислений.
86. Что такое cacheSignal в React Server Components и как его использовать?
	- cacheSignal возвращает AbortSignal, который позволяет отслеживать окончание жизни кэша, созданного через cache(). Его используют для отмены незавершённых асинхронных операций (например, fetch или работу с БД), если рендер компонента завершён, прерван или провален. В клиентских компонентах всегда возвращает null. Этот механизм помогает избегать ненужной работы и игнорировать ошибки, возникшие из-за отмены операции.
86. Что можно делать в  React Server Components, чего нельзя в клиентских?
	- Доступ к БД, файловой системе, секретам, серверным API, выполнение тяжёлых вычислений без отправки кода в браузер,  использовать серверные зависимости (например, fs, pg, bcrypt)
86. Что можно делать в клиентских компонентах React, чего нельзя в серверных?
	- использовать:
		- браузерные API, Хуки react, обработчики событий, манипулировать с DOM, храгнить состояния
86. Какие хуки доступны в React Server Components?
		1. `useId` - Генерация стабильных ID
86. Что такое Streaming SSR в React и как он работает?
	- Streaming SSR — это возможность React отдавать HTML по мере готовности дерева пока React рендерит все по частям
	- Работает через `renderToPipeableStream` (Node.js) или `renderToReadableStream` (Edge/Cloud)
	- Streaming SSR + Suspense позволяют отдавать HTML чанками и показывать fallback-и, пока части дерева ещё не готовы
86. Как SSR в React помогает уменьшить Time to First Byte (TTFB)?
	- SSR позволяет серверу сразу отправить полностью сформированный HTML, благодаря чему браузер начинает отображать контент сразу после получения первого байта без задержек на загрузку и выполнение JS
86. Как в React избежать отправки лишнего JavaScript на клиент?
	- Использовать Server Components, которые рендерятся только на сервере и не попадают в клиентский бандл
	- Применять `use client` директиву строго там, где нужна интерактивность
	- Делать код-сплиттинг и динамический импорт для загрузки JS только при необходимости
	- Минимизировать зависимости и не импортировать клиентские библиотеки в серверные компоненты
	- Использовать selective hydration, чтобы загружать JS по частям и с приоритетом

#### 7. Suspense и асинхронные паттерны
86. Как работает Suspense для данных в React?
	- Suspense приостанавливает рендер компонента, если данные ещё не готовы, бросая Promise. Пока Promise не разрешён, React отображает fallback UI. После завершения асинхронной операции рендер возобновляется с готовыми данными.
86. Как работают Suspense и ленивая загрузка серверных данных и компонентов в React/Next.js?
	- Серверные компоненты (RSC) могут быть асинхронными и использовать `await` прямо внутри тела компонента.
	- React при рендере ждёт завершения промисов, но при необходимости может показывать запасной UI (fallback) через `<Suspense>`, обеспечивая ленивую загрузку
	- Клиент получает чанки RSC payload через Streaming, что позволяет постепенно строить виртуальное дерево.
	- По мере готовности данных React «дозаписывает» оставшийся HTML на клиенте или сервере (Streaming SSR), ускоряя первую отрисовку
	- Suspense на сервере позволяет отдавать готовый HTML частями: сначала fallback, затем реальный UI
	- Suspense на клиенте управляет состояниями загрузки: сначала показывается fallback, а после завершения промисов отображается готовый компонент
86. Как работают `React.lazy` и Suspense для динамического импорта компонентов?
	- `React.lazy` динамически импортирует компонент (через `import()`), возвращая промис
	- Пока компонент загружается — Suspense показывает fallback UI
	- После загрузки компонент рендерится как обычно
86. Что дает использование `React.lazy`?
	1. Использование `React.lazy` позволяет динамически загружать компонент только тогда, когда он реально нужен, а не включать его сразу в основной бандл
	2. компонент попадает в отдельный чанковый файл
	3. Снижение размера начального JavaScript
	4. можно показывать fallback UI, пока компонент загружается.
86. Какие варианты fallback UI поддерживает React Suspense и как работает вложенность?
	- Fallback — любой React-элемент, показываемый во время загрузки
	- Вложенные Suspense показывают самый близкий fallback для загрузки в своей области
86. Как ведёт себя React при вложенных Suspense и цепочках fallback (suspense cascade)?
	- При вложенных Suspense, React строит цепочку fallback'ов: если inner Suspense переходит в состояние ожидания (suspend), React показывает его fallback
	- Если fallback-контент тоже вызывает suspend (например, ленивый компонент или async server компонент), React поднимается к ближайшему родительскому Suspense выше по компонентному дереву (не по DOM) и рендерит уже его fallback. Этот процесс продолжается вверх, пока не найдётся fallback, который можно отрендерить синхронно
	- Это называется suspense cascade — поведение предсказуемо, и важно, что цепочка строится по дереву компонентов, а не по DOM
86. Что такое `use()` в React и для чего оно нужно?
	- `use()` - это React API для чтения значения ресурса (Promise, контекст или серверный ресурс) прямо в теле компонента. Оно интегрируется с Suspense, позволяя приостанавливать рендер до готовности данных.
86. Как работает `use()` с Promise и контекстом в React?
	- Promise: приостанавливает рендер до его разрешения; пока Promise не завершён, показывается fallback через Suspense; при ошибке срабатывает ближайший Error Boundary.
	- Контекст: возвращает текущее значение, аналогично `useContext`, но может использоваться внутри условных операторов и циклов.х
86. Где доступен `use()` в React (SSR или CSR) и когда его применять?
	- Работает как на сервере (SSR, RSC), так и на клиенте (CSR), чаще используется для чтения ресурсов и асинхронных данных внутри Client Components
86. Как хук `use()` взаимодействует с Fiber?
	- Интегрируется с механизмом Suspense в Fiber: при ожидании Promise рендер компонента приостанавливается, Fiber переключается на fallback, а после завершения Promise рендер возобновляется с готовыми данными
86. Как использовать `use()` для чтения контекста вместо `useContext`?
	- `use()` позволяет читать значение контекста так же, как `useContext`, но с преимуществом: можно использовать внутри условных блоков и циклов, что невозможно с обычным `useContext`
86. Почему нельзя просто await в Client Components вместо `use()`?
	- `await` в теле обычного функционального компонента блокирует поток. `use()` позволяет React управлять ожиданием асинхронного результата в рамках Fiber и Suspense без блокировки рендера.
86. Как обрабатывать ошибки загрузки при React.lazy?
	1. Использовать Error Boundary вокруг `React.lazy` компонента

#### 8. Performance Optimization
86. Как React избегает лишних ререндеров?
	- Virtual DOM и сравнение (reconciliation)
	- Мемоизация с `React.memo`
	- Хуки `useMemo` и `useCallback`
	- Контроль ключей (key) в списках
86. Как работает batching обновлений состояния в React?
	- это механизм объединения нескольких обновлений состояния (state updates) в один цикл рендера
	- внутри обработчика вызывается несколько setState или обновлений, React объединяет (batch) их и выполняет один рендер после завершения обработчика
86. Как Automatic Batching  работает с промисами и таймерами?
	- В React  Automatic Batching работает со всеми асинхронными операциями. Когда несколько setState вызываются внутри промиса или setTimeout, React автоматически объединяет их в один рендер, что значительно улучшает производительность
86. Как `flushSync` обходит Automatic Batching?
	- `flushSync` принудительно выполняет обновление синхронно, игнорируя Automatic Batching. Это полезно когда нужно немедленно применить изменения, например, для измерений DOM или интеграции с внешними библиотеками
86. Как Fiber улучшает отзывчивость UI (например, при анимациях)?
	- Приоритизация обновлений
	- Прерываемость рендера
	- благодаря time slicing и прерывистому рендеру, браузер может своевременно обновлять кадры анимаций и избегать "фризов"
86. Что такое `memo` в React и зачем он нужен?  
	- `memo` позволяет пропускать повторный рендер функционального компонента, если его пропсы не изменились. Используется для оптимизации производительности при частых рендерах родителя, особенно для тяжёлых компонентов.
86. Как `React.memo` сравнивает пропсы по умолчанию и какие ограничения есть?
	- Используется shallow comparison через `Object.is`.
	- Ограничения: объекты, массивы и функции сравниваются по ссылке, изменения контекста игнорируются, глубокое сравнение не выполняется.
86. Когда и как применять пользовательский `arePropsEqual`?
	- Когда пропсы — это объекты, массивы или функции, которые нельзя сравнить по ссылке.
	- Функция должна возвращать `true` только если новый набор пропсов полностью эквивалентен старому.
86. Какие анти‑паттерны при использовании `React.memo`?
	- Мемоизация простых компонентов, где ререндер не затратный.    
	- Глубокое сравнение пропсов в `arePropsEqual`, которое дороже рендера.
	- Передача новых объектов/функций без `useMemo`/`useCallback`.
86. Что такое React Compiler?
	- React Compiler — это инструмент, который автоматически оптимизирует React код во время компиляции. Он анализирует код и применяет оптимизации, которые раньше требовали ручного написания `useMemo`, `useCallback` и других оптимизаций
86. Как React Compiler оптимизирует код?
	- React Compiler автоматически мемоизирует компоненты и функции, удаляет ненужные ререндеры, оптимизирует пропсы и состояния. Он делает это на уровне компиляции, что более эффективно чем ручные оптимизации

## 9. Component Patterns and State Management
86. Как реализуется однонаправленный поток данных в React?
	- Однонаправленный поток данных в React означает, что данные всегда идут сверху вниз — от родительских компонентов к дочерним через props
	- Родитель хранит состояние и передаёт его дочерним, которые могут только читать эти props, но не менять их напрямую. Изменения состояния происходят в родителе через коллбэки, переданные вниз
87. Что такое "lifting state up" и как его правильно использовать?
	- это когда состояние, нужное нескольким компонентам, поднимается к их ближайшему общему родителю. Вместо того чтобы каждый компонент держал своё локальное состояние и пытался синхронизировать его, состояние централизуется в одном компоненте-родителе, а дочерним передаются через props и коллбэки для изменения
88. В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?
	- Контролируемые компоненты — это компоненты, где состояние формы полностью управляется React через state и обновляется через обработчики (`onChange`). Значение поля всегда берётся из состояния, а не из DOM
	- Неконтролируемые компоненты — это компоненты, где состояние формы хранится непосредственно в DOM, а React лишь получает доступ через ref. React не управляет значением, а читает его при необходимости
	- Контролируемые компоненты позволяют сразу валидировать, управлять вводом, делать условный рендер элементов формы
	- 
89. Как правильно реализовать контролируемые и неконтролируемые компоненты форм?
	- Контролируемые компоненты: значение хранится в состоянии (`useState`), обновляется через `onChange`. React полностью управляет вводом
	- Неконтролируемые компоненты: значение хранится в DOM, доступ через ref. React не управляет вводом напрямую
90. Как в React обрабатывать события `onChange` и `onSubmit` в формах?
	- `onChange`: обновляет состояние для контролируемых компонентов
	- `onSubmit`: отменяет стандартное поведение и обрабатывает данные из состояния или ref
91. Как сделать простую валидацию без сторонних библиотек?
	- выполняется прямо в обработчике `onSubmit` или `onChange` — проверяем значения на нужные условия с сохранением ошибок в состоянии
	- HTML-атрибуты валидации `required`, `minLength`, `pattern`
92. Как получить доступ к React Context без хуков?
	- через компонент `<MyContext.Consumer>`. В него передают функцию, которая получает текущее значение контекста
93. Какие проблемы с производительностью возникают при частых обновлениях контекста?
	- При изменении значения в провайдере все дочерние компоненты использующие контекст перерендериваются, даже если используют лишь часть данных или не затронуты логикой
94. Что такое `dangerouslySetInnerHTML` и когда его используют?
	1. Способ вставки сырого HTML в компонент React.
	2. Требует осторожности, так как может привести к XSS-уязвимостям
95. В чём разница между `onInput` и `onChange` в React?
	- `onInput` срабатывает на каждое изменение значения в поле ввода, отражая изменения мгновенно; это обёртка нативного события браузера.
	- `onChange` в React — синтетическое событие, которое имитирует нативный `change`, но для `<input>` и `<textarea>` срабатывает на каждое изменение значения, а не только при потере фокуса, как в нативном `change`.
	- Используйте `onInput`, когда нужен максимально ранний отклик на пользовательский ввод, например:
	    - автокомплит при вводе символа
	    - динамическая валидация по мере набора текста
	    - мгновенное обновление состояния визуальных индикаторов

## 10. Events и Synthetic Events
96. Как работает система SyntheticEvent в React?
	- SyntheticEvent — это обёртка над нативными событиями браузера, создаваемая React для обеспечения кроссбраузерного и единообразного API при работе с событиями. Позволяет использовать одинаковые свойства и методы во всех браузерах.
97. В чём основные отличия между Synthetic Events и нативными событиями браузера?
		- Кроссбраузерность: единый интерфейс для всех браузеров; нативные события могут различаться по свойствам и поведению
		- Всплытие: события React всплывают по иерархии компонентов, а не по DOM; нативные события всплывают по DOM-дереву.
		- Совместимость с React Concurrent Mode: SyntheticEvent учитывает приоритеты событий в concurrent режиме, нативные — нет.
98. Как ведут себя stopPropagation и preventDefault в системе SyntheticEvent по сравнению с нативными событиями?
	1. `stopPropagation()` останавливает всплытие по React-иерархии компонентов, независимо от DOM.
	2. `preventDefault()` отменяет стандартное поведение элемента так же, как в нативном событии
99. Что такое replay события и какие проблемы могут возникать при их повторном воспроизведении?
	1. Replay — попытка повторно использовать объект SyntheticEvent после его обработки
	2. Проблема: SyntheticEvent реализован через пул событий, и после обработчика объект очищается для повторного использования.
	3. Если попытаться обратиться к свойствам события асинхронно без `event.persist()`, данные будут потеряны.
100. Что такое `event.persist()` в React и когда его использовать?
	- Отключает механизм пуллинга для конкретного SyntheticEvent, позволяя сохранять объект события для асинхронного использования.
	- Применяется, если нужно использовать свойства события в `setTimeout`, промисах или других асинхронных коллбэках.
101. Что такое пул событий (event pooling) в React и зачем он нужен?
	- Event Pooling — механизм повторного использования объектов SyntheticEvent для снижения нагрузки на сборщик мусора и уменьшения аллокаций.
	- После завершения обработчика все свойства события сбрасываются.
	- Для асинхронной работы с событием необходимо вызвать `event.persist()`.

#### 11. React Features и APIs
101. Что такое Error Boundary в React и какие ошибки он перехватывает?
	1. Error Boundary - это компонент-класс с методами `static getDerivedStateFromError()` и `componentDidCatch()`, который перехватывает ошибки во время рендера, в методах жизненного цикла и в конструкторах дочерних компонентов.
102. Что делает метод `static getDerivedStateFromError(error)` в Error Boundary и когда он вызывается?
	1. Статический метод, вызывается во время рендера, когда дочерний компонент бросает ошибку.
	2. Позволяет обновить состояние Error Boundary для отображения fallback UI.
103. Что делает метод `componentDidCatch(error, info)` в Error Boundary и для чего он используется?
	1. Вызывается после того, как ошибка произошла в дочернем компоненте.
	2. Используется для логирования ошибок, отправки их на сервер или выполнения других побочных эффектов.
104. Как и зачем применять `React.Fragment`?
	- Позволяет сгруппировать несколько элементов без добавления лишнего DOM-узла
105. Когда и как правильно использовать порталы в React?
	- Используйте порталы, когда UI-элемент должен визуально выходить за пределы текущей иерархии DOM — например, модальные окна, тултипы, всплывающие меню, уведомления
106. Как работает `ReactDOM.createPortal` и как он участвует в Fiber-дереве?
	- `ReactDOM.createPortal` рендерит элемент в другой DOM-узел, но оставляет его частью того же Fiber-дерева. Компонент внутри портала получает контексты, участвует в рендеринге, Suspense, ErrorBoundary и сохраняет порядок событий
107. Какие аргументы принимает `ReactDOM.createPortal`?
	- `children` — React-элементы, которые нужно отрендерить (JSX, компоненты, строки, фрагменты и т.п.)
	- `domNode` — DOM-узел, куда будет помещён этот контент. Этот узел должен уже существовать в DOM
	- `key` (опционально) — уникальный ключ (строка или число) для идентификации портала, особенно при рендере списков порталов
108. Какие особенности управления событиями и фокусом возникают при работе с порталами?
	- События всплывают по React-дереву, а не по DOM — обработчики работают как обычно, несмотря на другой DOM-узел
	- Фокусом нужно управлять вручную: при открытии модалки ставить фокус в портал, при закрытии — возвращать на исходный элемент
109. Как ведёт себя React Strict Mode в режиме разработки и зачем он нужен?
	- В Strict Mode компоненты и хуки специально монтируются, размонтируются и монтируются заново в режиме разработки. Это имитация двойного вызова жизненных циклов для выявления побочных эффектов
110. Как включить React Strict Mode в приложении?
	- обернуть компонент в `<React.StrictMode>
111. Как JSX трансформируется в вызовы `React.createElement`?
	- JSX — это синтаксический сахар, который во время сборки транспилируется в вызовы `React.createElement`
112. Что такое `<Activity>` в React и зачем он нужен?
	- `<Activity>` позволяет скрывать и восстанавливать UI и внутреннее состояние дочерних компонентов без их полного размонтирования.
	- Используется для сохранения состояния скрытых элементов, ускорения загрузки и предварительного рендеринга компонентов.
113. Как `<Activity>` помогает ускорить взаимодействие и предварительно рендерить компоненты?
	- Скрытые Activity-компоненты рендерятся с низким приоритетом и подготавливаются к будущему отображению.
	- Разделяет дерево компонентов на независимые блоки, позволяя React сначала гидратировать видимые элементы.
	- Позволяет заранее загружать код и данные компонентов, чтобы они отображались быстрее при показе.
114. Как работать с эффектами скрытых компонентов и какие есть ограничения?
	1. Эффекты скрытых компонентов размонтируются, чтобы избежать побочных эффектов.
	2. Для компонентов с побочными действиями нужно использовать `useEffect` с очисткой:
	3. Ограничения: компоненты, возвращающие только текст, не создают DOM; внутри `ViewTransition` скрытие/показ активирует анимации; предрендерируются только Suspense-совместимые источники данных; эффекты внутри `useEffect` не выполняются при скрытии.
115. Как  `<Activity>` отличается от условного рендеринга?
	1. Conditional Rendering (`{isVisible && <Component />}`) полностью размонтирует компонент → состояние и DOM теряются.
	2. `<Activity>` сохраняет DOM и состояние скрытого компонента, размонтирует только эффекты и восстанавливает их при показе.
116. Для чего используется React.Children.map и чем он отличается от обычного map массива?
	1. Применяет функцию к каждому дочернему элементу `props.children`, корректно обрабатывая одиночные элементы, `null` и фрагменты.
	2. В отличие от обычного массива, `props.children` может быть не массивом, поэтому `React.Children.map` безопасно обрабатывает любые children
117. Как работает React.Children.forEach и когда его удобнее использовать вместо map?
	1. Перебирает все дочерние элементы и выполняет функцию для каждого, но возвращает `undefined`
	2. Используется, когда не нужен результат перебора, а важно просто пройтись по детям
118. Что делает React.Children.toArray и зачем преобразовывать children в массив?
	1. Преобразует `props.children` в массив React-элементов.
	2. Удобно для безопасного перебора, сортировки, фильтрации и добавления ключей
119. Когда нужно использовать React.Children.only и что произойдёт, если передано больше одного элемента?
	1. Гарантирует, что `props.children` содержит ровно один React-элемент
	2. Если передано 0 или более 1 элемента — выбросится ошибка.
120. Для чего служит React.Children.count и как это помогает при работе с детьми?
	1. Возвращает количество дочерних элементов, учитывая, что `props.children` может быть одиночным элементом, массивом, `null` или `undefined`.
	2. Помогает корректно оценивать число детей без ручной проверки типов.
121. Как применять React.cloneElement и зачем клонировать React-элемент?
	1. Создаёт копию существующего React-элемента с новыми props и/или дочерними элементами.
	2. Используется для передачи дополнительных props потомкам без изменения оригинального элемента.
122. Что проверяет React.isValidElement и зачем нужна эта проверка?
	1. Проверяет, является ли объект React-элементом.
	2. Полезно перед операциями вроде клонирования или рендера, чтобы избежать ошибок с обычными объектами или строками.
123. Для чего используется React.isValidElementType и чем она отличается от isValidElement?
	1. `isValidElementType` проверяет, можно ли переданный объект использовать в JSX
	2. В отличие от `isValidElement`, которая проверяет уже созданный элемент, `isValidElementType` проверяет тип перед созданием элемента


---
## Hooks

108. Какие правила использования хуков React нужно соблюдать?
	- Вызывайте их на верхнем уровне в теле компонента функции
	- Вызывайте их на верхнем уровне в теле пользовательского хука
	- Не вызывайте хуки внутри условий или циклов
	- Не называйте хуки после условного return оператора
	- Не вызывайте хуки в обработчиках событий
	- Не вызывайте хуки в компонентах класса
	- Не вызывайте хуки внутри функций, переданных в `useMemo`, `useReducer`, или `useEffect`

### useState
109. Для чего нужен `useState` и как обновить его значение??
	- Чтобы создать локальное состояние в функциональном компоненте
	-  Вызов `setState(newValue)` или `setState(prev => computeNext(prev))`

110. Почему setState асинхронен, и как это влияет на обновления?
	- batching группирует обновления, чтобы не делать лишнюю работу. Поэтому state не обновляется сразу после вызова setState

111. Что произойдет, если вызвать setState с тем же значением?
	- React использует `Object.is` для сравнения. Если значение не изменилось — ререндер не произойдёт

112. В чем отличие `useState` от `useReducer`?
	- `useState` — для простого состояния. `useReducer` — для сложной логики и вложенных структур. `useReducer` даёт больше контроля и лучше масштабируется

113. Как сделать ленивую инициализацию состояния в `useState`?
	- `useState(() => computeExpensiveInitial())`

114. В чем разница между `useState(someFunction())`, `useState(someFunction)`, `useState(() => someFunction())`?
	- `someFn()` — вызов сразу, значение — результат
	- `someFn` — функция как значение, не вызовется
	- `() => someFn()` — ленивый вызов, только при первом рендере

115. Как избежать stale-значений при обновлении состояния в async-колбэках или таймерах?
	- Использовать функциональный `setState(prev => ...)`
---

### useEffect и useLayoutEffect

86. В чём разница между `useLayoutEffect` и `useEffect` с точки зрения Fiber?
	- `useLayoutEffect` — синхронный, блокирующий эффект, полезен для измерений DOM и синхронных манипуляций. выполняется в phase commit, после того, как React применил изменения к DOM, но до того, как браузер обновил экран
	- `useEffect` — асинхронный, неблокирующий, выполняется после отрисовки, оптимален для сетевых запросов, подписок и не критичных к времени операций. выполняется после фазы commit и после того, как браузер отрисовал обновлённый UI

86. Для чего нужен `useEffect` и когда он вызывается?
	1. useEffect используется для выполнения побочных эффектов выходящих за рамки чистого рендера
	2. Он вызывается после рендера и commit-фазы, асинхронно, уже после того как браузер обновил экран.

86. Для чего нужен `useLayoutEffect` и когда он вызывается?
	- useLayoutEffect используется для синхронных побочных эффектов, которые должны быть выполнены до того, как браузер отрисует изменения (измерение DOM, синхронные изменения размеров и позиций).
    - Вызывается в commit-фазе: после обновления DOM, но до обновления экрана браузером.

86. Какие параметры принимает useEffect и useLayoutEffect?
	- `callback: () => void` — основная функция с эффектом
	- `deps: any[]` — массив зависимостей (опционально)

86. Как работает массив зависимостей у useEffect и useLayoutEffect?
	- React сравнивает зависимости (по `Object.is`). Эффект выполняется только если хотя бы одна зависимость изменилась. Если массив пустой — выполнится один раз при монтировании

86. Какие варианты массива зависимостей используются в `useEffect` и `useLayoutEffect`?
	1. `undefined` → вызывается после каждого рендера.
	2. `[]` → вызывается один раз при монтировании.
	3. `[deps...]` → вызывается при изменении зависимостей.

86. Как использовать `useEffect` и `useLayoutEffect` с асинхронными функциями?
	- Нельзя сделать сам `useEffect` async, но можно в callback создать асинхронную функцию и вызвать ее

86. Что такое функция очистки (cleanup) в `useEffect` и `useLayoutEffect` и когда она вызывается?
	- Это функция, которую может возвращать callback. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента
	- Используется для отмены подписок, таймеров, abort-controllers и т.п.

86. Чем `useEffect` отличается от `useLayoutEffect`?
	- `useEffect`: вызывается асинхронно, после рендера и отрисовки
	- `useLayoutEffect`: вызывается синхронно, до отрисовки браузером и может блокировать отрисовку

86. Как избежать гонки состояний (race conditions) в асинхронных useEffect и useLayoutEffect?
	- Используй `AbortController`, флаги `isMounted

86. Как правильно использовать useEffect и useLayoutEffect с подписками на внешние источники (WebSocket, Observer, EventListener)?
	- Создай подписку в `useEffect`
	- Вернуть функцию очистки, чтобы отписаться при размонтировании или повторном вызове

86. Что произойдёт, если не использовать функцию очистки при подписке в useEffect и useLayoutEffect?
	- Повторные подписки → дублирование событий
	- неактуальные колбэки
	- Утечка ресурсов

86. Чем отличается порядок выполнения нескольких `useEffect и useLayoutEffect` в одном компоненте?
	- Оба типа эффектов выполняются в порядке объявления в компоненте - сверху вниз.
	- Сначала выполняются все useLayoutEffect, затем все useEffect.
	- Порядок важен, если эффекты логически зависят друг от друга.

86. Как влияет Strict Mode на вызовы `useEffect` и `useLayoutEffect`?
	- `useEffect` вызывается дважды (монтирование → размонтирование → повторное монтирование) чтобы поймать ошибки в нечистых эффектов, например, без cleanup

---
### useRef

149. Для чего нужен `useRef`?
	- Чтобы храненить значения между рендерами без триггера перерисовки

150. Какие варианты использования `useRef` в React?
	- Доступ к DOM
	- Хранение значения между рендерами
	- Предыдущее значение
	- Флаг "монтирован"
	- Таймеры, id, внешние инстансы
	- Хранение функций, чтобы избежать их пересоздания на каждом рендере (например, обработчики событий)

151. Как получить доступ к DOM-элементу с помощью `useRef`?
	- Прокинуть в атрибут ref html тега переменную которой присвоили `useRef()`

152. Как получить и изменить значение `useRef`?
	- Текущее значение доступно по `ref.current`.
	- Изменяется напрямую `ref.current = newValue`.

153. Чем `useRef` отличается от `useState`?
	- `useRef` не вызывает ререндер при изменении
	- `useState` - триггерит ререндер

 154. Как связать `useRef` родителя с дочерним компонентом?
	- В старых версиях React для проброса `ref` к DOM использовался `forwardRef`.  
	- В React 18+ прямой `ref` можно передавать к дочернему компоненту, если он возвращает один DOM-элемент, иначе `forwardRef` все еще нужен
---
### useMemo и useCallback

161. Что такое хук `useMemo` и для чего он используется?
	- `useMemo` — хук, который мемоизирует результат вычисления между рендерами.  
	- Позволяет не пересчитывать значение заново, если зависимости не изменились.

162. Что такое хук `useCallback` и для чего он используется?
	- `useCallback` — хук, который мемоизирует функцию, чтобы её ссылка оставалась стабильной между рендерами, если зависимости не изменились.

163. Какие аргументы принимает `useMemo` и что он возвращает?
	- Функция, которая возвращает значение.  
	- Массив зависимостей (deps) — значения, при изменении которых результат пересчитывается.  
	- Возвращает мемоизированное значение — результат выполнения функции, если зависимости не изменились.

164. Какие аргументы принимает `useCallback` и что он возвращает?
	- Колбэк-функция — возвращается как есть, не вызывается.  
	- Массив зависимостей (deps) — значения, при изменении которых функция пересоздаётся.  
	- Возвращает мемоизированную функцию.  
	- Ссылка на функцию остаётся стабильной до изменения зависимостей.

165. Когда стоит использовать `useMemo` и когда это может навредить?
	- Полезно, когда:  
		- Вычисления дорогие и требуют оптимизации.  
		- Нужно передать стабильную ссылку в зависимости других хуков или мемоизированных компонентов.  
		- Необходимо оптимизировать рендеры дочерних компонентов, зависящих от неизменных значений.  
	- Может навредить, когда:  
		- Вычисления дешёвые и быстрые.  
		- Зависимости часто меняются, и значение почти всегда пересчитывается.  
		- Преждевременная мемоизация большого числа значений — лишняя нагрузка на память и CPU.  
		- Нет проблем с производительностью — мемоизация не нужна.

166. Когда стоит использовать `useCallback` и в каких случаях это не даёт выигрыша?
	- Полезно, когда:  
		  - Функция передаётся в мемоизированные (`React.memo`) компоненты, чтобы избежать лишнего рендера.  
		  - Функция участвует в зависимостях других хуков (`useEffect`, `useMemo`, `setInterval`) и нужна стабильная ссылка.  
		  - Необходимо оптимизировать компоненты, зависящие от неизменных колбэков.  
	- Неэффективно, когда:  
		  - Компонент не зависит от стабильности функции.  
		  - Функция пересоздаётся из-за нестабильных зависимостей.  
		  - Рендеры дешёвые, и лишняя мемоизация усложняет код.

167. Когда стоит предпочесть `useCallback` обычной функции в компоненте?
	- Когда функция передаётся вниз (в props) и нужно избежать лишнего рендера дочернего `React.memo` компонента.  
	- Когда функция участвует в зависимостях эффекта, и нужна стабильная ссылка.

168. Как устроена мемоизация в `useMemo` и `useCallback` под капотом?
	- React хранит мемоизированное значение или функцию внутри структуры Fiber для конкретного компонента.  
	- При следующем рендере сравниваются зависимости через `Object.is`.  
	- Если хотя бы одна зависимость изменилась, функция/значение пересоздаётся, старое заменяется новым.  
	- Если зависимости не изменились, возвращается то же значение или ссылка.

169. Что произойдёт, если не указать массив зависимостей в `useMemo` или `useCallback`?
	- Функция будет выполняться при каждом рендере компонента.

170. Как `useMemo` и `useCallback` сравнивают зависимости: по ссылке или по значению?
	- По ссылке, с помощью `Object.is()`.

171. Как `useMemo` и `useCallback` ведут себя в Concurrent Mode?
	- Результат мемоизации сохраняется только после коммита.  
	- Если рендер прерывается, кэш не сохраняется, и функция или значение могут быть пересозданы при следующем рендере.

172. Чем `useMemo` отличается от мемоизации вне React (например, `lodash.memoize`)?
	- `useMemo` встроен в цикл рендеринга React и зависит от зависимостей и жизненного цикла компонента. Кэш сбрасывается при размонтировании.  
	- `lodash.memoize` — императивная мемоизация, работающая вне React, сохраняющая кэш глобально или локально, без учёта ререндеров и жизненного цикла.

173. Можно ли заменить `useCallback` с помощью `useMemo` для функции? Почему это не рекомендуется?
	- Да, можно: `useMemo(() => fn, [deps])`.  
	- Не рекомендуется из-за снижения читаемости и неочевидности намерения мемоизации функции.

174. Чем отличается `useCallback` от `useMemo`?
	- useCallback: мемоизирует функцию и возвращает саму функцию.  
	- useMemo: мемоизирует значение и возвращает результат вызова функции.

175. Как `useMemo` и `useCallback` влияют на использование памяти и работу сборщика мусора?
	- Кэш хранится до размонтирования компонента или изменения зависимостей.  
	- Частое или ненужное использование увеличивает потребление памяти и нагрузку на CPU из-за отслеживания зависимостей.

---

### useId

189. Для чего используется хук `useId` и какие задачи он решает?
	- Генерирует уникальный и стабильный ID, синхронизированный между сервером и клиентом.  
	- Используется для привязки `label ↔ input`, `aria-describedby` и других accessibility-атрибутов в компонентах, рендерящихся на сервере и клиенте.

190. Как работает `useId` и почему его ID остаются стабильными между рендерами?
	- React создаёт уникальный префикс для ID один раз и сохраняет его в структуре Fiber.  
	- Этот префикс не меняется при последующих рендерах компонента, обеспечивая стабильность.

192. Можно ли использовать `useId` в серверных компонентах React (RSC)?
	- Да, `useId` безопасен для Server Components.  
	- Обеспечивает одинаковые ID на сервере и клиенте, предотвращая mismatch при гидратации.

193. Как `useId` помогает при серверном рендеринге (SSR) избежать mismatch?
	- Генерирует одинаковые ID на сервере и клиенте, в отличие от `Math.random()` или uuid.  
	- React контролирует генерацию и встраивает метаданные в HTML, обеспечивая корректную гидратацию.

194. Чем `useId` отличается от генерации ID через `Math.random()` или сторонние библиотеки?
	- Стабильность между рендерами.  
	- Работает при SSR-гидратации.  
	- Безопасен для accessibility (label ↔ input, aria-атрибуты).

195. Можно ли использовать `useId` для ключей (`key`) в списках React?
	- Нет. Ключи должны быть детерминированы по данным, иначе React будет пере-монтировать элементы при изменении порядка или количества.
---


### useContext

201. Для чего нужен хук `useContext` и какой есть аналоги получения контекст?
	- Позволяет получать текущее значение контекста.  
	- Аналоги `<Context.Consumer>`(deprecated) или `use(resource)`

202. Как `useContext` работает при обновлении значения в провайдере?
	- React сравнивает по `Object.is` Если значение контекст меняется, все потомки, использующие `useContext`, перерисуются

203. Как избежать лишних рендеров при использовании `useContext`?
	- Мемоизировать value
	- Разделить контексты: один для данных, другой для диспатча (Pattern: StateContext + DispatchContext)
	- Вынести `useContext` ближе к месту, где нужен

204. Какие ограничения и подводные камни есть у `useContext`?
	- Все потребители перерисовываются при любом изменении `value`.  
	- Плохая производительность при больших объектах в `value`.  
	- Нельзя вызывать вне компонента или хука.  
	- Мутирование объекта в `value` не вызовет ререндер, т.к. сравнение происходит по ссылке (`Object.is`).

205. Как работает обновление контекста при вложенных провайдерах с одинаковым типом?
	- Если компонент обернут во вложенные `<Context.Provider>` одного и того же контекста, то `useContext(Context)` всегда читает ближайший вверх по дереву Provider
---

### useReducer

201. Что такое `useReducer` и для чего он нужен?
	- Хук для управления сложным или предсказуемым состоянием в функциональных компонентах.
	- Позволяет масштабировать логику изменения состояния через редьюсер вместо прямого присвоения (`useState`).

202. Чем `useReducer` отличается от `useState`?
	- `useState` → императивное обновление состояния (`setState(newValue)`).
	- `useReducer` → декларативное управление: вызываешь `dispatch(action)`, а редьюсер решает, как изменится состояние.
	- Легче масштабируется при сложных структурах состояния.

203. Как устроена редьюсер-функция?
	- Чистая функция `(state, action) => newState`.
		- `state` — текущее состояние.
		- `action` — объект или любое значение, описывающее событие.
	- Возвращает новое состояние, не мутируя предыдущее.

204. Что возвращает `useReducer`?
	- Массив `[state, dispatch]`:
		- `state` — текущее состояние.
		- `dispatch` — функция для отправки действий в редьюсер.

205. Какие параметры принимает `useReducer` и как задать начальное состояние?
	- `reducer` — функция редьюсера.
	- `initialArg` — начальное состояние.
	- `init` (опционально) — функция для ленивой инициализации: `init(initialArg)` возвращает начальное состояние.

206. Как работает `dispatch` и можно ли использовать асинхронно?
	- `dispatch(action)` ставит обновление в очередь, React выполняет ререндер асинхронно (с учётом батчинга).
	- `dispatch` сам синхронен, но можно вызывать из `useEffect`, `setTimeout` или async-функций.

207. Как использовать `useReducer` для глобального состояния с `useContext`?
	- Создаём контекст: `const Context = createContext()`.
	- Передаём `[state, dispatch]` через `<Context.Provider>`.
	- В любом компоненте: `const [state, dispatch] = useContext(Context)`.

208. Почему редьюсер должен быть чистой функцией?
	- Редьюсер должен возвращать новое состояние без мутаций, чтобы React корректно определял изменения и выполнял ререндер.


-----

### useInsertionEffect

260. Чем `useInsertionEffect` отличается от `useEffect` и `useLayoutEffect` и для чего  он используется?
	- Вызывается до вставки DOM и до `useLayoutEffect`.
	- Используется для синхронной вставки стилей перед рендером.
	- нужен для CSS-in-JS библиотек, позволяет вставлять стили до любых layout-эффектов, гарантируя корректный рендер компонентов с нужными стилям
    
261. Можно ли читать DOM внутри `useInsertionEffect`?
	- Нет, DOM ещё не обновлён новым рендером. Чтение может вернуть устаревшие данные или вызвать ошибки.
    
262. Как `useInsertionEffect` влияет на порядок вставки CSS и приоритет правил?
	- Стили вставляются раньше всех других эффектов, обеспечивая правильный порядок `<style>` и корректное применение CSS с нужной specificity.

---
### useImperativeHandle

266. Как работает `useImperativeHandle` и зачем он нужен?
	- Позволяет кастомизировать объект, который родитель получит через ref

268. В каких случаях стоит избегать `useImperativeHandle` вообще?
	- Нет необходимости инкапсулировать доступ к DOM
	- Нужное поведение — декларативное, а не императивное
	- Применяется, когда это единственный способ выразить поведение: scroll, focus, animation trigger и т.д

---
### useDebugValue

271. Как работает `useDebugValue` и влияет ли он на продакшн-бандл?
	- `useDebugValue(value, formatFn?)` — это хук, который используется исключительно для отладки в React DevTools
	- Не влияет на поведение компонента, не вызывает побочные эффекты, удаляется на продакшн-сборке

---

## useEffectEvent

272. Что такое `useEffectEvent` и для чего он нужен?
	- Хук для извлечения нереактивной логики из эффектов в отдельную функцию - событие эффекта.
	- Позволяет читать последние значения props или state внутри эффекта без повторного запуска эффекта при их изменении.
273. Какие ограничения и рекомендации по использованию?
	- Вызывать только внутри эффектов.
	- Не передавать другим компонентам или хукам.
	- Не заменяет зависимости в массиве зависимостей эффекта. Для реактивных значений используйте их в массиве deps.
	- Применять только для нереактивной логики (логика, которая не должна перезапускать эффект).

--- 
### useSyncExternalStore

249. Что делает `useSyncExternalStore` и зачем он нужен?
	- Это хук React для синхронизации компонента с внешним источником состояния которые живут вне React.
	- Гарантирует, что данные читаются синхронно перед рендером, что важно для Concurrent Mode и SSR
	- Используется, когда внешнее состояние влияет на UI, а не просто на побочные эффекты.

250. Какие аргументы принимает `useSyncExternalStore` и что он возвращает?
	- subscribe(callback) – подписывается на изменения внешнего состояния. Возвращает функцию отписки.
	- getSnapshot() – синхронно возвращает актуальный снимок состояния. Должен быть стабильным (без лишнего создания новых объектов).
	- getServerSnapshot?() – опционально для SSR. Возвращает начальный снимок на сервере, чтобы клиент и сервер были синхронизированы.
	- Возвращает текущее состояние (snapshot), которое получено из getSnapshot (или из getServerSnapshot при серверном рендере) которое можно использовать в рендере компонента.

251. Почему нельзя использовать `useState`/`useEffect` для подписки на внешний источник состояния?
	- `useEffect` выполняется после рендера, поэтому UI может отрендериться с устаревшими данными → дергание интерфейса
	- При SSR `useEffect` не вызывается, поэтому компонент на сервере и клиенте может получить разное состояние
	- React не может гарантировать согласованность между рендером и подпиской

252. Как работает `getSnapshot` и почему он должен быть стабильным?
	- Возвращает актуальное значение из внешнего источника данных.
	- Если данные не изменились — возвращает тот же объект/примитив (сравнение через `Object.is`), чтобы избежать лишних ререндеров.
	- Если `getSnapshot` возвращает новый объект каждый раз → бесконечные ререндеры.

253. Как работает подписка (`subscribe`) и тайминг?
	1. Подписка сообщает React, когда вызвать `getSnapshot`.
	2. React вызывает `getSnapshot` синхронно при рендере и при уведомлении об изменении.
	3. Подписка должна возвращать функцию отписки, чтобы не было утечек памяти.

254. Типичные кейсы использования `useSyncExternalStore`?
	1. Глобальные сторы вне React: Redux, Zustand, MobX
	2. Браузерные API, которые изменяются со временем: `navigator.onLine`, `window.matchMedia`, размеры окна.
	3. Позиция скролла или элементов по `ref`, когда это влияет на рендер.
	4. Данные из LocalStorage, IndexedDB или других внешних хранилищ, когда UI зависит от них напрямую.

255. Как использовать `useSyncExternalStore` с SSR?
	 - Для серверного рендера используется `getServerSnapshot`.
	- Возвращает начальное значение, чтобы сервер и клиент рендерили один и тот же UI.
	- Если не передан `getServerSnapshot` при SSR → ошибка.

256. Когда использовать `useSyncExternalStore` а когда `useEffect`?
	1. useSyncExternalStore - Внешнее состояние влияет на UI и должно быть актуально сразу на рендере
	2. useEffect - Внешнее событие или состояние нужно только для побочного эффекта (анализ, уведомления, пуши, сокеты)

---

### useOptimistic

272. Что делает хук `useOptimistic` и зачем он нужен?
	- `useOptimistic(initialState, updateFn)` позволяет временно подменять состояние UI объектом, отражающим предполагаемый результат асинхронного действия, пока оно не завершится.
	- Хук позволяет сразу обновлять UI локально, предполагая успешный результат асинхронного действия, без ожидания завершения этого действия.
	- После завершения асинхронной операции (успешной или с ошибкой) происходит сброс оптимистического состояния и UI обновляется с актуальными данными.

273. Как работает функция `updateFn` и почему важно возвращать новый объект?
	- `updateFn(state, optimisticValue)` должен возвращать новый объект состояния, а не мутировать существующий.
	- React ожидает иммутабельность, чтобы корректно отслеживать изменения и вызывать ререндер компонента.
	- Мутация существующего объекта может привести к неправильному рендеру или отсутствию обновления UI.

274. Какие пропсы принимает useOptimistic и что он возвращает?
	1. const [state, update] = useOptimistic(initialState, updateFn);
		1. initialState — начальное значение состояния.`
		2. updateFn(state, optimisticValue) — функция, которая получает текущее состояние и оптимистическое значение, и возвращает новый state.
	2. Возвращает:
		1. state — текущее оптимистическое состояние для рендера.
		2. update(optimisticValue) — функция для применения оптимистического изменения.

 275. Как использовать `useOptimistic` с SSR и синхронизировать оптимистическое состояние с серверными данными?
	- `useOptimistic` позволяет сразу обновлять UI локально, предполагая успешный результат асинхронной операции.  
	- После завершения операции нужно синхронизировать состояние с сервером:  
		- При успешной операции — подтвердить оптимистическое изменение или заменить state актуальными данными с сервера.  
		- При ошибке — откатить оптимистическое изменение вручную, чтобы UI оставался консистентным.  
	- При SSR важно, чтобы сервер возвращал корректный начальный state, чтобы гидрация на клиенте была согласованной.  
	- В комбинации с Server Actions это позволяет пользователю видеть мгновальные изменения UI, а затем согласовывать их с результатами сервера (UI reconciles после завершения операции).
	
276. Как выглядит типичная схема: optimistic update → реальный результат → reconcile?
	1. Пользователь выполняет действие (например, отправляет сообщение).
	2. Вызывается `update(optimisticValue)`, UI сразу обновляется локально.
	3. В фоне запускается асинхронная операция (Server Action, fetch или mutation).
	4. Когда операция завершается:
	    - При SSR сервер возвращает актуальный state.
	    - При CSR клиент получает новые данные.
	5. UI reconciles — оптимистическое состояние сбрасывается, отображается реальный state.



 ---
### useTransition

280. Что делает `useTransition` и чем его поведение отличается от обычного обновления состояния?
	- Позволяет выполнять низкоприоритетные обновления интерфейса (Transitions), не блокируя критичные части UI.
	- Обновления внутри `startTransition` могут быть отложены, прерваны или отменены React Scheduler.
	- Без `startTransition` любое обновление состояния выполняется синхронно и может блокировать интерфейс при тяжёлых вычислениях.

281. Что возвращает `useTransition`?
	1. `isPending` — булево значение, показывающее, есть ли активный Transition.
	2. `startTransition` — функция, в которую передаётся callback для создания низкоприоритетного обновления.

283. Как работает `startTransition` и как он влияет на приоритет обновлений?
	- Обновления внутри `startTransition` получают TransitionLane — низкий приоритет.
	- Эти обновления могут быть прерваны или отложены, если приходят более важные (синхронные) обновления, например, ввод текста.
	- Обновления вне `startTransition` выполняются с SyncLane, немедленно.

286. Как React решает, когда прервать отложенный ререндер?
	- React использует cooperative scheduling (time slicing).
	- Если Transition занимает слишком много времени, React прерывает ререндер, чтобы обработать более важные события (ввод пользователя, клики).
	- После прерывания запускается повторный рендер с актуальными данными.

287. Какие базовые кейсы применения `useTransition`?
	- Обновление больших списков или таблиц данных после фильтрации/сортировки.
	- Переключение вкладок с тяжёлым контентом (фото, графики, карты).
	- Пагинация и подгрузка данных без блокировки пользовательского ввода.
	- В Suspense-ориентированных компонентах для плавного отображения fallback.

288. Когда следует использовать `useTransition`, а когда обычное обновление состояния?
	- `useTransition`: для **не критичных обновлений UI**, которые могут быть отложены, пока пользователь взаимодействует с интерфейсом.
	- Обычное `useState`: для **критичных изменений**, которые должны отразиться в интерфейсе немедленно (например, ввод текста в поле).

289. Когда лучше использовать глобальный `startTransition`, а не `useTransition`?
	- Когда не требуется индикатор ожидания (`isPending`).
	- Когда обновление запускается вне компонента или хука — в обычных JS-модулях (утилиты, middleware, обработчики сторонних библиотек), где нельзя использовать хуки и нет JSX.

---

### useDeferredValue

1. Что делает `useDeferredValue` и зачем он нужен?
	- Возвращает отложенную версию значения, которая обновляется с низким приоритетом.
	- Позволяет UI оставаться отзывчивым при тяжёлых или долгих рендерах.

1. В чём отличие `useDeferredValue` от `useTransition`?
	- `useTransition` оборачивает `setState`, создавая Transition для обновлений.
	- `useDeferredValue` применяется к уже вычисленному значению и позволяет «догонять» его с задержкой.

1. Какие типы значений можно передавать в `useDeferredValue`?
	- Примитивы (string, number, boolean), объекты, массивы, функции.
	- Для объектов/массивов важно, чтобы ссылки создавались вне рендера, иначе будут лишние ререндеры.

1. Как использовать `useDeferredValue` с Suspense и fallback UI?
	- DeferredValue передаётся в компонент, который использует Suspense.
	- Пока background render с новым значением загружается, пользователь видит старые данные вместо fallback.

1. Когда стоит использовать `useDeferredValue` вместо обычного состояния?
	- Когда часть UI медленно рендерится, но нужно, чтобы остальная часть оставалась отзывчивой.
	- Например: список/таблица, которая обновляется при каждом вводе в текстовое поле.

1. Как `useDeferredValue` отличается от дебаунса и троттлинга?
	- Не требует фиксированной задержки, обновление зависит от производительности устройства.
	- Background render прерываемый: новые изменения отменяют текущий deferred render.
	- Дебаунс/троттлинг блокируют обновления, useDeferredValue лишь снижает приоритет рендера.

---

### `useActionState`

1. Что делает `useActionState` и для чего нужен?
	- Обновляет локальное состояние на основе результата асинхронного `action`.
	- Управляет состоянием формы или компонента при отправке данных и синхронизирует UI с результатом Server Action.
2. Чем `useActionState` отличается от `useState` + `useEffect`?
	- Автоматически синхронизирует состояние с результатом последнего вызова `action`.
	- Нет необходимости вручную слушать изменения и обновлять состояние через эффекты.
3. Какие аргументы принимает `useActionState`?
	- `action` — асинхронная функция `(prevState, formData) => newState | Promise<newState>`.
	- `initialState` — начальное состояние.
	- `permalink` (опционально) — URL для прогрессивного улучшения на динамических страницах.
4. Что возвращает `useActionState`?
	- `state` — текущее состояние, сначала `initialState`, затем результат последнего `action`.
	- `formAction` — функцию для `<form action={formAction}>` или вызова вручную.
	- `isPending` — флаг выполнения `action`.

1. Как использовать `useActionState` для форм и асинхронных действий?
	- Передавать `formAction` в `<form>` или кнопку.
	- Использовать `state` для отображения данных.
	- Использовать `isPending` для индикатора загрузки.

1. Как работает `action(prevState, formData)`?
	- `prevState` — текущее состояние до отправки.
	- `formData` — данные формы.
	- Возвращает новое состояние синхронно или через `Promise`.

1. Что происходит при ошибке в `action`?
	- Состояние не обновляется.
	- `isPending` становится `false`.
	- Ошибки нужно обрабатывать вручную.

---
## useFormStatus
1. **Что делает `useFormStatus` и зачем он нужен?**  
   - Хук из `react-dom`, который показывает текущий статус родительской формы.  
   - Используется для управления UI во время отправки формы, например, чтобы дизейблить кнопки или показывать индикатор загрузки.

2. **Какие ключевые данные возвращает хук и как их использовать?**  
   - `pending` — true, если форма сейчас отправляется.  
   - `data` — данные формы, которые отправляются.  
   - `method` — метод формы (`get` или `post`).  
   - `action` — функция или ссылка на обработчик формы.

3. **Где нужно использовать `useFormStatus`, чтобы он работал корректно?**  
   - Только внутри компонента, который находится внутри родительской `<form>`.  
   - Не работает для форм, созданных в том же компоненте, где вызывается хук, или вне `<form>`.

4. **В каких случаях стоит использовать `useFormStatus`?**  
   - Чтобы дизейблить кнопку отправки, пока форма ещё обрабатывается.  
   - Чтобы показать индикатор загрузки или сообщение о процессе отправки.  
   - Чтобы читать текущие данные формы во время отправки и использовать их в UI (например, отображение запрашиваемого имени пользователя).

---

## createContext 

 1. Что такое Context в React и зачем он нужен?
	Механизм для передачи общих данных по дереву без проп-drilling.
	
 2. Что такое «prop drilling» и как Context это решает?
	- Prop drilling — необходимость прокидывать пропсы через промежуточные компоненты.  
	- Context позволяет получать данные напрямую через `useContext`, минуя цепочку пропсов.

 3. Как создать Context?
	- Через `createContext()`, затем обернуть нужную часть дерева в `<MyContext.Provider>` и получить данные через `useContext(MyContext)`.

4. Почему для получения значения контекста компонент должен находиться внутри Provider?
	- Потому что Provider формирует границу контекста.  
	- Если компонент находится вне Provider, React возвращает значение по умолчанию, так как никакого контекста выше в дереве нет.