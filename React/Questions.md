#### **1. Virtual DOM и Reconciliation**

1. Что такое Virtual DOM?
	1. Virtual DOM - это **абстрактное представление UI** в виде дерева **обычных JavaScript-объектов**, которые отражают структуру реального DOM. React использует его, чтобы **оптимизировать и контролировать обновления интерфейса**.
2. Как работает Virtual DOM?
	1. Компонент возвращает JSX → превращается в дерево Virtual DOM.
	2. При изменении состояния/пропсов React создаёт новое дерево VDOM.
	3. React сравнивает новое и старое дерево (алгоритм diff).
	4. Вычисляется минимальный набор изменений (патчи)
	5. Реальный DOM обновляется **точечно**, на основе diff-а.
3. Что может спровоцировать обновление Virtual DOM?
	1. Изменение `props` компонента
	2. Изменение контекста через `useContext`
	3. Монтирование и размонтирование компонентов
	4. Изменение состояния через `useState`/`useReducer`
	5. Любые изменения данных, влияющие на вывод JSX
4. Где работает Virtual DOM?
	1. Virtual DOM работает в памяти JavaScript-движка, то есть в оперативной памяти (RAM) браузера, внутри JavaScript-окружения
5. Из чего состоит Virtual DOM?
	1. Virtual DOM состоит из JavaScript-объектов, каждый из которых представляет **один UI-элемент** (аналог узла DOM)
6. Почему Virtual DOM эффективнее прямых манипуляций с DOM?
	1. Прямые манипуляции с DOM вызывают дорогостоящие затраты браузера на layout/repaint.
	2. Работать с UI в памяти,
	3. Обновления происходят в памяти, что позволяет вычислять минимальный набор изменений (diffing) и применять их пакетно, снижая количество дорогостоящих операций с реальным DOM
7. Как работает алгоритм **diffing** в React для сравнивания изменения в Virtual DOM?
	1. React использует эффективный алгоритм diffing с линейной сложностью O(n)
	2. Сравнивает элементы сверху вниз и слева направо.
	3. Если у элементов **разный `type`** (например, `div` и `span` или разные компоненты), React полностью заменяет соответствующее поддерево.
	4. Если `type` совпадает, React сравнивает **props** и рекурсивно переходит к сравнению **детей**.
	5. При сравнении детей React ориентируется на позицию элементов и `key
		1. Если ключи присутствуют, используется сопоставление по ним для эффективной обработки добавлений, удалений и перемещений.
		2. Без ключей сравнение идёт по индексу, что менее эффективно и может привести к лишним обновлениям.
8. Как ключи (`key`) влияют на процесс сравнения элементов?
	1. Ключи (`key`) — это уникальные идентификаторы элементов списка, которые React использует для сопоставления элементов между старым и новым деревом
	2. Если ключи присутствуют, React сопоставляет элементы по ним, что позволяет эффективно выявлять: - добавленные, удалённые перемещённые элементы.
	3. Без ключей React сравнивает элементы **по их позиции (индексу)** в массиве

#### **2. Fiber Architecture**

9. Что такое React Fiber и чем он отличается от Stack Reconciler?
	1. Прерываемость
	2. Приоритезация
	3. Инкрементальный рендеринг
10. В чем минусы Virtual DOM над Fiber?
	1. Старый Virtual DOM работал синхронно и непрерываемо, что приводило к блокировкам UI при больших обновлениях.
	2. Отсутствие приоритезации обновлений: все обновления обрабатывались с одинаковым приоритетом.
	3. Нельзя было **прервать, отложить или отменить рендеринг**, что негативно влияло на отзывчивость интерфейса.
	4. Отсутствие инкрементального (пошагового) рендеринга
	5. Отсутствие возможности прерывать и возобновлять рендеринг с учётом приоритетов.
11. Почему Fiber использует связный список, а не рекурсивный обход?
	1. Связный список позволяет React:
		1. Выполнять обход дерева итеративно, без глубокого рекурсивного стека, что снижает риск переполнения стека
		2. Прерывать и возобновлять рендеринг
		3. Управлять приоритетами задач и планировать работу по частям
	2. Рекурсия же требует полного прохода и не позволяет прерывать работу посередине.
12. Как работает связный список в контексте Fiber?
	1. это структура из объектов FiberNode, где каждый узел содержит ссылки:
		1. child — на первого потомка,
		2. `sibling` — на следующего брата (соседа),
		3. `return` — на родителя.  
    2. Так можно пройти всё дерево последовательно, переходя от родителя к первому ребёнку, потом к соседям, обходя дерево без рекурсии.
13. Что такое FiberNode и как он устроен?
	1. FiberNode — это объект, представляющий один узел дерева Fiber. Он содержит всю информацию, необходимую React для управления рендерингом и обновлением конкретного UI-элемента
14. Какие ключевые поля содержит объект FiberNode и что каждое из них означает?
	1. stateNode — ссылка на реальный инстанс, связанный с этим узлом (DOM-элемент, экземпляр класса, или null для функциональных компонентов).
	2. return — ссылка на родительский FiberNode, позволяющая подниматься вверх по дереву.
	3. child — ссылка на первый дочерний FiberNode, начало обхода детей.
	4. sibling — ссылка на следующий соседний FiberNode на том же уровне.
	5. flags — битовая маска, указывающая, какие операции (вставка, обновление, удаление) нужно выполнить с этим узлом.
15. Как взаимодействуют FiberNode поля `return`, `child` и `sibling` для обхода дерева Fiber без рекурсии?
	1. Поле `child` позволяет спуститься вниз по дереву
	2. поле `sibling` — перейти к соседнему узлу на том же уровне
	3. поле `return` — подняться вверх к родителю после обхода всех детей.
	4. Вместе они реализуют итеративный обход дерева, заменяющий рекурсию, что даёт контроль над процессом рендеринга и позволяет прерывать и возобновлять работу.
16. Какие бывают типы флагов (`flags`) в `FiberNode` и какие операции они обозначают?
	1. `flags` — это битовая маска, которая сообщает React, какие действия нужно выполнить над узлом на этапе **commit**. Основные флаги:
		1. Placement — узел нужно **вставить** в DOM (новый элемент).
    	2. Update`** — узел нужно **обновить** (например, props или DOM-атрибуты).
		3. Deletion — узел нужно **удалить** из DOM.
		4. ChildDeletion — удалить одного или нескольких потомков.
		5. Ref — обновить ref.
		6. Passive — выполнить эффекты `useEffect`.
17. Что такое двойная буферизация (double buffering) в Fiber?
	1. Двойная буферизация в Fiber — это хранение двух деревьев (current и working) для безопасного обновления UI без блокировок: изменения делают в рабочем дереве, а после завершения заменяют текущее.

#### **3. Fiber Render Process**

18. Что такое work loop в React Fiber и как он организует рендеринг?
	1. **Work loop в React Fiber** — это основной цикл, в котором React **пошагово обходит дерево Fiber**, создаёт/обновляет `FiberNode`'ы и готовит дерево к коммиту. Он лежит в основе **инкрементального, прерываемого рендеринга**.
19. Как связный список Fiber позволяет прерывать и возобновлять рендеринг?
	1. обход дерева — это итеративный процесс с явным хранением текущей позиции, это позволяет просто сохранить состояние обхода (текущий узел), остановить цикл и освободить основной поток для других задач, при следующем вызове React продолжит обход с сохранённого узла, а не начинает заново или не уходит в глубокую рекурсию
20. Как обновляется UI в React Fiber (полный цикл от `setState` до отрисовки)?
	1. Инициирование обновления
		1. создаётся объект обновления, который добавляется в очередь обновлений соответствующего `FiberNode`.
	2. Приоритезация
		1. Обновление получает приоритет через систему **Lanes**.  
	3. Планирование задачи (Scheduler)
		1. Scheduler решает, когда запускать работу: сразу (высокий приоритет) или отложить (низкий).
	4. Render-фаза (Reconciliation) - эта фаза прерываема и инкрементальна, может быть приостановлена и возобновлена.
		1. Создаётся новое дерево `work-in-progress` (рабочее дерево Fiber) на основе текущего.
		2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие `FiberNode`'ы, собирает список эффектов
	5. Завершение render-фазы
		1. После обхода дерева React формирует полный список эффектов для commit-фазы.
	6. Commit-фаза (синхронная, непрерываемая)
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (`cleanup`) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции `useLayoutEffect`
		4. Выполняются функции `useEffect`
	7. Обновление текущего дерева
		1. Рабочее дерево `work-in-progress` становится текущим (`current`), старое может быть удалено или повторно использовано
21. Какие фазы есть в Fiber?
	1. Reconciliation (render фаза) - Прерываемая и инкрементальная.
	2. Commit фаза - Синхронная и непрерываемая.
22. Чем отличаются эти фазы и какую роль они играют в обновлении UI?
	1. render-фаза отвечает за подготовку и планирование изменений, commit-фаза — за их окончательное применение и взаимодействие с DOM.
23. Что происходит в фазе **Render**?
	1. . Создаётся новое дерево `work-in-progress` на основе текущего.
	2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие `FiberNode`'ы, собирает список эффектов
	3. После обхода дерева React формирует полный список эффектов для commit-фазы.
	4. Фаза может быть прервана и возобновлена, чтобы избежать блокировки основного потока
24. Что происходит в фазе **Commit**?
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (`cleanup`) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции `useLayoutEffect`
		4. Выполняются функции `useEffect
		5. Commit-фаза не прерывается, чтобы гарантировать консистентность DOM
25. Что такое Effect List?
	1. это связанный список узлов Fiber с помеченными изменениями, которые React последовательно применяет к DOM и запускает соответствующие эффекты в фазе commit.
26. Как формируется и используется **Effect List**?
	1. Во время render-фазы React при обходе `work-in-progress` дерева помечает каждый `FiberNode` с изменениями специальными флагами
	2. Эти помеченные узлы собираются в Effect List — связанный список эффектов, которые нужно применить.
	3. В commit-фазе React последовательно проходит по Effect List и выполняет соответствующие операции

#### **4. Priority System and Scheduling**

27. Как работает система приоритетов в React Fiber и как она влияет на рендеринг?
	1. Каждое обновление получает приоритет — через механизм `Lanes`.
	2. React сначала обрабатывает **более приоритетные задачи** (например, ввод), менее важные — откладывает.
28. Что такое **Lane-модель** и как она работает?
	1. Lane-модель — система приоритизации обновлений в React Fiber, где каждое обновление относится к одной или нескольким lanes — битовым флагам разного приоритета.
29. Какие типы (lanes) существуют (`SyncLane`, `InputContinuousLane`, `DefaultLane` и др.)?
	1. SyncLane — максимальный приоритет, обновления должны выполниться сразу (например, flushSync).
	2. InputContinuousLane — приоритет интерактивного ввода, чтобы UI был отзывчивым.
	3. DefaultLane — обычные фоновый обновления.
30. Что такое Scheduler?
	1. Это планировщик задач React, который решает, когда и с каким приоритетом запускать работу по обновлению UI. Он координирует выполнение render-фазы, позволяя прерывать низкоприоритетные задачи ради более важных
31. Как **Scheduler** выбирает приоритет задач?
	1. Scheduler использует lanes и сопоставляет их с уровнями приоритетов.
	2. Задачи с более высоким приоритетом прерывают текущие и запускаются раньше
32. Что делает `flushSync` и как он обходит приоритезацию?
	1. `flushSync` — функция, которая запускает обновление синхронно, игнорируя систему приоритетов и асинхронность Scheduler. Она принудительно выполняет render и commit сразу, чтобы обновление UI произошло немедленно
33. Что такое **Concurrent Mode** и как он меняет рендеринг?
	1. Concurrent Mode - новый способ работы React с рендерингом, при котором React не блокирует основной поток на долгое время, а разбивает работу на небольшие части (инкрементальный рендеринг).
	2. Позволяет React **приостанавливать, возобновлять и приоритезировать** работу по обновлению интерфейса.
34. Что такое time slicing?
	1. механизм в React Fiber, который разбивает работу по рендерингу на небольшие части. React выполняет эти части по очереди, прерываясь по тайм-ауту, чтобы дать браузеру возможность обрабатывать пользовательские события и другие задачи.
	2. Time slicing реализуется за счёт итеративного обхода дерева Fiber с сохранением состояния, чтобы при возобновлении рендеринга продолжить с того места, где остановились.
35. Как React прерывает и возобновляет рендеринг (time slicing)?
	1. React разбивает работу рендера на небольшие задачи — единицы работы (`units of work`).
	2. При достижении лимита времени текущая задача прерывается, текущее состояние обхода (`nextUnitOfWork`) сохраняется.
	3. В следующий момент React возобновляет обход с сохранённой позиции, позволяя браузеру обрабатывать важные события между этими фрагментами работы
36. Как Suspense использует механизм прерывания?
	1. Suspense позволяет React прервать рендеринг компонента, если он «зависает» на асинхронной операции (например, загрузке данных или кода).
	2. React отменяет текущую работу по рендеру, показывает fallback UI, а затем возобновляет рендеринг, когда асинхронная операция завершена.

#### **5. Server-Side Rendering and Hydration**

37. Как работает гидратация (hydration) после SSR?
	1. Сервер присылает готовую страницу с уже заполненным HTML
	2. Браузер показывает этот HTML — пользователь сразу видит контент, даже если JS ещё не загрузился.
	3. После загрузки JS React берёт этот HTML и «подключает» к нему свою логику: навешивает обработчики событий, создаёт внутренние структуры для управления состоянием.
	4. React не рисует заново весь UI, а работает поверх уже существующего DOM, делая его интерактивным.
38. Что такое **selective hydration** и как она ускоряет загрузку?
	1. Selective hydration — это стратегия, при которой React не гидратирует сразу всё дерево, а по частям и с приоритетом. Например, сначала гидратируются видимые пользователю интерактивные части, а остальные — позже или при взаимодействии.
39. Что такое Server Components?
	1. Server Components — это React-компоненты, которые рендерятся только на сервере. Они не попадают в клиентский бандл, не запускают JS в браузере и позволяют значительно уменьшить размер кода на клиенте. Серверные компоненты могут напрямую обращаться к базе данных или файловой системе и отправлять готовый HTML, облегчая загрузку и повышая производительность
40. Что такое серверные функции?
	1. Серверные функции (Server Actions) — это функции, которые выполняются на сервере по вызову из React-компонента. Они могут обрабатывать данные, выполнять бизнес-логику или работать с API, при этом не отправляя клиенту лишний JavaScript
41. Что такое деректива use client?
	1. строчка в начале файла которая указывает, что компонент должен рендериться и работать на клиенте.
42. Что такое деректива use server?
	1. строчка в начале файла указывает, что функция или компонент выполняется только на сервере.
43. Что можно делать в сервеных компонентах чего нельзя в клиентских?
	1. доступ к базе данных, файловой системе, секретам
	2. использовать серверные зависимости (например, `fs`, `pg`, `bcrypt`)
44. Что можно делать в клиентский компонентах чего нельзя в серверных?
	1. использовать:
		1. браузерные API
		2. Хуки react
		3. обработчики событий
		4. манипулировать с DOM
45. Что такое Streaming SSR и как он работает?
	1. Streaming SSR — это возможность React отдавать HTML по мере готовности дерева пока React рендерит все по частям
	2. Работает через `renderToPipeableStream` (Node.js) или `renderToReadableStream` (Edge/Cloud).
46. Что такое **hydration mismatch**? 
	1. **Hydration mismatch** — это ситуация, когда HTML, пришедший с сервера (SSR) не совпадает с тем, что React "ожидает" при клиентской гидратации.
47. Как избежать hydration mismatch?
	1. **Соблюдать одинаковую логику рендера** на сервере и клиенте.
		1. не использовать случайные значения (`Math.random()`, `Date.now()`),
		2. `window`, `document` и любые browser-only API.
		3. Использовать `useEffect`, а не `useLayoutEffect` для client-only логики
48. Почему важно, чтобы SSR и клиентский рендер генерировали одинаковый DOM?
	1. React при гидратации **подключается к существующему серверному HTML** и ожидает, что структура совпадёт. Если DOM не совпадает — происходит **hydration mismatch**, React показывает предупреждения и может перерисовать большие участки UI
49. Что произойдёт при hydration mismatch?
	1. React покажет warning, а иногда — перерисует весь DOM узел
50. как useLayoutEffect может влиять на hydration?
	1. `useLayoutEffect` выполняется **до отрисовки**, только на клиенте — и может **синхронно изменить DOM**, не совпадающий с HTML от сервера, что приводит к hydration mismatch
51. Как SSR помогает уменьшить Time to First Byte (TTFB)
	1. SSR позволяет серверу сразу отправить полностью сформированный HTML, благодаря чему браузер начинает отображать контент сразу после получения первого байта без задержек на загрузку и выполнение JS
52. Как избежать отправки лишнего JS на клиент
	1. Использовать Server Components, которые рендерятся только на сервере и не попадают в клиентский бандл.
	2. Применять `use client` директиву строго там, где нужна интерактивность.
	3. Делать код-сплиттинг и динамический импорт для загрузки JS только при необходимости.
	4. Минимизировать зависимости и не импортировать клиентские библиотеки в серверные компоненты.
	5. Использовать selective hydration, чтобы загружать JS по частям и с приоритетом.
53. Как работает Suspense и lazy loading серверных данных и компонентов?
	1. Серверные компоненты могут использовать асинхронные функции (например, `await fetch()`) прямо внутри тела компонента. React ждёт их завершения или отдаёт fallback, обеспечивая эффективный ленивый рендеринг и загрузку.
	2. После загрузки данных React «дозаписывает» оставшийся HTML по стриму (Streaming SSR), обеспечивая эффективный ленивый рендеринг и быструю первую отрисовку.
	3. На клиенте Suspense переключается между fallback и готовым UI по мере завершения загрузки, поддерживая плавный переход.
54. Какими хуками можно пользоваться в серверных компонентах?
	1. useId - Генерация стабильных ID

#### **6. Performance Optimization**

55. Как React избегает лишних ререндеров?
	1. Virtual DOM и сравнение (reconciliation)
	2. Мемоизация с `React.memo`
	3. Хуки `useMemo` и `useCallback`
	4. Контроль ключей (`key`) в списках
56. Как работает **batching** обновлений?
	1. это механизм объединения нескольких обновлений состояния (state updates) в один цикл рендера
	2. внутри обработчика вызывается несколько `setState` или обновлений, React объединяет (batch) их и выполняет **один рендер** после завершения обработчика
57. Как Fiber улучшает отзывчивость UI (например, при анимациях)?
	1. Приоритизация обновлений
	2. Прерываемость рендера
	3. благодаря time slicing и прерывистому рендеру, браузер может своевременно обновлять кадры анимаций и избегать "фризов".

#### **7. Advanced Patterns and Features**

58. Как Fiber обрабатывает асинхронные операции?
	1. Fiber сам по себе не выполняет асинхронные операции, но он управляет их результатами и обновлением UI с учётом приоритетов
59. Как работает **Suspense для данных**?
	1. Suspense для данных приостанавливает рендер компонента, если данные ещё не готовы, бросая Promise. React показывает fallback UI, пока Promise не разрешится, после чего рендер возобновляется с готовыми данными.
60. Что такое use()?
	1. `use()` — это React API для чтения значения ресурса, такого как Promise или контекст
61. для чего нужен use()?
	1. Чтобы "подписаться" на Promise или контекст и получить их значение, интегрируясь с Suspense и Error Boundaries.
62. как работает use()?
	1. Если передан Promise, React "приостанавливает" рендер компонента до его разрешения (Suspense fallback показывается).
	2. Если Promise отклонён — срабатывает ближайший Error Boundary.
	3. Если передан контекст — `use()` возвращает его значение, как `useContext`, но может использоваться в условных и циклах.
63. где работает use()? ssr или csr?
	1. Работает и на сервере, и на клиенте, но преимущественно используется для чтения ресурсов в Client Components
64. Как новый хук `use()` взаимодействует с Fiber?
	1. `use()` интегрируется с механизмом Suspense в Fiber: при ожидании Promise Fiber приостанавливает рендер и переключается на fallback, а после разрешения возобновляет рендер с полученными данными.
65. как использовать use() с контекстом?
	1. Использование `use` с контекстом способ читать значение контекста, аналогичный `useContext`, но с преимуществом возможности вызывать `use` внутри условных блоков и циклов.
66. Почему нельзя просто `await` в Client Components вместо use()?
	1. `await` нельзя использовать напрямую в теле функционального компонента — он синхронный и блокирует. `use()` позволяет React управлять состоянием ожидания асинхронного результата в рамках Fiber и Suspense.

#### **8. Debugging and Internals**

67. В чём разница между `useLayoutEffect` и `useEffect` с точки зрения Fiber?
	 1. `useLayoutEffect` — синхронный, блокирующий эффект, полезен для измерений DOM и синхронных манипуляций. выполняется в **phase commit**, **после того, как React применил изменения к DOM**, но **до того, как браузер обновил экран**
    2. `useEffect` — асинхронный, неблокирующий, выполняется после отрисовки, оптимален для сетевых запросов, подписок и не критичных к времени операций. выполняется **после фазы commit и после того, как браузер отрисовал обновлённый UI**
68. Как React делит работу на чанки и приостанавливает рендеринг для более важных задач?
	1. React Fiber разбивает работу рендеринга на небольшие части (чанки). При этом рендеринг **приостанавливается** (interruptible rendering), если появляется задача с более высоким приоритетом (например, пользовательский ввод)
69. Как React обрабатывает "зависшие" компоненты (например, при загрузке данных).
	1. При загрузке данных, если компонент возвращает Promise, React **приостанавливает его рендеринг**, показывая запасной UI (fallback) через Suspense. Когда данные загружены, React продолжает рендеринг компонента с этими данными
70. что такое Selective Hydration?
	1. Selective Hydration — это техника, при которой React при гидратации на клиенте сначала  гидратирует только самые важные или видимые части UI, а остальные части гидратируются позже, по мере необходимости.
71. Разница между срочными (urgent) и отложенными (non-urgent) обновлениями и Как это связано с приоритетами в Scheduler.
	1. Срочные (urgent) обновления — это события с высоким приоритетом, как ввод пользователя или клики, которые React должен обработать немедленно.
	2. Отложенные (non-urgent) обновления — менее важные задачи, например, обновление неактивных компонентов, которые можно выполнить позже.  
	3. Scheduler React управляет этими приоритетами, позволяя прерывать низкоприоритетные задачи для срочных, поддерживая отзывчивость UI.
72. что такое interruptible rendering?
	1. Interruptible rendering — возможность React прерывать текущий процесс рендеринга в любой момент, чтобы переключиться на более приоритетную работу, а затем продолжать с места остановки
73. Почему Server Components не имеют состояния и хуков?
	1. Server Components рендерятся на сервере и не имеют жизненного цикла или интерактивности, поэтому состояние и хуки им не нужны
74. Как server Components уменьшают размер бандла.
	1. Потому что Server Components не включаются в клиентский бандл JavaScript — они полностью рендерятся на сервере и передают клиенту уже готовый HTML
75. Как работают `React.lazy` и `Suspense` для динамического импорта компонентов?
	1. React.lazy` динамически импортирует компонент (через `import()`), возвращая промис.
	2. Пока компонент загружается — `Suspense` показывает fallback UI.
	3. После загрузки компонент рендерится как обычно.
76. Какие бывают варианты fallback UI и как работает вложенность в `Suspense`?
	1. Fallback — любой React-элемент, показываемый во время загрузки.
	2. Вложенные Suspense показывают самый близкий fallback для загрузки в своей области.
77. Какие основные этапы монтирования, обновления и размонтирования компонентов в функциональном React?
	1. Монтирование: рендер + запуск эффектов с пустым массивом зависимостей (`useEffect(() => {}, [])`).
	2. Обновление: повторный рендер + эффекты с изменившимися зависимостями.
	3. Размонтирование: вызов очисток эффектов (функций, возвращаемых из `useEffect`
78. Как компоненты ведут себя в разных режимах рендера (синхронном и конкурентном)?
	1. Sync: рендер блокирует UI до конца.
	2. Concurrent: рендер можно приостанавливать, приоритеты обновлений.

#### **9. Component Patterns and State Management**

79. Как реализуется однонаправленный поток данных в React?
	1. Однонаправленный поток данных в React означает, что данные всегда идут сверху вниз — от родительских компонентов к дочерним через props
	2. Родитель хранит состояние и передаёт его дочерним, которые могут только читать эти props, но не менять их напрямую. Изменения состояния происходят в родителе через коллбэки, переданные вниз
80. Что такое "lifting state up" и как его правильно использовать?
	1. это когда состояние, нужное нескольким компонентам, поднимается к их ближайшему общему родителю. Вместо того чтобы каждый компонент держал своё локальное состояние и пытался синхронизировать его, состояние централизуется в одном компоненте-родителе, а дочерним передаются через props и коллбэки для изменения.
81. В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?
	1. **Контролируемые компоненты** — это компоненты, где состояние формы полностью управляется React через `state` и обновляется через обработчики (`onChange`). Значение поля всегда берётся из состояния, а не из DOM.
	2. **Неконтролируемые компоненты** — это компоненты, где состояние формы хранится непосредственно в DOM, а React лишь получает доступ через  ref. React не управляет значением, а читает его при необходимости.
	3. Контролируемые компоненты позволяют сразу валидировать, управлять вводом, делать условный рендер элементов формы.

#### **10. React Features and APIs**

82. Как и зачем применять `React.Fragment`?
	1. Позволяет сгруппировать несколько элементов без добавления лишнего DOM-узла.
83. Когда и как правильно использовать порталы в React?
	1. Используйте порталы, когда UI-элемент должен визуально выходить за пределы текущей иерархии DOM — например, модальные окна, тултипы, всплывающие меню, уведомления
84. Как работает ReactDOM.createPortal и как он участвует в Fiber-дереве 
	1. `ReactDOM.createPortal` рендерит элемент в другой DOM-узел, но оставляет его частью того же Fiber-дерева. Компонент внутри портала получает контексты, участвует в рендеринге, Suspense, ErrorBoundary и сохраняет порядок событий.
85. Поведение при вложенных `Suspense` с fallback-цепочками 
	1. При вложенных `Suspense`, React строит **цепочку fallback’ов**: если inner `Suspense` переходит в состояние ожидания (suspend), React показывает его `fallback`.
	2. Если `fallback`-контент тоже вызывает suspend (например, ленивый компонент или async server компонент), React поднимается к ближайшему родительскому `Suspense` выше по компонентному дереву (не по DOM) и рендерит уже его `fallback`. Этот процесс продолжается вверх, пока не найдётся `fallback`, который можно отрендерить синхронно.
	3. Это называется **suspense cascade** — поведение предсказуемо, и важно, что цепочка строится по дереву компонентов, а не по DOM
86. Какие особенности управления событиями и фокусом возникают при работе с порталами?
	2. События всплывают по React-дереву, а не по DOM — обработчики работают как обычно, несмотря на другой DOM-узел
	3. Фокусом нужно управлять вручную: при открытии модалки ставить фокус в портал, при закрытии — возвращать на исходный элемент.
87. Какие аргументы принимает cratePortal?
	1. children** — React-элементы, которые нужно отрендерить (JSX, компоненты, строки, фрагменты и т.п.).
	2. domNode** — DOM-узел, куда будет помещён этот контент. Этот узел должен уже существовать в DOM.
	3. key** (опционально) — уникальный ключ (строка или число) для идентификации портала, особенно при рендере списков порталов.
88. Какие стандартные атрибуты и API React помогают создавать доступный UI?
	1. aria-* (`aria-label`, `aria-labelledby`, `aria-describedby`, `aria-hidden`) для описания элементов для скринридеров.
	2. tabIndex - для настройки порядка табуляции и возможности фокусировки.
89. Как правильно реализовать контролируемые и неконтролируемые компоненты форм?
	1. Контролируемые компоненты:** значение хранится в состоянии (`useState`), обновляется через `onChange`. React полностью управляет вводом.
	2. **Неконтролируемые компоненты:** значение хранится в DOM, доступ через `ref`. React не управляет вводом напрямую.
90. Как обрабатывать события `onChange` и `onSubmit` в формах?
	1. **onChange:** обновляет состояние для контролируемых компонентов.
	2. o**nSubmit:** отменяет стандартное поведение и обрабатывает данные из состояния или `ref`.
91. Как сделать простую валидацию без сторонних библиотек?
	1. выполняется прямо в обработчике `onSubmit` или `onChange` — проверяем значения на нужные условия с сохранением ошибок в состоянии
	2. HTML-атрибуты валидации `required`, `minLength`, `pattern`
92. Как реализовать анимации с помощью CSS?
	1. Создаёшь CSS-классы с `transition` (для плавных переходов свойств) или `@keyframes` (для сложных анимаций).
93. Как работает система `SyntheticEvent` в React?
	1. `SyntheticEvent` — это обёртка над нативными событиями браузера, которую React создаёт для обеспечения **кроссбраузерного** и **одинакового API** при работе с событиями.
94. В чём основные отличия между Synthetic Events и нативными событиями браузера?
	1. **Кроссбраузерность**  
	    1. `SyntheticEvent` предоставляет единый интерфейс, который одинаково работает во всех браузерах. Нативные события могут иметь отличия в свойствах и поведении между браузерами.
	2. **Поведение всплытия**  
	    События в React всплывают **по React-иерархии компонентов**, даже если DOM-структура другая (например, при использовании `createPortal`). Нативные события всплывают **по DOM-дереву**.
	3. **Совместимость с React API**  
	    1. Только `SyntheticEvent` работает корректно с системой приоритетов событий в concurrent режиме. Нативные события об этом "не знают".
	4. **API одинаково везде**  
	    1. У `SyntheticEvent` всегда есть стандартные свойства (`type`, `target`, `currentTarget`, `preventDefault()`, `stopPropagation()` и т.п.), даже если браузер этого не поддерживает напрямую.
95. Как ведёт себя Strict Mode?
	1. В Strict Mode компоненты и хуки специально монтируются, размонтируются и монтируются заново _в режиме разработки_. Это имитация двойного вызова жизненных циклов для выявления побочных эффектов
96. Почему компоненты и хуки вызываются повторно в Strict Mode?
	1. React повторно вызывает функции компонентов и эффекты, чтобы проверить, правильно ли они чистят ресурсы и не вызывают неожиданных сайд-эффектов при монтировании/размонтировании
97. Как  Strict Mode  помогает улучшить качество кода и отловить ошибки?
	1. Такая проверка помогает заранее выявлять баги, неправильное управление эффектами и состояние, делая код более устойчивым и предсказуемым перед продакшен-сборкой
98. Как настроить Strict Mode?
	1. обернуть компонент в `<React.StrictMode>`.
99. Как получить доступ к контексту без хуков?
	через компонент `<MyContext.Consumer>`. В него передают функцию, которая получает текущее значение контекста.
100. Какие проблемы с производительностью возникают при частых обновлениях контекста?
	1. При изменении значения в провайдере все дочерние компоненты использующие контекст перерендериваются, даже если используют лишь часть данных или не затронуты логикой/
101. Как JSX трансформируется в вызовы `React.createElement`?
	1. JSX — это синтаксический сахар, который во время сборки транспилируется в вызовы `React.createElement`
102. Что такое `ReactElement` и чем он отличается от компонента?
	1. `ReactElement` — это обычный объект, который описывает элемент React: тип (тег или компонент), пропсы и детей. Это «план» для реального DOM. Он не является компонентом и не содержит логики — это результат вызова компонента или JSX.

#### **11. React 18+ Features**

101. Как Automatic Batching работает с промисами и таймерами?
	1. В React 18 Automatic Batching работает со всеми асинхронными операциями. Когда несколько setState вызываются внутри промиса или setTimeout, React автоматически объединяет их в один рендер, что значительно улучшает производительность.
102. В чем разница между React 17 и React 18 batching?
	1. React 17: batching работал только в обработчиках событий React (onClick, onChange и т.д.)
	2. React 18: batching работает везде, включая промисы, таймеры, сетевые запросы и любые другие асинхронные операции
103. Как `flushSync` обходит Automatic Batching?
	1. `flushSync` принудительно выполняет обновление синхронно, игнорируя Automatic Batching. Это полезно когда нужно немедленно применить изменения, например, для измерений DOM или интеграции с внешними библиотеками.
104. Что такое React Compiler?
	1. React Compiler — это  инструмент, который автоматически оптимизирует React код во время компиляции. Он анализирует код и применяет оптимизации, которые раньше требовали ручного написания useMemo, useCallback и других оптимизаций.
105. Как React Compiler оптимизирует код?
	1. React Compiler автоматически мемоизирует компоненты и функции, удаляет ненужные ререндеры, оптимизирует пропсы и состояния. Он делает это на уровне компиляции, что более эффективно чем ручные оптимизации.

## Hooks

106. **Правила хуков**:
	1. Вызывайте их на верхнем уровне в теле компонента функции
	2. Вызывайте их на верхнем уровне в теле пользовательского хука
	3. Не вызывайте хуки внутри условий или циклов.
	4. Не называйте хуки после условного `return` оператора.
	5. Не вызывайте хуки в обработчиках событий.
	6. Не вызывайте хуки в компонентах класса.
	7. Не вызывайте хуки внутри функций, переданных в `useMemo`, `useReducer`, или `useEffect`

**useState**

107. Для чего нужен `useState`?
	1. Чтобы создать локальное состояние в функциональном компоненте.
108. Что возвращает `useState`?
	1. Массив из двух элементов: текущее значение и функция для его обновления
109. Как изменить состояние `useState`?
	1. Вызов setState(newValue) или setState(prev => computeNext(prev))
110. Как обновлять состояние на основе предыдущего значения?
	1. setState(prev => computeNext(prev))
111. Почему `setState` асинхронен, и как это влияет на обновления?
	1. batching группирует обновления, чтобы не делать лишнюю работу. Поэтому `state` не обновляется сразу после вызова `setState`.
112. Что произойдет, если вызвать `setState` с тем же значением?
	1. React использует `Object.is` для сравнения. Если значение не изменилось — ререндер не произойдёт.
113. Как работает shallow compare в `useState`?
	1. Shallow сравнение — `Object.is(prev, next)`. Для объектов и массивов — сравниваются только ссылки.
114. Как работает `useState` при повторных рендерах?
	1. React сохраняет значение в ячейке хука. Инициализация выполняется один раз — при первом рендере.
115. Как правильно обновлять состояние, если оно — объект или массив?
	1. Иммутабельно: setState(prev => ({ ...prev, updated: true }))
116. Почему нельзя вызывать `useState` условно?
	1. Потому что порядок вызовов хуков должен быть стабильным между рендерами
117. В чем отличие `useState` от `useReducer`?
	1. `useState` — для простого состояния. `useReducer` — для сложной логики и вложенных структур. `useReducer` даёт больше контроля и лучше масштабируетс
118. Как ведет себя `useState` при размонтировании компонента?
	1. Хук отрабатывает только при монтировании. После анмаунта `setState` ничего не делает.
119. Как сделать ленивую инициализацию состояния в `useState`?
	1. useState(() => computeExpensiveInitial())
120. В чем разница между `useState(someFunction())`, `useState(someFunction)`, `useState(() => someFunction())`?
	1. `someFn()` — вызов сразу, значение — результат.
	2. `someFn` — функция как значение, не вызовется.
	3. `() => someFn()` — ленивый вызов, только при первом рендере.
121. Можно ли мемоизировать `setState` с помощью `useCallback`?
	1. Можно, но не нужно.`setState` стабилен, ссылка не меняется.
122. Что произойдёт, если передать пропсы как начальное значение в `useState`, а затем эти пропсы изменятся?
	1. Ничего не произойдёт. Начальное значение читается **только при монтировании**. Для синхронизации с пропсами нужен `useEffect`.
123. Как синхронизировать значение useState с передаваемыми компоненту пропсами?
	1. Чтобы синхронизировать `state` с пропсами, нужно использовать `useEffect` с подпиской на нужные пропсы.
124. Что будет если useState при значении объекта через setState присвоить этот же объект.
	1. setObj((obj) => obj) - ничего не будет так как ссылка такая же.
	2. setObj((obj) => {...obj}) - произойдет перерендер так как ссылку уже будет другой.
125. Как избежать stale-значений при обновлении состояния в async-колбэках или таймерах?
	1. Использовать функциональный `setState(prev => ...)`
126. Почему `setState` внутри `useEffect` может зациклить рендер?
	1. Если `setState` вызывается без условий, и обновляемое состояние входит в `deps`, произойдёт бесконечный цикл
127. Как работает batching в React 18 и какие кейсы нарушают его (например, `setTimeout`, промисы)?
	1. React **batch'ит**  несколько вызовов `setState` в один ререндер
	2. после 18 версии  всё, что запущено внутри одного "tick" (микро/макрозадачи), будет батчиться.
	3. flushSync принудительно ререндерит компонент игнорируя batch(инг)


---

**useEffect** и useLayoutEffect

120. Для чего нужен `useEffect`?
	1. `useEffect` позволяет выполнять побочные эффекты
121. Когда вызывается `useEffect`?
	1. После рендера, **асинхронно**, уже после того как браузер нарисовал DOM.
122. какие параметры принимает useEffect?
	1. callback: () => void — основная функция с эффектом;
	2. `deps: any[]` — массив зависимостей (опционально)
123. Что возвращает useEffect?
	1. Ничего сам по себе (undefined). Но колбэк может вернуть **функцию очистки** — она вызовется при размонтировании или перед следующим выполнением эффекта.
124. Как работает массив зависимостей?
	1. React сравнивает зависимости (по `Object.is`). Эффект выполняется **только если хотя бы одна зависимость изменилась**. Если массив пустой — выполнится один раз при монтировании.
125. Что будет, если не указать зависимости?
	1. Эффект будет выполняться **после каждого рендера**
126. Как выполнить эффект только примонтировании?
	1. Передать пустой массив зависимостей:
127. Как использовать `useEffect` с асинхронными функциями?
	1. Нельзя сделать сам `useEffect` async, но можно в callback создать асинхронную функцию и вызвать ее
128. Что такое функция очистки (cleanup)?
	1. Это функция, которую может возвращать callback. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента.
	2. Используется для отмены подписок, таймеров, abort-controllers и т.п.
129. Когда вызывается функция очистки?
	1. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента.
130. Как отменять асинхронные операции в useEffect?
	1. AbortController для запросов
	2. флаг переменную 
131. Чем `useEffect` отличается от `useLayoutEffect`?
	1. `useEffect`: вызывается **асинхронно**, **после** рендера и отрисовки.
	2. `useLayoutEffect`: вызывается **синхронно**, **до** отрисовки браузером и может блокировать отрисовку.
136. Что такое "useEffect первого рендера" и "useEffect обновления"? Как их различать?
	1. **useEffect первого рендера**: выполняются один раз при монтировании (`useEffect(() => {...}, [])`).
	2. **useEffect обновления**: выполняются при изменении зависимостей (`useEffect(() => {...}, [a, b])`).
134. Как избежать гонки состояний (race conditions) в асинхронных эффектах?
	1. Используй `AbortController`, флаги `isMounted`
135. Почему нельзя делать `await` напрямую в `useEffect(callback)`?
	1. Потому что `useEffect` должен возвращать либо **undefined**, либо **функцию очистки**.  `async` функция **всегда возвращает Promise**, что нарушает контракт
136. Как правильно использовать эффекты с подписками на внешние источники (WebSocket, Observer, EventListener)?
	1. Создай подписку в `useEffect`
	2. Вернуть функцию очистки, чтобы отписаться при размонтировании или повторном вызове.
137. Что произойдёт, если не использовать функцию очистки при подписке?
	1. Повторные подписки → **дублирование событий**
	2. неактуальные колбэки
	3. **Утечка ресурсов**
138. Чем отличается порядок выполнения нескольких `useEffect` в одном компоненте?
	1. Они **выполняются сверху вниз**, в **порядке объявления**. Это важно, если между ними есть зависимость:
142. Как влияет Strict Mode на вызовы `useEffect` (дважды)? Как это влияет на эффекты с побочками?
	1. `useEffect` вызывается **дважды** (монтирование → размонтирование → повторное монтирование)
	2. Цель — поймать ошибки в **нечистых эффектов**, например, без `cleanup` 

---

**useRef**

147. Для чего нужен `useRef`?
	1. Также — для доступа к DOM-элементам.
	2. Чтобы хранить значения, которые **не вызывают ререндер** при изменении. 
148. Варианты использования useRef?
	1. Доступ к DOM
	2. Хранение значения между рендерами
	3. Предыдущее значение
	4. Флаг "монтирован"
	5. Таймеры, id, внешние инстансы
149. Как получить доступ к DOM-элементу с помощью `useRef`
	1. Прокинуть в атрибут ref html тега переменную которой присвоили useRef()
150. Что хранится в `.current`?
	1. В поле `.current` хранится **текущее значение**, которое  туда положили. По умолчанию — значение, переданное в `useRef(initialValue)`
151. Можно ли изменять `.current`?
	1. Да, через ref.current = newValue
152. Вызывает ли изменение `.current` перерендер?
	1. `useRef` не триггерит повторный рендер, в отличие от `useState`.
153. Как использовать `useRef` для хранения значений между рендерами?
	1. Любое значение присвоенное ref.current мутабельно, достпуно для использования и сохраняется между перерендерами.
154. Чем `useRef` отличается от `useState`?
	1. `useRef` не вызывает ререндер при изменении.
	2. `useState` — триггерит ререндер.
155. Как использовать `useRef` для хранения предыдущего значения?
	1. Любое значение присвоенное ref.current мутабельно, достпуно для использования и сохраняется между перерендерами.
156. Как `useRef` помогает избежать лишнего рендера в `onScroll`, `onResize` и других частых ивентах?
	1. При `onScroll`, `onResize` и подобных событиях **состояние часто обновляется**, но перерендер при каждом изменении — дорого. `useRef` позволяет **сохранять значения между рендерами**, не триггеря ререндер.
157. Можно ли использовать `useRef` как глобальный стейт? Почему это плохая идея?
	1. **Можно, но не нужно.** так как 
		1. `useRef` — **локален компоненту**
		2. не вызывает ререндер
		3. не реактивен — другие компоненты не узнают об изменении
158. Как связать `useRef` и `forwardRef` для передачи доступа к DOM наружу?
	1. `forwardRef` нужен, чтобы пробросить `ref` от родителя к DOM-элементу внутри компонента.
---

**useMemo**
159. Что такое `useMemo`?
	1. `useMemo` — это хук, который **мемоизирует результат вычисления** между рендерами, чтобы не пересчитывать заново, если зависимости не изменились
160. Какие аргументы принимает `useMemo`?
	1. Функция, которая возвращает значение
	2. Массив зависимостей (`deps`)
161. Что возвращает `useMemo`?
	1. Результат выполнения переданной функции — **мемоизированное значение**.
162. Когда применять `useMemo`?
	1. Дорогие вычисления
	2. Передача стабильной ссылки в зависимости
	3. Оптимизация рендеров дочерних компонентов
163. Когда `useMemo` бесполезен?
	1. Преждевременная мемоизация **нагружает память и CPU**.
	2. Если вычисление дешёвое
	3. Если часто меняются зависимости и значение всегда пересчитывается
	4. Если нет проблем с производительностью
164. Как работает мемоизация в `useMemo`?
	1. React **запоминает результат** выполнения функции
	2. При следующем рендере **сравнивает зависимости**
	3. Если зависимости **не изменились** (`Object.is`) — возвращает **кэш, иначе — **пересчитывает**
165. Что произойдёт, если не указать массив зависимостей?
	1. Функция будет **перевычисляться при каждом рендере**
166. Когда `useMemo` может навредить производительности?
	1. Если мемоизируется **дешёвая логика**
	2. Если зависимости часто меняются
	3. Если много `useMemo` — **меньше GC**, **больше памяти**
167. Как `useMemo` сравнивает зависимости (по ссылке или по значению)?
	1. По ссылке, через `Object.is()`:
168. Как `useMemo` ведёт себя в React Concurrent Mode?
	1. В Concurrent Mode `useMemo` ведёт себя также, как и другие React-хуки: результат мемоизации сохраняется **только после коммита**. Если рендер был прерван, результат `useMemo` **не сохраняется**, и при следующем рендере функция будет вызвана снова
169. Чем `useMemo` отличается от мемоизации вне React (например, lodash.memoize)?
	1. `useMemo` — это **hook**, встроенный в React-цикл рендеринга и зависящий от зависимостей и жизненного цикла компонента. Он **автоматически сбрасывается** при размонтировании компонента.  
	2. В отличие от него, `lodash.memoize` — это **императивная мемоизация**, работающая вне контекста React и требующая ручного контроля над кэшем. Она сохраняет результат в глобальном или внешнем кэше и не зависит от ререндеров.
170. Как `useMemo` влияет на память и сборку мусора?
	1. Каждый `useMemo` сохраняет результат в кэше до тех пор, пока компонент не размонтируется или зависимости не изменятся. Если `useMemo` используется без нужды (например, для дешёвых вычислений), это может **увеличить потребление памяти**, замедлить сборку мусора и создать **лишнюю нагрузку на CPU** из-за отслеживания зависимостей
171. Как `useMemo` взаимодействует с Suspense?
	1. В режиме Suspense, если рендер компонента прерывается из-за "зависания" на промисе (например, в data fetching), `useMemo` работает аналогично Concurrent Mode: результат **не кэшируется**, пока не произойдёт успешный коммит. Это значит, что функция в `useMemo` может вызываться **повторно** при каждом новом рендере, до тех пор, пока Suspense не завершит ожидание.
172. Какие ошибки возникают при неправильном указании зависимостей?
	1. Если зависимости `useMemo` указаны неправильно (например, не указаны значения, от которых зависит вычисление), могут возникнуть **баги со stale values**: мемоизированное значение будет пересчитываться реже, чем нужно, и может стать **неактуальным**. Это приводит к неконсистентному UI, неверным данным или логике.

---

**useCallback**

173. Что такое `useCallback`?
	1. `useCallback` — это хук, который **мемоизирует функцию**, чтобы она сохраняла **стабильную ссылку** между рендерами, если не изменились зависимости.
174. Какие аргументы принимает `useCallback`?
	1. Колбэк-функция (возвращается как есть, **не вызывается**)
	2. Массив зависимостей
175. Что возвращает `useCallback`?
	1. Мемоизированную функцию
176. Когда применять `useCallback`?
	1. Когда нужно **передать функцию в memoized-компонент**
	2. В `useEffect` / `useMemo` / `setInterval` — когда функция зависит от стабильности ссылки
	3. Для оптимизации компонентов, избегающих лишнего рендера по ссылке на колбэк
177. Когда `useCallback` бесполезен?
	1. Если компонент не зависит от стабильности функции
	2. Если функция пересоздаётся каждый раз из-за нестабильных зависимостей
	3. Если перерисовки и так дешёвые
178. Что будет, если функция в useCallback зависит от внешних значений, а они не указаны в зависимостях?
	1.  баг: внутри функции будут **устаревшие значения** (stale closure).
179. Чем отличается `useCallback` от `useMemo`?
	1. useCallback
		1. Мемоизирует **функцию**
		2. Возвращает саму функцию
	2. useMemo
		1. Мемоизирует **значение**
		2. Возвращает результат вызова
180. Когда стоит предпочесть `useCallback` вместо обычной функции?
	1. Когда функция **передаётся вниз** (в props) и нужно **избежать лишнего рендера** дочернего `React.memo` компонента
	2. Когда функция участвует в **зависимостях эффекта**, и  нужна **стабильная ссылка**
181. можно ли заменить useCallback c помощью useMemo?
	1. Да. но не рекомендуется из-за неочевидности:
182. Как избежать stale closure (устаревших значений) при использовании `useCallback`?
	1. Чтобы избежать stale closure, необходимо указывать в массиве зависимостей все значения, на которые ссылается колбэк: пропсы, стейт и любые переменные из внешней области. Это гарантирует, что функция будет пересоздана при изменении нужных данных и всегда работать с актуальными значениями.**
183. Как `useCallback` работает в Concurrent Mode?
	1. `useCallback` — не сохраняется между прерванными рендерами, пока не завершится коммит.
	2. Но после успешного коммита, возвращаемая функция будет **стабильна**, если зависимости не поменялись.
184. Почему нельзя мемоизировать колбэк с пустым массивом зависимостей, если внутри используются пропсы/стейт?
	1. Пустой массив зависимостей фиксирует колбэк навсегда после первого рендера. Если в теле функции используются внешние значения, они будут захвачены однажды и больше не обновятся. Это приведёт к использованию устаревших данных и нарушит ожидаемое поведение компонента.
185. Можно ли комбинировать `useCallback` с `useMemo`? В каких случаях?
	1. Комбинация возможна и уместна, когда требуется создать мемоизированную структуру, содержащую функции, и сохранить стабильность всей структуры между рендерами.
186. Чем `useCallback` отличается от простого объявления функции внутри компонента?
	1. Функция, объявленная внутри компонента без `useCallback`, пересоздаётся при каждом рендере и всегда имеет новую ссылку. `useCallback` позволяет сохранить ссылку на функцию между рендерами при условии, что зависимости не изменились


---

**useId**

187. Для чего используется `useId`?
	1. нужен для генерации **уникального, стабильного ID**, который синхронизируется между сервером и клиентом. 
	2. полезен для привязки `label` ↔ `input`, `aria-describedby`, и в компонентах, рендерящихся и на сервере, и на клиенте.
188. Как работает `useId`?
	1. React генерирует **уникальный, стабильный префикс** независимо от количества ререндеров
189. можно ли использвоать хук useId в серверных компонентах?
	1. Да. `useId` **безопасен для Server Components** и работает и на сервере, и на клиенте. Это одна из его задач — **избежать mismatch при гидратации**
190. Как `useId` помогает при серверном рендеринге (SSR)?
	1. `useId` гарантирует **одинаковый ID** на обеих сторонах (в отличии от `Math.random()`, `uuid`), потому что React сам контролирует генерацию и встраивает метаданные в HTML.
191. В чём отличие `useId` от генерации ID через `Math.random()` или другие способы?
	1. Стабильный между рендерами
	2. Работает при SSR-гидратации
	3. безопасен для accessibility
192. Можно ли использовать `useId` для генерации ключей в списках?
	1. **Нет.** Ключи в списках должны быть **детерминированы по данным**, иначе при изменении порядка или количества элементов React будет **пере-монтировать** всё.
193. Что будет, если использовать `useId` в компоненте, который ререндерится много раз?
	1. `useId` стабилен — он выдаёт **одно и то же значение** между рендерами, пока компонент не размонтируется.
194. Какие проблемы решает `useId` в контексте accessibility?
	1. Для доступности важно, чтобы `label` имел `htmlFor={id}`, а `input` — `id={sameId}`. Если ID разные на сервере и клиенте — атрибут `for` указывает не туда → **screen reader не сможет связать label и поле**. `useId` даёт **одинаковый ID** и решает эту проблему.
195. Как `useId` ведёт себя при гидратации SSR?
	1. React знает, как синхронизировать ID, сгенерированные на сервере и клиенте, чтобы избежать ошибок.  Это происходит через встроенные маркеры в HTML, которые позволяют React **восстановить правильный state без mismatch**.
196. Как `useId` генерирует ID в конкурентном режиме?
	1. `useId()` генерирует **стабильный уникальный ID**, который:
	2. **Не зависит от порядка рендера** и не сбивается даже при конкурентных прерываниях (`concurrent rendering`), т.к. не использует счётчики, как `useRef` или инкремент.
197. Есть ли ограничения по количеству вызовов `useId` в одном компоненте?
	1. Нет, **жёстких ограничений нет** —  можно вызывать `useId` сколько угодно раз и каждый вызов `useId()` вернёт **уникальный ID**, даже в одном компоненте.
198. Как `useId` ведёт себя при гидратации в SSR с использованием React Suspense?
	1. - **React гарантирует**, что `useId()` возвращает **одинаковое значение** на сервере и клиенте. Это особенно важно при использовании `Suspense`, где часть дерева может быть отложена, что **меняет порядок вызова хуков**.
	2. ID детерминированный, стабилен даже при `Suspense`, `startTransition`, и других асинхронных рендерах.

---


**useContext**

199. Для чего нужен `useContext`?
	1. Чтобы получать значение из контекста
200. Как создать и экспортировать контекст в React?
	1. export const ThemeContext = React.createContext(null);
201. Как использовать `useContext` для получения значения из контекста?
	1. const theme = useContext(ThemeContext);
202. Можно ли использовать `useContext` вне компонента? Почему?
	1. Нельзя. `useContext` — это хук, он должен вызываться **внутри функционального компонента** или другого хука
203. Как `useContext` работает при обновлении значения в провайдере?
	1. Если значение контекст меняется, **все потомки**, использующие `useContext`, **перерисуются**.  
	2. React сравнивает по `Object.is`.
204. Как избежать лишних рендеров при использовании `useContext`?
	1. Мемоизировать value
	2. Разделить контексты: один для данных, другой для диспатча (Pattern: `StateContext` + `DispatchContext`)
	3. Вынести `useContext` ближе к месту, где нужен
205. Можно ли использовать несколько контекстов одновременно? Как это делать?
	1. Да. Просто вложив провайдеры друг в друга
206. Когда использовать `useContext`, а когда — глобальные стейты типа Redux или Zustand?
	1. Используй `useContext` для **UI-состояния и небольших кусков**, Redux/Zustand — если **данные масштабируются и делятся между многими частями приложения**.
207. Как работает `useContext` с серверным рендерингом (SSR)?
	1. unknow
208. Какие ограничения и подводные камни есть у `useContext`?
	1. Все потребители перерисуются при **любом изменении value**
	2. Плохая производительность при больших объектах в value
	3. Нельзя вызывать вне компонента
	4. Мутирование объекта в value не вызовет ререндер
209. Как работает обновление контекста при вложенных провайдерах с одинаковым типом?
	1. Если компонент обернут во **вложенные `<Context.Provider>` одного и того же контекста**, то `useContext(Context)` всегда читает **ближайший вверх по дереву** `Provider`
210. Как `useContext` влияет на производительность в больших приложениях?
	1. при **любом изменении value** в `Provider`, все компоненты, читающие этот контекст (через `useContext`), **перерисовываются**, даже если они используют только часть value.
	2. Это связано с тем, что React делает сравнение по `Object.is(value)` на уровне `Provider`.
211. Как обрабатывать ошибки при чтении контекста вне провайдера?
	1. Создай обёртку-хук:
	2. function useStrictContext() {
		  const context = useContext(MyContext);
		  if (!context) {
	    throw new Error('useMyContext должен вызываться внутри <MyContext.Provider>');
		  }
		  return context;
		}
212. Какие альтернативы `useContext` для глобального состояния и когда их лучше применять?
	1. Zustand, Redux + RTK, Recoil
	2. `useContext` хорошо работает для:
		1. UI-состояния
	    2. локальных настроек
		3. небольшого шаринга между родителем и потомками

---

**useReducer**

213. Что такое `useReducer` и для чего он нужен?
	1. Это хук для управления **сложным или предсказуемым состоянием**
214. Какие параметры принимает useReducer?
	1. `reducer`: Редюсер — чистая функция, которая определяет логику обновления состояния. Редюсер принимает два аргумента – состояние и действие, и возвращает следующее состояние. Состояние и действие могут быть любых типов.
	2. `initialArg`: Значение на основе которого вычисляется начальное состояние. Значение начального состояния может быть любого типа. То как из него будет вычисляться начальное состояние, зависит от аргумента `init`.
	3. `init`:(jgwbjyfkmyj) Функция инициализатора, которая возвращает начальное состояние. Если она не указана, то начальное состояние устанавливается в `initialArg`. В противном случае начальное состояние устанавливается в результат вызова `init(initialArg)`.
215. Чем отличается `useReducer` от `useState`?
	1. `useState` → императивный: напрямую задаёшь новое значение
	2. `useReducer` → декларативный: ты диспатчишь событие (`dispatch(action)`), и **редьюсер решает**, как изменится состояние.
	3. `useReducer` легче масштабировать
216. Как устроена редьюсер-функция? Какие параметры она принимает?
	1. Редьюсер — это чистая функция:
	2. (state, action) => newState, где 
		1. `state` — текущее состояние.
		2. `action` — объект, описывающий событие
	3. Возвращает новое состояние. Не мутирует предыдущее.
217. Что возвращает `useReducer`?
	1. Массив из двух значений: 
		1. - `state` — текущее состояние.
		2. `dispatch` — функция, которая запускает редьюсер.
218. Что такое функция dispatch?
	1. `dispatch(action)` — это функция, которая передаёт `action` в редьюсер и вызывает пересчёт нового состояния.
219. Как задать начальное состояние и как сделать ленивую инициализацию?
	1. через initFn
	2. `initialArg` — любое значение (можно `undefined`).
	3. `initFn(initialArg)` - возвращает **начальное состояние** (вызывается один раз).  
220. Как работает dispatch? Можно ли вызывать dispatch асинхронно?
	1. `dispatch` **синхронно ставит обновление в очередь**, но **перерендер происходит асинхронно** (в batched-режиме React).
	2. `dispatch` сам не поддерживает `async/await`, но  можно вызывать его из `useEffect`, `async function`, `setTimeout` и т.д.
221. Как использовать `useReducer` с асинхронными операциями?
	1. Асинхронность обрабатывается **вне редьюсера**, а сам редьюсер — синхронный.
222. Как использовать `useReducer` вместе с `useContext` для глобального стейта?
	1. Создаёшь контекст, в который кладёшь `[state, dispatch]`.
	2. Оборачиваешь `Context.Provider` вокруг `<App>`.
	3. Любой компонент может использовать `useContext(Context)` - получает `state` и `dispatch`.
223. Как React 18+ улучшает работу с `useReducer` (например, конкурентный режим и приоритеты обновлений)?
	1. Обновления через `dispatch` теперь участвуют в **automatic batching**.
224. Что происходит, если вызвать dispatch после размонтирования компонента?
	1. Никакой ошибки не будет, но `dispatch` вызовет **ничего** — компонент уже не существует.
	2. Решение — проверять `isMounted` через `useRef` или отменять побочные эффекты в `cleanup`.
225. Почему редьюсер должен быть чистой функцией? Какие проблемы возникают при мутации?
	1. Редьюсер обязан быть чистой функцией, потому что React полагается на **сравнение по ссылке**, чтобы понять, произошло ли изменение состояния.Если  внутри редьюсера мутировть объект, но возвращать ту же ссылку, React не задетектит изменения и не перерендерит компонент
226. Как избежать вызова dispatch после размонтирования компонента?
	1. В `useEffect` можно установить флаг при монтировании и сбросить его в `cleanup`
	2. Перед вызовом `dispatch` проверять этот флаг.
227. Можно ли использовать несколько редьюсеров в одном компоненте?
	1. Да, можно, каждый `useReducer` управляет своей частью данных и не зависит от других.
228. Как обновлять части состояния, если state — объект или массив, чтобы избежать мутаций?
	1. Вместо мутаций  создавать новую версию объекта или массива, копируя неизменённые части.
229. В чём различия между `useReducer` и Redux-подходом?
	1. `useReducer` — это локальный инструмент, предназначенный для управления сложным состоянием внутри одного компонента или изолированной части UI. Redux — это глобальный store, ориентированный на управление состоянием всего приложения

-----
### useTransition

230. Что делает `useTransition` и как отличить его поведение от обычного обновления?
	1. Что делает `useTransition` и как отличить его поведение от обычного обновления?
	2. без `startTransition` обновление блокирует весь рендер; с `startTransition` — UI может обновить критичные части сразу, а "тяжёлые" позже.
231. Как `startTransition` влияет на приоритет обновлений в React?
	1. React снижает приоритет запускаемых внутри `startTransition` обновлений до `TransitionLane` (в React scheduler), т.е. это **concurrent** и **прерываемые** обновления, в отличие от синхронных (`DefaultLane`, `SyncLane`) — они могут быть отложены, отменены или заблокированы `Suspense`
232. Что происходит, если вызвать `startTransition` внутри уже идущего `startTransition`?
	1. Никакого дополнительного эффекта не будет — вложенные `startTransition` **не стекуются** и не создают вложенные транзакции. Все вложенные обновления также будут иметь `TransitionLane`, то есть они остаются низкоприоритетными
233. Как React решает, когда прервать отложенный ререндер?
	1. React при рендере следит за временем через **cooperative scheduling**. Если текущий `Transition`-рендер занимает слишком много времени (time slicing), он может быть прерван, чтобы отрендерить более приоритетные обновления (например, input). После прерывания может быть запущен повторный render с учётом новых данных.
234. Как `isPending` синхронизирован между render-фазами?
	1. `isPending` — это **значение, возвращаемое из `useTransition`**, оно обновляется при старте и завершении transition-обновлений. Он не гарантирует точное состояние рендера, так как обновляется **асинхронно** и может **отставать** на один тик. Это флаг для **UI-индикации**, не для логики.
235. Как отменяется отложенное обновление, если пришёл новый input?
	1. Если во время transition приходит новый input, React **прерывает** текущий рендер и **перезапускает** его с актуальными данными. Предыдущая версия не применяется. Это возможно благодаря тому, что transition — **прерываемый render**
236. Почему `useTransition` не вызывает повторного рендера сразу?
	1. Обновления внутри `startTransition` попадают в очередь с низким приоритетом. React может **отложить их выполнение**, если есть более важные дел
237. Как `useTransition` взаимодействует с `Suspense`?
	1. Если отложенное обновление внутри `startTransition` приводит к загрузке (`<Suspense>` fallback), React отрендерит fallback UI. Так как это transition, fallback будет **временным**, и пользователь может продолжать взаимодействие.
238. Как работает с `React.memo` и влияет ли отложенное состояние на `props` сравнение?
	1. сли переданные props приходят из `useDeferredValue` или `useTransition`'а (через state), то `React.memo` сравнивает их обычным `shallowEqual`.
    
### useDeferredValue

240.  Что делает `useDeferredValue` и в чём отличие от `useTransition`?
	1. `useDeferredValue(value)` возвращает отложенную версию `value`, которая обновляется с низким приоритетом.
	2. В отличие от `useTransition`, который оборачивает _setState_, `useDeferredValue` применяется к _уже вычисленному значению_.
241. Что произойдёт, если `useDeferredValue` применяется к `primitive`, `object`, `array`, `function`?
	1. useDeferredValue Работает с любыми типами.
	2. для объектов/массивов/функций важно, что сравнение идёт по **ссылке**, не по содержимому
242. Как работает сравнение значений `prev` vs `deferred` – shallow или deep?
	1. React сравнивает **по ссылке (reference equality)**
243. Когда `useDeferredValue` может **не вызвать** повторного рендера?
	1. Когда `value` изменился, но новое значение `===` предыдущему (для примитивов — по значению, для объектов — по ссылке).
	2. Также, если `deferredValue` всё ещё "догоняет" старое значение и не успел обновиться
244. Как работает с `React.memo` — что попадёт в `areEqual(prevProps, nextProps)`?
	1. `React.memo` сравнивает `deferredValue`, а не оригинальный `value`
245. Что происходит, если исходное значение меняется чаще, чем deferred успевает обновиться?
	1. `deferredValue` может "зависнуть" на старом значение
	2. React **может пропустить промежуточные значения** и применит только последнее, когда появится «окно» времени.
	3. Это поведение делает его похожим на **автоматический дебаунс**.
246. Как использовать `useDeferredValue` с Suspense и `fallback` UI?
	1. `useDeferredValue` можно применять к **данным, загружаемым через Suspense**.
	2. Отложенный переход позволит сначала показать `fallback`, не блокируя основной поток.
	3. Часто комбинируется с `useMemo` и `React.lazy`.
247. Может ли `useDeferredValue` вызывать tearing или лаги?
	1. да, если `value` и `deferredValue` попадают в разные рендеры компонентов
	2. Важно избегать чтения `value` и `deferredValue` одновременно в одном компоненте, чтобы не получить рассинхрон.
    
###  useSyncExternalStore
248. Что делает `useSyncExternalStore` и в каких случаях он необходим?
	1. `useSyncExternalStore` — это хук React, позволяющий синхронизировать состояние React-компонента с **внешним** (не React) стором или API.  
	2. Eго основная задача — гарантировать, что подписка и чтение состояния извне происходит **синхронно** и **без рассинхронизации**, особенно важно для Concurrent Mode и SSR.
249. Какие аргументы принимает useSyncExternalStore и что он возвращает?
	1. **subscribe** — функция подписки на изменения внешнего стора. Она принимает коллбек, который вызывается при изменении данных, и возвращает функцию отписки.
	2. **getSnapshot** — функция, которая синхронно возвращает актуальный снимок (snapshot) состояния из стора. React вызывает её при рендере, чтобы получить текущее состояни
	3. **getServerSnapshot?** — опциональная функция, которая возвращает snapshot для серверного рендера. Используется при SSR для генерации начального состояния, чтобы клиент и сервер были синхронизированы.
	4. возвращает текущее состояние (snapshot), которое получено из `getSnapshot` (или из `getServerSnapshot` при серверном рендере)
250. Почему нельзя использовать `useState`/`useEffect` для подписки на внешний store?
	1. `useState` + `useEffect` создают **асинхронные обновления**, которые могут привести к рассинхронизации UI,
	2. При SSR `useEffect` не вызывается, поэтому компонент на сервере и клиенте может получить разное состояние
	3. React не может гарантировать согласованность между рендером и подпиской
251. Какие проблемы решает useSyncExternalStore?
	1. Обеспечивает, что React читает актуальное состояние _синхронно_ во время рендера
	2. Позволяет корректно подписываться на внешние изменения и автоматически отписываться при размонтировании или изменении подписки
	3. Обеспечивает согласованность состояния между серверным рендером и клиентской гидрацией.
252. Как работает `getSnapshot` и когда он должен быть стабилен?
	1. - `getSnapshot` — функция, которая возвращает текущее значение из внешнего стора.
	2. Она должна быть **чистой и стабильной**: при отсутствии изменений — возвращать одно и то же значение (сравнение через `Object.is`).
	3. Если данные в сторе не изменились — возвращать **тот же объект/примитив** , чтобы избежать лишних ререндеров.
	4. Если `getSnapshot` возвращает новый объект при каждом вызове — React будет ререндерить компонент бесконечно.
253. Что произойдёт, если `getSnapshot` возвращает новое значение при каждом вызове?
	1. приведёт к бесконечному циклу ререндеров
254. Как работает подписка — синхронно или асинхронно?
	1. Подписка через `subscribe` вызывается **синхронно** при изменениях в сторе
	2. React при получении уведомления вызывает `getSnapshot` и запускает ререндер.
	3. Подписка должна возвращать функцию отписки.
255. В чём разница между `subscribe` и `getSnapshot` по таймингу?
	1. `subscribe` — устанавливает **слушателя изменений**. Вызывается один раз при монтировании или обновлении хука. `subscribe` говорит React, когда вызвать `getSnapshot`.
	2. `getSnapshot` — вызывается **при каждом рендере** и при оповещении о событии изменения, чтобы получить актуальное значение.
256. Как работает SSR-поддержка через `useSyncExternalStoreWithSelector`?
	1. В SSR используется третий аргумент `getServerSnapshot` — возвращает начальное значение стора на сервере.
	2. При SSR `getServerSnapshot` вызывается только на сервере и при гидрации клиента.
	3. Если `getServerSnapshot` не передан, SSR рендер выбросит ошибку.
257. Что происходит, если snapshot меняется во время рендера?
	1. React запускает **повторный рендер**
	2. Это связано с Concurrent Mode: React может дважды вызвать `getSnapshot` — перед и после применения изменений.
258. Какие ошибки возникают при нестабильном snapshot или unsubscribe?
	1. Бесконечные ререндеры.
	2. Если `subscribe` объявлен внутри компонента и меняется на каждом рендере, React будет **переподписываться** слишком часто, снижая производительность.
	3. Неправильный unsubscribe привядищй к утечке
    
### useInsertionEffect
259. Чем `useInsertionEffect` отличается от `useEffect` и `useLayoutEffect`?
	1. `useInsertionEffect` вызывается — до того, как React вставит DOM-узлы и выполнит `useLayoutEffect`**. Это самый ранний эффект, нужен для синхронной вставки стилей перед любой отрисовкой.
260. Почему `useInsertionEffect` нужен для библиотек CSS-in-JS ?
	1. `useInsertionEffect` позволяет вставить стили **до запуска любых layout-эффектов**, тем самым гарантируя, что компоненты отрендерятся уже с правильными стилями.
261. Что произойдёт, если внутри `useInsertionEffect` сделать `setState`?
	1. React бросит ошибку или предупредит, потому что вызов обновления состояния в `useInsertionEffect` может привести к бесконечным циклам рендера и рассинхронизации фаз рендера.
	2. `useInsertionEffect` предназначен только для побочных эффектов, не меняющих состояние компонента.
262. Почему нельзя читать DOM внутри `useInsertionEffect`?
	1. В момент вызова `useInsertionEffect` DOM **ещё не обновлён** новым рендером.
	2. Чтение DOM может вернуть устаревшие данные или привести к ошибкам, поскольку React только начинает фазу commit, но ещё не применил изменения к DOM.
263. Как `useInsertionEffect` влияет на порядок вставки CSS и приоритет specificity?
	1. `useInsertionEffect` гарантирует, что стили вставляются **раньше всех других эффектов**, включая `useLayoutEffect`. Это обеспечивает правильный порядок `<style>`-тегов в `<head>`, что важно для корректного применения CSS-правил с нужным приоритетом (specificity).
264. Что произойдёт, если `useInsertionEffect` недоступен (например, SSR)?
	1. `useInsertionEffect` **не вызывается на сервере**, так как там нет DOM.
    
### useImperativeHandle
265. Как работает `useImperativeHandle` и зачем он нужен?
	1. позволяет **кастомизировать объект**, который родитель получит через `ref`.
266. Почему важно передавать второй аргумент в `forwardRef`, а не использовать `useRef` напрямую?
	1. В React 18 и ниже `ref` **не приходит как проп** — его нужно явно проксировать через `forwardRef`
	2. в React 19 forwardRef не нужен и ref можно прокидывать обычным пропсом
267. Можно ли в `useImperativeHandle` возвращать функции, которые используют stale props/state?
	1. Да, можно, **если правильно указать зависимости**:
268. В каких случаях стоит избегать `useImperativeHandle` вообще?
	1. Нет необходимости **инкапсулировать доступ к DOM**.
	2. Нужное поведение — **декларативное**, а не императивное.
	3. Применяется, когда это единственный способ выразить поведение: scroll, focus, animation trigger и т.д.
269. Что произойдёт, если ref в `forwardRef` null или изменится тип?
	1. Если `ref === null`, `useImperativeHandle` **не выполнится** — React ничего не запишет.
	2. Если `ref` изменит тип (например, с `useRef()` на колбэк-реф), React:
		1. сначала вызовет `cleanup` предыдущего handle (если был),
		2. потом вызовет `createHandle` для нового рефа.
    
### useDebugValue
270. Как работает `useDebugValue` и влияет ли он на продакшн-бандл?
	1. `useDebugValue(value, formatFn?)` — это хук, который используется **исключительно для отладки** в React DevTools.
	2. **не влияет на поведение компонента**, **не вызывает побочные эффекты**, удаляется на продакшн-сборке
### useEvent (not released)
- Что делает `useEvent` и чем он отличается от `useCallback`?
- Почему `useCallback` не всегда решает проблему stale замыканий?
- Как `useEvent` сохраняет reference на последнюю версию функции без пересоздания?
- В чём польза `useEvent` при подписке на DOM-события или глобальные обработчики?
- Как работает под капотом — через ref или proxy?
- Может ли `useEvent` быть использован как dependency для других хуков?
- Поддерживает ли `useEvent` серверный рендеринг?
### useOptimistic
271. Что делает `useOptimistic` и как он связан с Server Actions?
	1. `useOptimistic(state, updateFn)` позволяет **временно подменять state** UI-объектом, отражающим предполагаемый результат **асинхронного действия**, пока оно не завершится.
	2. `useOptimistic` позволяет **сразу обновить UI**, пока Server Action выполняется.
	3. После завершения Server Action (успешного или с ошибкой), произойдёт **сброс optimistic state**, и UI обновится с новыми реальными данными
272. Как выглядит типичная схема: optimistic update → реальный результат → reconcile?
	1. Пользователь отправляет данные
	2. `addOptimistic(message)` вызывается, UI сразу обновляется через `updateFn`
	3. В фоне стартует Server Action (или любой async logic).
	4. Когда async завершился:
		1. Если SSR — сервер возвращает новый state.
		2. Если CSR — клиент получает новые данные.
	5. UI «reconciles» — т.е. **сбрасывается `optimisticState` → `state`**
273. Как отменить optimistic state при отмене запроса или ошибке?
	1. Нет прямого API для отмены optimistic update вручную — React **автоматически сбрасывает** optimistic state
		1. произойдёт новый render с обновлённым `state` (например, после fetch),
		2. компонент размонтируется.
274. Можно ли использовать `useOptimistic` без `form` и `Server Actions`?
	1. Да. `useOptimistic` — **универсальный** хук, он не зависит от `form` или Server Actions, может использоваться в `startTransition`, `onClick`, `onSubmit`, внутри обычного async-обработчика.
275. Что произойдёт, если optimistic value конфликтует с новым реальным state?
	1. При следующем ререндере UI **заменит optimistic state новым `state`**, полученным извне
	2. Конфликтов не будет — **`useOptimistic` не делает дифф** между ними.
276. Как влияет на Suspense или Concurrent rendering?
	1. `useOptimistic` **полностью совместим с Concurrent Mode**.
	2. Он **может использоваться внутри `startTransition`** для немутирующего UI-обновления.
	3. Работает как **low-priority render**, не блокируя основной рендер.
	4. Если используется в дереве с `<Suspense>`, то optimistic UI отрендерится **до suspense-фолбека**.
277. Как работает `updateFn` и почему важно возвращать новый объект, а не мутировать?
	1. `updateFn(state, optimisticValue)` должен возвращать **новый state**.
	2. React ожидает **иммутабельность** — мутирование `state` не вызовет правильного рендера и может сломать работу.
278. Может ли `useOptimistic` быть использован с внешними state management (Redux/Zustand)?
	1. Да, но `useOptimistic` — **локальный хук**, он не управляет внешним хранилищем.
	2. Он **не должен напрямую мутировать Zustand/Redux state**.
	3. Оптимистичное состояние может быть только для UI, а после успешного запроса обновляется реальный стор:
    
### useActionState

279. Чем `useActionState` отличается от обычного `useState` + `useEffect`?
	1. `useActionState` объединяет в себе управление локальным состоянием и вызов асинхронной формы-ориентированной функции (action), обновляя состояние по результату action.
	2. В отличие от `useState` + `useEffect`, где нужно вручную слушать изменения и обновлять состояние, `useActionState` автоматически синхронизирует состояние с результатом последнего вызова action.
280. Для чего нужен useActionState?
	1. Управление состоянием, которое обновляется в результате отправки формы или вызова асинхронного action.
	2. Синхронизация UI с результатом серверной функции (Server Action) при прогрессивной гидратации и взаимодействии.
	3. Облегчение написания интерактивных форм и асинхронных действий без громоздких эффектов.
281. Какаие аргмуенты принимает useActionState?
	1. - `actionFn`: асинхронная функция или Server Action, вызываемая при отправке формы. Получает первым аргументом текущий (или предыдущий) state, затем formData.
	2. initialState начальное значение состояния до первой отправки формы.
	3. permalink (опционально): URL для прогрессивного улучшения на динамических страницах (редиректы до гидратации).
282. Что возвращает useActionState?
	1. Состояние (`state`) — это значение, которое возвращает переданная функция после выполнения. Изначально оно равно `initialState`, а потом обновляется при каждом вызове.
	2. Функция действия (`action`) — обёртка над твоей функцией. Её можно передать как `action={...}` в форму или вызывать вручную. Она принимает `formData` и вызывает переданную функцию с `prevState` и `formData`.
	3. Флаг `isPending` — указывает, выполняется ли сейчас `action`. Автоматически становится `true` при запуске и `false` после завершения, даже если внутри используется `await`.
283. Как `useActionState` помогает обрабатывать формы и асинхронные действия?
	1. Возвращает изменяемый `state`, который отражает результат последнего выполненного action.
	2. Возвращает модифицированный action (`formAction`), который следует использовать в `<form action={formAction}>` или в кнопке с `formAction`.
	3. Автоматически управляет состоянием ожидания (`isPending`) для UI.
	4. Обновляет `state` после завершения action, вызывая ререндер компонента
284. Что делает `action(prevState, formData)` и как использовать `formData` внутри?
	1. `action` — функция с подписью `(prevState, formData) => newState | Promise<newState>`.
	2. `prevState` — текущее состояние формы/компонента до отправки.
	3. `formData` — объект `FormData` с данными формы, передаваемый при отправке.
	4. Внутри `action` можно обрабатывать `formData`, вычислять новое состояние на основе предыдущего, возвращать результат синхронно или асинхронно.
285. Как работает взаимодействие с `Server Actions`?
	1. При использовании с Server Actions `useActionState` позволяет получить результат выполнения серверной функции и сразу обновить локальное состояние.
	2. При этом форма может быть интерактивной до полной гидратации, так как React уже знает, как обновлять состояние на основе ответа сервера.
	3. - `permalink` позволяет задать URL для прогрессивного улучшения на серверных маршрутах.
286. Что происходит, если action возвращает ошибку — влияет ли это на UI?
	1. Если action выбрасывает ошибку (reject), `useActionState` не обновит состояние.
	2. Ошибка не перехватывается внутри хука — нужно обрабатывать её вручную (например, try/catch внутри action или обрабатывать ошибки глобально).
	3. В UI состояние останется прежним, и `isPending` перейдёт в `false`.
	4. Для отображения ошибок лучше использовать отдельный state или структуру данных, возвращаемую из action.
287. Можно ли вызвать `setState` внутри `action` напрямую?
	1. Нет. `action` — чистая функция, которая должна возвращать новое состояние.
	2. Вызовы локальных React setState вне компонента из action невозможны.
	3. Все обновления состояния происходят через возвращаемое значение action и механизм `useActionState`.
288. Как сбрасывается state, если отправка формы отменена или изменилась?
	1. Если отправка отменена (например, переход на другую страницу), состояние `useActionState` остаётся текущим до следующей успешной отправки.
	2. Если меняется `initialState` при повторном рендере, он игнорируется после первого действия — состояние сохраняется между отправками.
	3. Для сброса состояния нужно либо использовать отдельную логику, либо заново размонтировать компонент
289. Как `useActionState` влияет на retry, Suspense и optimistic UI?
	1. `useActionState` автоматически обновляет состояние по результату action, что упрощает retry — достаточно повторить вызов action.
	2. Поддержка Suspense и progressive hydration реализуется через серверные механизмы React и Server Actions.
	3. Для сложного optimistic UI лучше использовать `useOptimistic` или сторонние подходы, так как `useActionState` ориентирован на результат action, а не промежуточное состояние.
290. как синхронизировать состояния state у useActionState с пропсами
	1. `useActionState` не синхронизируется с пропсами автоматически. Он использует `initialState` только **один раз при инициализации** и больше не реагирует на его изменени
	2. Для синхронизации с внешними данными (пропсами или глобальным стором) нужно либо использовать локальный `useState` и синхронизировать его вручную через `useEffect`, либо вообще не использовать `useActionState` и управлять стейтом внешне


---

## ПОЛНЫЙ СПИСОК ВОПРОСОВ

### 1. Virtual DOM и Reconciliation
1. Что такое Virtual DOM?
2. Как работает Virtual DOM?
3. Что может спровоцировать обновление Virtual DOM?
4. Где работает Virtual DOM?
5. Из чего состоит Virtual DOM?
6. Почему Virtual DOM эффективнее прямых манипуляций с DOM?
7. Как работает алгоритм **diffing** в React для сравнивания изменения в Virtual DOM?
8. Как ключи (`key`) влияют на процесс сравнения элементов?

### 2. Fiber Architecture
9. Что такое React Fiber и чем он отличается от Stack Reconciler?
10. В чем минусы Virtual DOM над Fiber?
11. Почему Fiber использует связный список, а не рекурсивный обход?
12. Как работает связный список в контексте Fiber?
13. Что такое FiberNode и как он устроен?
14. Какие ключевые поля содержит объект FiberNode и что каждое из них означает?
15. Как взаимодействуют FiberNode поля `return`, `child` и `sibling` для обхода дерева Fiber без рекурсии?
16. Какие бывают типы флагов (`flags`) в `FiberNode` и какие операции они обозначают?
17. Что такое двойная буферизация (double buffering) в Fiber?

### 3. Fiber Render Process
18. Что такое work loop в React Fiber и как он организует рендеринг?
19. Как связный список Fiber позволяет прерывать и возобновлять рендеринг?
20. Как обновляется UI в React Fiber (полный цикл от `setState` до отрисовки)?
21. Какие фазы есть в Fiber?
22. Чем отличаются эти фазы и какую роль они играют в обновлении UI?
23. Что происходит в фазе **Render**?
24. Что происходит в фазе **Commit**?
25. Что такое Effect List?
26. Как формируется и используется **Effect List**?

### 4. Priority System and Scheduling
27. Как работает система приоритетов в React Fiber и как она влияет на рендеринг?
28. Что такое **Lane-модель** и как она работает?
29. Какие типы (lanes) существуют (`SyncLane`, `InputContinuousLane`, `DefaultLane` и др.)?
30. Что такое Scheduler?
31. Как **Scheduler** выбирает приоритет задач?
32. Что делает `flushSync` и как он обходит приоритезацию?
33. Что такое **Concurrent Mode** и как он меняет рендеринг?
34. Что такое time slicing?
35. Как React прерывает и возобновляет рендеринг (time slicing)?
36. Как Suspense использует механизм прерывания?

### 5. Server-Side Rendering and Hydration
37. Как работает гидратация (hydration) после SSR?
38. Что такое **selective hydration** и как она ускоряет загрузку?
39. Что такое Server Components?
40. Что такое серверные функции?
41. Что такое деректива use client?
42. Что такое деректива use server?
43. Что можно делать в сервеных компонентах чего нельзя в клиентских?
44. Что можно делать в клиентский компонентах чего нельзя в серверных?
45. Что такое Streaming SSR и как он работает?
46. Что такое **hydration mismatch**?
47. Как избежать hydration mismatch?
48. Почему важно, чтобы SSR и клиентский рендер генерировали одинаковый DOM?
49. Что произойдёт при hydration mismatch?
50. как useLayoutEffect может влиять на hydration?
51. Как SSR помогает уменьшить Time to First Byte (TTFB)?
52. Как избежать отправки лишнего JS на клиент?
53. Как работает Suspense и lazy loading серверных данных и компонентов?
54. Какими хуками можно пользоваться в серверных компонентах?

### 6. Performance Optimization
55. Как React избегает лишних ререндеров?
56. Как работает **batching** обновлений?
57. Как Fiber улучшает отзывчивость UI (например, при анимациях)?

### 7. Advanced Patterns and Features
58. Как Fiber обрабатывает асинхронные операции?
59. Как работает **Suspense для данных**?
60. Что такое use()?
61. для чего нужен use()?
62. как работает use()?
63. где работает use()? ssr или csr?
64. Как новый хук `use()` взаимодействует с Fiber?
65. как использовать use() с контекстом?
66. Почему нельзя просто `await` в Client Components вместо use()?

### 8. Debugging and Internals
67. В чём разница между `useLayoutEffect` и `useEffect` с точки зрения Fiber?
68. Как React делит работу на чанки и приостанавливает рендеринг для более важных задач?
69. Как React обрабатывает "зависшие" компоненты (например, при загрузке данных)?
70. что такое Selective Hydration?
71. Разница между срочными (urgent) и отложенными (non-urgent) обновлениями и Как это связано с приоритетами в Scheduler?
72. что такое interruptible rendering?
73. Почему Server Components не имеют состояния и хуков?
74. Как server Components уменьшают размер бандла?
75. Как работают `React.lazy` и `Suspense` для динамического импорта компонентов?
76. Какие бывают варианты fallback UI и как работает вложенность в `Suspense`?
77. Какие основные этапы монтирования, обновления и размонтирования компонентов в функциональном React?
78. Как компоненты ведут себя в разных режимах рендера (синхронном и конкурентном)?

### 9. Component Patterns and State Management
79. Как реализуется однонаправленный поток данных в React?
80. Что такое "lifting state up" и как его правильно использовать?
81. В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?

### 10. React Features and APIs
82. Как и зачем применять `React.Fragment`?
83. Когда и как правильно использовать порталы в React?
84. Какие особенности управления событиями и фокусом возникают при работе с порталами?
85. Какие аргументы принимает cratePortal?
86. Какие стандартные атрибуты и API React помогают создавать доступный UI?
87. Как правильно реализовать контролируемые и неконтролируемые компоненты форм?
88. Как обрабатывать события `onChange` и `onSubmit` в формах?
89. Как сделать простую валидацию без сторонних библиотек?
90. Как реализовать анимации с помощью CSS?
91. Как работает система `SyntheticEvent` в React?
92. В чём основные отличия между Synthetic Events и нативными событиями браузера?
93. Как ведёт себя Strict Mode?
94. Почему компоненты и хуки вызываются повторно в Strict Mode?
95. Как Strict Mode помогает улучшить качество кода и отловить ошибки?
96. Как настроить Strict Mode?
97. Как получить доступ к контексту без хуков?
98. Какие проблемы с производительностью возникают при частых обновлениях контекста?
99. Как JSX трансформируется в вызовы `React.createElement`?
100. Что такое `ReactElement` и чем он отличается от компонента?

### 11. React 18+ Features
101. Как Automatic Batching работает с промисами и таймерами?
102. В чем разница между React 17 и React 18 batching?
103. Как `flushSync` обходит Automatic Batching?
104. Что такое React Compiler?
105. Как React Compiler оптимизирует код?

### 12. Hooks - Правила хуков
106. Правила хуков

### 13. useState
107. Для чего нужен `useState`?
108. Что возвращает `useState`?
109. Как изменить состояние `useState`?
110. Как обновлять состояние на основе предыдущего значения?
111. Почему `setState` асинхронен, и как это влияет на обновления?
112. Что произойдет, если вызвать `setState` с тем же значением?
113. Как работает shallow compare в `useState`?
114. Как работает `useState` при повторных рендерах?
115. Как правильно обновлять состояние, если оно — объект или массив?
116. Почему нельзя вызывать `useState` условно?
117. В чем отличие `useState` от `useReducer`?
118. Как ведет себя `useState` при размонтировании компонента?
119. Как сделать ленивую инициализацию состояния в `useState`?
120. В чем разница между `useState(someFunction())`, `useState(someFunction)`, `useState(() => someFunction())`?
121. Можно ли мемоизировать `setState` с помощью `useCallback`?
122. Что произойдёт, если передать пропсы как начальное значение в `useState`, а затем эти пропсы изменятся?
123. Как синхронизировать значение useState с передаваемыми компоненту пропсами?
124. Что будет если useState при значении объекта через setState присвоить этот же объект?
125. Как избежать stale-значений при обновлении состояния в async-колбэках или таймерах?
126. Почему `setState` внутри `useEffect` может зациклить рендер?
127. Как работает batching в React 18 и какие кейсы нарушают его (например, `setTimeout`, промисы)?

### 14. useEffect и useLayoutEffect
128. Для чего нужен `useEffect`?
129. Когда вызывается `useEffect`?
130. какие параметры принимает useEffect?
131. Что возвращает useEffect?
132. Как работает массив зависимостей?
133. Что будет, если не указать зависимости?
134. Как выполнить эффект только примонтировании?
135. Как использовать `useEffect` с асинхронными функциями?
136. Что такое функция очистки (cleanup)?
137. Когда вызывается функция очистки?
138. Как отменять асинхронные операции в useEffect?
139. Чем `useEffect` отличается от `useLayoutEffect`?
140. Что такое "useEffect первого рендера" и "useEffect обновления"? Как их различать?
141. Как избежать гонки состояний (race conditions) в асинхронных эффектах?
142. Почему нельзя делать `await` напрямую в `useEffect(callback)`?
143. Как правильно использовать эффекты с подписками на внешние источники (WebSocket, Observer, EventListener)?
144. Что произойдёт, если не использовать функцию очистки при подписке?
145. Чем отличается порядок выполнения нескольких `useEffect` в одном компоненте?
146. Как влияет Strict Mode на вызовы `useEffect` (дважды)? Как это влияет на эффекты с побочками?

### 15. useRef
147. Для чего нужен `useRef`?
148. Варианты использования useRef?
149. Как получить доступ к DOM-элементу с помощью `useRef`?
150. Что хранится в `.current`?
151. Можно ли изменять `.current`?
152. Вызывает ли изменение `.current` перерендер?
153. Как использовать `useRef` для хранения значений между рендерами?
154. Чем `useRef` отличается от `useState`?
155. Как использовать `useRef` для хранения предыдущего значения?
156. Как `useRef` помогает избежать лишнего рендера в `onScroll`, `onResize` и других частых ивентах?
157. Можно ли использовать `useRef` как глобальный стейт? Почему это плохая идея?
158. Как связать `useRef` и `forwardRef` для передачи доступа к DOM наружу?

### 16. useMemo
159. Что такое `useMemo`?
160. Какие аргументы принимает `useMemo`?
161. Что возвращает `useMemo`?
162. Когда применять `useMemo`?
163. Когда `useMemo` бесполезен?
164. Как работает мемоизация в `useMemo`?
165. Что произойдёт, если не указать массив зависимостей?
166. Когда `useMemo` может навредить производительности?
167. Как `useMemo` сравнивает зависимости (по ссылке или по значению)?
168. Как `useMemo` ведёт себя в React Concurrent Mode?
169. Чем `useMemo` отличается от мемоизации вне React (например, lodash.memoize)?
170. Как `useMemo` влияет на память и сборку мусора?
171. Как `useMemo` взаимодействует с Suspense?
172. Какие ошибки возникают при неправильном указании зависимостей?

### 17. useCallback
173. Что такое `useCallback`?
174. Какие аргументы принимает `useCallback`?
175. Что возвращает `useCallback`?
176. Когда применять `useCallback`?
177. Когда `useCallback` бесполезен?
178. Что будет, если функция в useCallback зависит от внешних значений, а они не указаны в зависимостях?
179. Чем отличается `useCallback` от `useMemo`?
180. Когда стоит предпочесть `useCallback` вместо обычной функции?
181. можно ли заменить useCallback c помощью useMemo?
182. Как избежать stale closure (устаревших значений) при использовании `useCallback`?
183. Как `useCallback` работает в Concurrent Mode?
184. Почему нельзя мемоизировать колбэк с пустым массивом зависимостей, если внутри используются пропсы/стейт?
185. Можно ли комбинировать `useCallback` с `useMemo`? В каких случаях?
186. Чем `useCallback` отличается от простого объявления функции внутри компонента?

### 18. useId
187. Для чего используется `useId`?
188. Как работает `useId`?
189. можно ли использвоать хук useId в серверных компонентах?
190. Как `useId` помогает при серверном рендеринге (SSR)?
191. В чём отличие `useId` от генерации ID через `Math.random()` или другие способы?
192. Можно ли использовать `useId` для генерации ключей в списках?
193. Что будет, если использовать `useId` в компоненте, который ререндерится много раз?
194. Какие проблемы решает `useId` в контексте accessibility?
195. Как `useId` ведёт себя при гидратации SSR?
196. Как `useId` генерирует ID в конкурентном режиме?
197. Есть ли ограничения по количеству вызовов `useId` в одном компоненте?
198. Как `useId` ведёт себя при гидратации в SSR с использованием React Suspense?

### 19. useContext
199. Для чего нужен `useContext`?
200. Как создать и экспортировать контекст в React?
201. Как использовать `useContext` для получения значения из контекста?
202. Можно ли использовать `useContext` вне компонента? Почему?
203. Как `useContext` работает при обновлении значения в провайдере?
204. Как избежать лишних рендеров при использовании `useContext`?
205. Можно ли использовать несколько контекстов одновременно? Как это делать?
206. Когда использовать `useContext`, а когда — глобальные стейты типа Redux или Zustand?
207. Как работает `useContext` с серверным рендерингом (SSR)?
208. Какие ограничения и подводные камни есть у `useContext`?
209. Как работает обновление контекста при вложенных провайдерах с одинаковым типом?
210. Как `useContext` влияет на производительность в больших приложениях?
211. Как обрабатывать ошибки при чтении контекста вне провайдера?
212. Какие альтернативы `useContext` для глобального состояния и когда их лучше применять?

### 20. useReducer
213. Что такое `useReducer` и для чего он нужен?
214. Какие параметры принимает useReducer?
215. Чем отличается `useReducer` от `useState`?
216. Как устроена редьюсер-функция? Какие параметры она принимает?
217. Что возвращает `useReducer`?
218. Что такое функция dispatch?
219. Как задать начальное состояние и как сделать ленивую инициализацию?
220. Как работает dispatch? Можно ли вызывать dispatch асинхронно?
221. Как использовать `useReducer` с асинхронными операциями?
222. Как использовать `useReducer` вместе с `useContext` для глобального стейта?
223. Как React 18+ улучшает работу с `useReducer` (например, конкурентный режим и приоритеты обновлений)?
224. Что происходит, если вызвать dispatch после размонтирования компонента?
225. Почему редьюсер должен быть чистой функцией? Какие проблемы возникают при мутации?
226. Как избежать вызова dispatch после размонтирования компонента?
227. Можно ли использовать несколько редьюсеров в одном компоненте?
228. Как обновлять части состояния, если state — объект или массив, чтобы избежать мутаций?
229. В чём различия между `useReducer` и Redux-подходом?

### useTransition

230. Что делает `useTransition` и как отличить его поведение от обычного обновления?
231. Как `startTransition` влияет на приоритет обновлений в React?
232. Что происходит, если вызвать `startTransition` внутри уже идущего `startTransition`?
233. Как React решает, когда прервать отложенный ререндер?
234. Как `isPending` синхронизирован между render-фазами?
235. Как отменяется отложенное обновление, если пришёл новый input?
236. Почему `useTransition` не вызывает повторного рендера сразу?
237. Как `useTransition` взаимодействует с `Suspense` и `ErrorBoundary`?
238. Какие типичные ошибки при использовании `useTransition` в формах и списках?
239. Как работает с `React.memo` и влияет ли отложенное состояние на `props` сравнение?
    
### useDeferredValue

240.  Что делает `useDeferredValue` и в чём отличие от `useTransition`?
241. Что произойдёт, если `useDeferredValue` применяется к `primitive`, `object`, `array`, `function`?
242. Как работает сравнение значений `prev` vs `deferred` – shallow или deep?
243. Когда `useDeferredValue` может **не вызвать** повторного рендера?
244. Как работает с `React.memo` — что попадёт в `areEqual(prevProps, nextProps)`?
245. Что происходит, если исходное значение меняется чаще, чем deferred успевает обновиться?
246. Как использовать `useDeferredValue` с Suspense и `fallback` UI?
247. Может ли `useDeferredValue` вызывать tearing или лаги?
    
###  useSyncExternalStore
1. Что делает `useSyncExternalStore` и в каких случаях он необходим?
2. Почему нельзя использовать `useState`/`useEffect` для подписки на внешний store?
3. Как работает `getSnapshot` и когда он должен быть стабилен?
4. Что произойдёт, если `getSnapshot` возвращает новое значение при каждом вызове?
5. Как работает подписка — синхронно или асинхронно?
6. В чём разница между `subscribe` и `getSnapshot` по таймингу?
7. Как работает SSR-поддержка через `useSyncExternalStoreWithSelector`?
8. Что происходит, если snapshot меняется во время рендера?
9. Какие ошибки возникают при нестабильном snapshot или unsubscribe?
    
### useInsertionEffect
1. Чем `useInsertionEffect` отличается от `useEffect` и `useLayoutEffect`?
2. Почему `useInsertionEffect` нужен для библиотек CSS-in-JS (Emotion, styled-components)?
3. Что произойдёт, если внутри `useInsertionEffect` сделать `setState`?
4. Почему нельзя читать DOM внутри `useInsertionEffect`?
5. Как `useInsertionEffect` влияет на порядок вставки CSS и приоритет specificity?
6. Что произойдёт, если `useInsertionEffect` недоступен (например, SSR)?
7. Как fallback'ают Emotion или Styled-components при отсутствии `useInsertionEffect`?
    
### useImperativeHandle
1. Как работает `useImperativeHandle` и зачем он нужен?
2. Почему важно передавать второй аргумент в `forwardRef`, а не использовать `useRef` напрямую?
3. Что произойдёт, если вернуть новый объект каждый раз (не мемоизировать результат)?
4. Можно ли в `useImperativeHandle` возвращать функции, которые используют stale props/state?
5. Как использовать `useImperativeHandle` для управления анимациями, фокусом, expose API?
6. В каких случаях стоит избегать `useImperativeHandle` вообще?
7. Что произойдёт, если ref в `forwardRef` null или изменится тип?
    
### useDebugValue
1. Как работает `useDebugValue` и влияет ли он на продакшн-бандл?
2. Как `useDebugValue` отображается в React DevTools?
3. Как работает форматтер (второй аргумент — `formatFn`) и когда он вызывается?
4. Может ли `useDebugValue` вызывать перерендер или side-effect?
5. Как использовать `useDebugValue` в кастомных хуках?
6. Как избежать performance impact при сложных форматтерах?
    
### useEvent
1. Что делает `useEvent` и чем он отличается от `useCallback`?
2. Почему `useCallback` не всегда решает проблему stale замыканий?
3. Как `useEvent` сохраняет reference на последнюю версию функции без пересоздания?
4. В чём польза `useEvent` при подписке на DOM-события или глобальные обработчики?
5. Как работает под капотом — через ref или proxy?
6. Может ли `useEvent` быть использован как dependency для других хуков?
7. Поддерживает ли `useEvent` серверный рендеринг?
### useOptimistic
1. Что делает `useOptimistic` и как он связан с Server Actions?
2. Как выглядит типичная схема: optimistic update → реальный результат → reconcile?
3. Как отменить optimistic state при отмене запроса или ошибке?
4. Можно ли использовать `useOptimistic` без `form` и `Server Actions`?
5. Что произойдёт, если optimistic value конфликтует с новым реальным state?
6. Как влияет на Suspense или Concurrent rendering?
7. Как работает `updateFn` и почему важно возвращать новый объект, а не мутировать?
8. Может ли `useOptimistic` быть использован с внешними state management (Redux/Zustand)?
    
### useActionState
1. Чем `useActionState` отличается от обычного `useState` + `useEffect`?
2. Как `useActionState` помогает обрабатывать формы и асинхронные действия?
3. Что делает `action(prevState, formData)` и как использовать `formData` внутри?
4. Как работает взаимодействие с `Server Actions`?
5. Что происходит, если action возвращает ошибку — влияет ли это на UI?
6. Можно ли вызвать `setState` внутри `action` напрямую?
7. Как сбрасывается state, если отправка формы отменена или изменилась?
8. Как `useActionState` влияет на retry, Suspense и optimistic UI?
9. **Всего вопросов: 238**