что такое batching и как он работает

**useState**

1. Для чего нужен `useState`?
2. Что возвращает `useState`?
3. Как изменить состояние `useState`?
4. Как обновлять состояние на основе предыдущего значения?
5. Какие способы есть для обновления на основе предыдущего состояния?
6. Почему `setState` асинхронен, и как это влияет на обновления?
7. Что произойдет, если вызвать `setState` с тем же значением?
8. Как работает shallow compare в `useState`?
9. Как работает `useState` при повторных рендерах?
10. Как правильно обновлять состояние, если оно — объект или массив?
11. Почему нельзя вызывать `useState` условно?
12. В чем отличие `useState` от `useReducer`?
13. Как ведет себя `useState` при размонтировании компонента?
14. Как сделать ленивую инициализацию состояния в `useState`?
15. В чем разница между `useState(someFunction())`, `useState(someFunction)`, `useState(() => someFunction())`?
16. Можно ли мемоизировать `setState` с помощью `useCallback`?
17. Что произойдёт, если передать пропсы как начальное значение в `useState`, а затем эти пропсы изменятся?
    

---

**useEffect** и useLayoutEffect

- Для чего нужен `useEffect`?
- Когда вызывается `useEffect`?
- какие параметры принимает useEffect?
- Что возвращает useEffect?
- Как работает массив зависимостей?
- Что будет, если не указать зависимости?
- Как задать эффект только при монтировании?
- Как использовать `useEffect` с асинхронными функциями?
- Что такое функция очистки (cleanup)?
- Когда вызывается функция очистки?
- Как отменять асинхронные операции в useEffect?
- Чем `useEffect` отличается от `useLayoutEffect`?

---

**useRef**

- Для чего нужен `useRef`?
- Варианты использования useRef?
- Как получить доступ к DOM-элементу с помощью `useRef`?
- Что хранится в `.current`?
- Можно ли изменять `.current`?
- Вызывает ли изменение `.current` перерендер?
- Как использовать `useRef` для хранения значений между рендерами?
- Чем `useRef` отличается от `useState`?
- Как использовать `useRef` для хранения предыдущего значения?
    

---


---

**useMemo**
- Что такое `useMemo`?
- Какие аргументы принимает `useMemo`?
- Что возвращает `useMemo`?
- Когда применять `useMemo`?
- Когда `useMemo` бесполезен?
- Как работает мемоизация в `useMemo`?
- Что произойдёт, если не указать массив зависимостей?
- Когда `useMemo` может навредить производительности?
- Как `useMemo` сравнивает зависимости (по ссылке или по значению)?

---

**useCallback**

- Что такое `useCallback`?
- Какие аргументы принимает `useCallback`?
- Что возвращает `useCallback`?
- Когда применять `useCallback`?
- Когда `useCallback` бесполезен?
- Что будет, если функция в useCallback зависит от внешних значений, а они не указаны в зависимостях?
- Чем отличается `useCallback` от `useMemo`?
- Когда стоит предпочесть `useCallback` вместо обычной функции?
- можно ли заменить useCallback c помощью useMemo?


---

**useId**

- Для чего используется `useId`?
- Как работает `useId`?
- можно ли использвоать хук useId в серверных компонентах?
- Как `useId` помогает при серверном рендеринге (SSR)?
- В чём отличие `useId` от генерации ID через `Math.random()` или другие способы?
- Можно ли использовать `useId` для генерации ключей в списках?
- Что будет, если использовать `useId` в компоненте, который ререндерится много раз?
- Какие проблемы решает `useId` в контексте accessibility (например, для `label` и `input`)?
- Как `useId` ведёт себя при гидратации SSR?

---


**useContext**

- Для чего нужен `useContext`?
- Как создать и экспортировать контекст в React?
- Как использовать `useContext` для получения значения из контекста?
- Можно ли использовать `useContext` вне компонента? Почему?
- Как `useContext` работает при обновлении значения в провайдере?
- Как избежать лишних рендеров при использовании `useContext`?
- Можно ли использовать несколько контекстов одновременно? Как это делать?
- Когда использовать `useContext`, а когда — глобальные стейты типа Redux или Zustand?
- Как работает `useContext` с серверным рендерингом (SSR)?
- Какие ограничения и подводные камни есть у `useContext`?

---

**useReducer**
- Что такое `useReducer` и для чего он нужен?
- Чем отличается `useReducer` от `useState`?
- Как устроена редьюсер-функция? Какие параметры она принимает?
- Что возвращает `useReducer`?
- Что такое функция dispatch?
- Как задать начальное состояние и как сделать ленивую инициализацию?
- Как работает dispatch? Можно ли вызывать dispatch асинхронно?
- Как использовать `useReducer` с асинхронными операциями?
- Как использовать `useReducer` вместе с `useContext` для глобального стейта?
- Как React 18+ улучшает работу с `useReducer` (например, конкурентный режим и приоритеты обновлений)?
- Что происходит, если вызвать dispatch после размонтирования компонента?


-----
- useTransition
    
- useDeferredValue
    
- useSyncExternalStore
    
- useInsertionEffect
    
- useImperativeHandle
    
- useDebugValue
    
- useEvent
    
- useOptimistic
    
- useActionState