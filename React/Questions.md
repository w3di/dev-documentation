#### **1. Virtual DOM и Reconciliation**

1. Что такое Virtual DOM?
	1. Virtual DOM - это **абстрактное представление UI** в виде дерева **обычных JavaScript-объектов**, которые отражают структуру реального DOM. React использует его, чтобы **оптимизировать и контролировать обновления интерфейса**.
2. Как работает Virtual DOM?
	1. Компонент возвращает JSX → превращается в дерево Virtual DOM.
	2. При изменении состояния/пропсов React создаёт новое дерево VDOM.
	3. React сравнивает новое и старое дерево (алгоритм diff).
	4. Вычисляется минимальный набор изменений (патчи)
	5. Реальный DOM обновляется **точечно**, на основе diff-а.
3. Что может спровоцировать обновление Virtual DOM?
	1. Изменение `props` компонента
	2. Изменение контекста через `useContext`
	3. Монтирование и размонтирование компонентов
	4. Изменение состояния через `useState`/`useReducer`
	5. Любые изменения данных, влияющие на вывод JSX
4. Где работает Virtual DOM?
	1. Virtual DOM работает в памяти JavaScript-движка, то есть в оперативной памяти (RAM) браузера, внутри JavaScript-окружения
5. Из чего состоит Virtual DOM?
	1. Virtual DOM состоит из JavaScript-объектов, каждый из которых представляет **один UI-элемент** (аналог узла DOM)
6. Почему Virtual DOM эффективнее прямых манипуляций с DOM?
	1. Прямые манипуляции с DOM вызывают дорогостоящие затраты браузера на layout/repaint.
	2. Работать с UI в памяти,
	3. Обновления происходят в памяти, что позволяет вычислять минимальный набор изменений (diffing) и применять их пакетно, снижая количество дорогостоящих операций с реальным DOM
7. Как работает алгоритм **diffing** в React для сравнивания изменения в Virtual DOM?
	1. React использует эффективный алгоритм diffing с линейной сложностью O(n)
	2. Сравнивает элементы сверху вниз и слева направо.
	3. Если у элементов **разный `type`** (например, `div` и `span` или разные компоненты), React полностью заменяет соответствующее поддерево.
	4. Если `type` совпадает, React сравнивает **props** и рекурсивно переходит к сравнению **детей**.
	5. При сравнении детей React ориентируется на позицию элементов и `key
		1. Если ключи присутствуют, используется сопоставление по ним для эффективной обработки добавлений, удалений и перемещений.
		2. Без ключей сравнение идёт по индексу, что менее эффективно и может привести к лишним обновлениям.
8. Как ключи (`key`) влияют на процесс сравнения элементов?
	1. Ключи (`key`) — это уникальные идентификаторы элементов списка, которые React использует для сопоставления элементов между старым и новым деревом
	2. Если ключи присутствуют, React сопоставляет элементы по ним, что позволяет эффективно выявлять: - добавленные, удалённые перемещённые элементы.
	3. Без ключей React сравнивает элементы **по их позиции (индексу)** в массиве

#### **2. Fiber Architecture**

9. Что такое React Fiber и чем он отличается от Stack Reconciler?
	1. Прерываемость
	2. Приоритезация
	3. Инкрементальный рендеринг
10. В чем минусы Virtual DOM над Fiber?
	1. Старый Virtual DOM работал синхронно и непрерываемо, что приводило к блокировкам UI при больших обновлениях.
	2. Отсутствие приоритезации обновлений: все обновления обрабатывались с одинаковым приоритетом.
	3. Нельзя было **прервать, отложить или отменить рендеринг**, что негативно влияло на отзывчивость интерфейса.
	4. Отсутствие инкрементального (пошагового) рендеринга
	5. Отсутствие возможности прерывать и возобновлять рендеринг с учётом приоритетов.
11. Почему Fiber использует связный список, а не рекурсивный обход?
	1. Связный список позволяет React:
		1. Выполнять обход дерева итеративно, без глубокого рекурсивного стека, что снижает риск переполнения стека
		2. Прерывать и возобновлять рендеринг
		3. Управлять приоритетами задач и планировать работу по частям
	2. Рекурсия же требует полного прохода и не позволяет прерывать работу посередине.
12. Как работает связный список в контексте Fiber?
	1. это структура из объектов FiberNode, где каждый узел содержит ссылки:
		1. child — на первого потомка,
		2. `sibling` — на следующего брата (соседа),
		3. `return` — на родителя.  
    2. Так можно пройти всё дерево последовательно, переходя от родителя к первому ребёнку, потом к соседям, обходя дерево без рекурсии.
13. Что такое FiberNode и как он устроен?
	1. FiberNode — это объект, представляющий один узел дерева Fiber. Он содержит всю информацию, необходимую React для управления рендерингом и обновлением конкретного UI-элемента
14. Какие ключевые поля содержит объект FiberNode и что каждое из них означает?
	1. stateNode — ссылка на реальный инстанс, связанный с этим узлом (DOM-элемент, экземпляр класса, или null для функциональных компонентов).
	2. return — ссылка на родительский FiberNode, позволяющая подниматься вверх по дереву.
	3. child — ссылка на первый дочерний FiberNode, начало обхода детей.
	4. sibling — ссылка на следующий соседний FiberNode на том же уровне.
	5. flags — битовая маска, указывающая, какие операции (вставка, обновление, удаление) нужно выполнить с этим узлом.
15. Как взаимодействуют FiberNode поля `return`, `child` и `sibling` для обхода дерева Fiber без рекурсии?
	1. Поле `child` позволяет спуститься вниз по дереву
	2. поле `sibling` — перейти к соседнему узлу на том же уровне
	3. поле `return` — подняться вверх к родителю после обхода всех детей.
	4. Вместе они реализуют итеративный обход дерева, заменяющий рекурсию, что даёт контроль над процессом рендеринга и позволяет прерывать и возобновлять работу.
16. Какие бывают типы флагов (`flags`) в `FiberNode` и какие операции они обозначают?
	1. `flags` — это битовая маска, которая сообщает React, какие действия нужно выполнить над узлом на этапе **commit**. Основные флаги:
		1. Placement — узел нужно **вставить** в DOM (новый элемент).
    	2. Update`** — узел нужно **обновить** (например, props или DOM-атрибуты).
		3. Deletion — узел нужно **удалить** из DOM.
		4. ChildDeletion — удалить одного или нескольких потомков.
		5. Ref — обновить ref.
		6. Passive — выполнить эффекты `useEffect`.
17. Что такое двойная буферизация (double buffering) в Fiber?
	1. Двойная буферизация в Fiber — это хранение двух деревьев (current и working) для безопасного обновления UI без блокировок: изменения делают в рабочем дереве, а после завершения заменяют текущее.

#### **3. Fiber Render Process**

18. Что такое work loop в React Fiber и как он организует рендеринг?
	1. **Work loop в React Fiber** — это основной цикл, в котором React **пошагово обходит дерево Fiber**, создаёт/обновляет `FiberNode`'ы и готовит дерево к коммиту. Он лежит в основе **инкрементального, прерываемого рендеринга**.
19. Как связный список Fiber позволяет прерывать и возобновлять рендеринг?
	1. обход дерева — это итеративный процесс с явным хранением текущей позиции, это позволяет просто сохранить состояние обхода (текущий узел), остановить цикл и освободить основной поток для других задач, при следующем вызове React продолжит обход с сохранённого узла, а не начинает заново или не уходит в глубокую рекурсию
20. Как обновляется UI в React Fiber (полный цикл от `setState` до отрисовки)?
	1. Инициирование обновления
		1. создаётся объект обновления, который добавляется в очередь обновлений соответствующего `FiberNode`.
	2. Приоритезация
		1. Обновление получает приоритет через систему **Lanes**.  
	3. Планирование задачи (Scheduler)
		1. Scheduler решает, когда запускать работу: сразу (высокий приоритет) или отложить (низкий).
	4. Render-фаза (Reconciliation) - эта фаза прерываема и инкрементальна, может быть приостановлена и возобновлена.
		1. Создаётся новое дерево `work-in-progress` (рабочее дерево Fiber) на основе текущего.
		2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие `FiberNode`'ы, собирает список эффектов
	5. Завершение render-фазы
		1. После обхода дерева React формирует полный список эффектов для commit-фазы.
	6. Commit-фаза (синхронная, непрерываемая)
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (`cleanup`) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции `useLayoutEffect`
		4. Выполняются функции `useEffect`
	7. Обновление текущего дерева
		1. Рабочее дерево `work-in-progress` становится текущим (`current`), старое может быть удалено или повторно использовано
21. Какие фазы есть в Fiber?
	1. Reconciliation (render фаза) - Прерываемая и инкрементальная.
	2. Commit фаза - Синхронная и непрерываемая.
22. Чем отличаются эти фазы и какую роль они играют в обновлении UI?
	1. render-фаза отвечает за подготовку и планирование изменений, commit-фаза — за их окончательное применение и взаимодействие с DOM.
23. Что происходит в фазе **Render**?
	1. . Создаётся новое дерево `work-in-progress` на основе текущего.
	2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие `FiberNode`'ы, собирает список эффектов
	3. После обхода дерева React формирует полный список эффектов для commit-фазы.
	4. Фаза может быть прервана и возобновлена, чтобы избежать блокировки основного потока
24. Что происходит в фазе **Commit**?
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (`cleanup`) эффектов из предыдущего рендера: сначала `useLayoutEffect` cleanup, потом `useEffect` cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции `useLayoutEffect`
		4. Выполняются функции `useEffect
		5. Commit-фаза не прерывается, чтобы гарантировать консистентность DOM
25. Что такое Effect List?
	1. это связанный список узлов Fiber с помеченными изменениями, которые React последовательно применяет к DOM и запускает соответствующие эффекты в фазе commit.
26. Как формируется и используется **Effect List**?
	1. Во время render-фазы React при обходе `work-in-progress` дерева помечает каждый `FiberNode` с изменениями специальными флагами
	2. Эти помеченные узлы собираются в Effect List — связанный список эффектов, которые нужно применить.
	3. В commit-фазе React последовательно проходит по Effect List и выполняет соответствующие операции

#### **4. Priority System and Scheduling**

27. Как работает система приоритетов в React Fiber и как она влияет на рендеринг?
	1. Каждое обновление получает приоритет — через механизм `Lanes`.
	2. React сначала обрабатывает **более приоритетные задачи** (например, ввод), менее важные — откладывает.
28. Что такое **Lane-модель** и как она работает?
	1. Lane-модель — система приоритизации обновлений в React Fiber, где каждое обновление относится к одной или нескольким lanes — битовым флагам разного приоритета.
29. Какие типы (lanes) существуют (`SyncLane`, `InputContinuousLane`, `DefaultLane` и др.)?
	1. SyncLane — максимальный приоритет, обновления должны выполниться сразу (например, flushSync).
	2. InputContinuousLane — приоритет интерактивного ввода, чтобы UI был отзывчивым.
	3. DefaultLane — обычные фоновый обновления.
30. Что такое Scheduler?
	1. Это планировщик задач React, который решает, когда и с каким приоритетом запускать работу по обновлению UI. Он координирует выполнение render-фазы, позволяя прерывать низкоприоритетные задачи ради более важных
31. Как **Scheduler** выбирает приоритет задач?
	1. Scheduler использует lanes и сопоставляет их с уровнями приоритетов.
	2. Задачи с более высоким приоритетом прерывают текущие и запускаются раньше
32. Что делает `flushSync` и как он обходит приоритезацию?
	1. `flushSync` — функция, которая запускает обновление синхронно, игнорируя систему приоритетов и асинхронность Scheduler. Она принудительно выполняет render и commit сразу, чтобы обновление UI произошло немедленно
33. Что такое **Concurrent Mode** и как он меняет рендеринг?
	1. Concurrent Mode - новый способ работы React с рендерингом, при котором React не блокирует основной поток на долгое время, а разбивает работу на небольшие части (инкрементальный рендеринг).
	2. Позволяет React **приостанавливать, возобновлять и приоритезировать** работу по обновлению интерфейса.
34. Что такое time slicing?
	1. механизм в React Fiber, который разбивает работу по рендерингу на небольшие части. React выполняет эти части по очереди, прерываясь по тайм-ауту, чтобы дать браузеру возможность обрабатывать пользовательские события и другие задачи.
	2. Time slicing реализуется за счёт итеративного обхода дерева Fiber с сохранением состояния, чтобы при возобновлении рендеринга продолжить с того места, где остановились.
35. Как React прерывает и возобновляет рендеринг (time slicing)?
	1. React разбивает работу рендера на небольшие задачи — единицы работы (`units of work`).
	2. При достижении лимита времени текущая задача прерывается, текущее состояние обхода (`nextUnitOfWork`) сохраняется.
	3. В следующий момент React возобновляет обход с сохранённой позиции, позволяя браузеру обрабатывать важные события между этими фрагментами работы
36. Как Suspense использует механизм прерывания?
	1. Suspense позволяет React прервать рендеринг компонента, если он «зависает» на асинхронной операции (например, загрузке данных или кода).
	2. React отменяет текущую работу по рендеру, показывает fallback UI, а затем возобновляет рендеринг, когда асинхронная операция завершена.

#### **5. Server-Side Rendering and Hydration**

37. Как работает гидратация (hydration) после SSR?
	1. Сервер присылает готовую страницу с уже заполненным HTML
	2. Браузер показывает этот HTML — пользователь сразу видит контент, даже если JS ещё не загрузился.
	3. После загрузки JS React берёт этот HTML и «подключает» к нему свою логику: навешивает обработчики событий, создаёт внутренние структуры для управления состоянием.
	4. React не рисует заново весь UI, а работает поверх уже существующего DOM, делая его интерактивным.
38. Что такое **selective hydration** и как она ускоряет загрузку?
	1. Selective hydration — это стратегия, при которой React не гидратирует сразу всё дерево, а по частям и с приоритетом. Например, сначала гидратируются видимые пользователю интерактивные части, а остальные — позже или при взаимодействии.
39. Что такое Server Components?
	1. Server Components — это React-компоненты, которые рендерятся только на сервере. Они не попадают в клиентский бандл, не запускают JS в браузере и позволяют значительно уменьшить размер кода на клиенте. Серверные компоненты могут напрямую обращаться к базе данных или файловой системе и отправлять готовый HTML, облегчая загрузку и повышая производительность
40. Что такое серверные функции?
	1. Серверные функции (Server Actions) — это функции, которые выполняются на сервере по вызову из React-компонента. Они могут обрабатывать данные, выполнять бизнес-логику или работать с API, при этом не отправляя клиенту лишний JavaScript
41. Что такое деректива use client?
	1. строчка в начале файла которая указывает, что компонент должен рендериться и работать на клиенте.
42. Что такое деректива use server?
	1. строчка в начале файла указывает, что функция или компонент выполняется только на сервере.
43. Что можно делать в сервеных компонентах чего нельзя в клиентских?
	1. доступ к базе данных, файловой системе, секретам
	2. использовать серверные зависимости (например, `fs`, `pg`, `bcrypt`)
44. Что можно делать в клиентский компонентах чего нельзя в серверных?
	1. использовать:
		1. браузерные API
		2. Хуки react
		3. обработчики событий
		4. манипулировать с DOM
45. Что такое Streaming SSR и как он работает?
	1. Streaming SSR — это возможность React отдавать HTML по мере готовности дерева пока React рендерит все по частям
	2. Работает через `renderToPipeableStream` (Node.js) или `renderToReadableStream` (Edge/Cloud).
46. Что такое **hydration mismatch**? 
	1. **Hydration mismatch** — это ситуация, когда HTML, пришедший с сервера (SSR) не совпадает с тем, что React "ожидает" при клиентской гидратации.
47. Как избежать hydration mismatch?
	1. **Соблюдать одинаковую логику рендера** на сервере и клиенте.
		1. не использовать случайные значения (`Math.random()`, `Date.now()`),
		2. `window`, `document` и любые browser-only API.
		3. Использовать `useEffect`, а не `useLayoutEffect` для client-only логики
48. Почему важно, чтобы SSR и клиентский рендер генерировали одинаковый DOM?
	1. React при гидратации **подключается к существующему серверному HTML** и ожидает, что структура совпадёт. Если DOM не совпадает — происходит **hydration mismatch**, React показывает предупреждения и может перерисовать большие участки UI
49. Что произойдёт при hydration mismatch?
	1. React покажет warning, а иногда — перерисует весь DOM узел
50. как useLayoutEffect может влиять на hydration?
	1. `useLayoutEffect` выполняется **до отрисовки**, только на клиенте — и может **синхронно изменить DOM**, не совпадающий с HTML от сервера, что приводит к hydration mismatch
51. Как SSR помогает уменьшить Time to First Byte (TTFB)
	1. SSR позволяет серверу сразу отправить полностью сформированный HTML, благодаря чему браузер начинает отображать контент сразу после получения первого байта без задержек на загрузку и выполнение JS
52. Как избежать отправки лишнего JS на клиент
	1. Использовать Server Components, которые рендерятся только на сервере и не попадают в клиентский бандл.
	2. Применять `use client` директиву строго там, где нужна интерактивность.
	3. Делать код-сплиттинг и динамический импорт для загрузки JS только при необходимости.
	4. Минимизировать зависимости и не импортировать клиентские библиотеки в серверные компоненты.
	5. Использовать selective hydration, чтобы загружать JS по частям и с приоритетом.
53. Как работает Suspense и lazy loading серверных данных и компонентов?
	1. Серверные компоненты могут использовать асинхронные функции (например, `await fetch()`) прямо внутри тела компонента. React ждёт их завершения или отдаёт fallback, обеспечивая эффективный ленивый рендеринг и загрузку.
	2. После загрузки данных React «дозаписывает» оставшийся HTML по стриму (Streaming SSR), обеспечивая эффективный ленивый рендеринг и быструю первую отрисовку.
	3. На клиенте Suspense переключается между fallback и готовым UI по мере завершения загрузки, поддерживая плавный переход.
54. Какими хуками можно пользоваться в серверных компонентах?
	1. useId - Генерация стабильных ID

#### **6. Performance Optimization**

55. Как React избегает лишних ререндеров?
	1. Virtual DOM и сравнение (reconciliation)
	2. Мемоизация с `React.memo`
	3. Хуки `useMemo` и `useCallback`
	4. Контроль ключей (`key`) в списках
56. Как работает **batching** обновлений?
	1. это механизм объединения нескольких обновлений состояния (state updates) в один цикл рендера
	2. внутри обработчика вызывается несколько `setState` или обновлений, React объединяет (batch) их и выполняет **один рендер** после завершения обработчика
57. Как Fiber улучшает отзывчивость UI (например, при анимациях)?
	1. Приоритизация обновлений
	2. Прерываемость рендера
	3. благодаря time slicing и прерывистому рендеру, браузер может своевременно обновлять кадры анимаций и избегать "фризов".

#### **7. Advanced Patterns and Features**

58. Как Fiber обрабатывает асинхронные операции?
	1. Fiber сам по себе не выполняет асинхронные операции, но он управляет их результатами и обновлением UI с учётом приоритетов
59. Как работает **Suspense для данных**?
	1. Suspense для данных приостанавливает рендер компонента, если данные ещё не готовы, бросая Promise. React показывает fallback UI, пока Promise не разрешится, после чего рендер возобновляется с готовыми данными.
60. Что такое use()?
	1. `use()` — это React API для чтения значения ресурса, такого как Promise или контекст
61. для чего нужен use()?
	1. Чтобы "подписаться" на Promise или контекст и получить их значение, интегрируясь с Suspense и Error Boundaries.
62. как работает use()?
	1. Если передан Promise, React "приостанавливает" рендер компонента до его разрешения (Suspense fallback показывается).
	2. Если Promise отклонён — срабатывает ближайший Error Boundary.
	3. Если передан контекст — `use()` возвращает его значение, как `useContext`, но может использоваться в условных и циклах.
63. где работает use()? ssr или csr?
	1. Работает и на сервере, и на клиенте, но преимущественно используется для чтения ресурсов в Client Components
64. Как новый хук `use()` взаимодействует с Fiber?
	1. `use()` интегрируется с механизмом Suspense в Fiber: при ожидании Promise Fiber приостанавливает рендер и переключается на fallback, а после разрешения возобновляет рендер с полученными данными.
65. как использовать use() с контекстом?
	1. Использование `use` с контекстом способ читать значение контекста, аналогичный `useContext`, но с преимуществом возможности вызывать `use` внутри условных блоков и циклов.
66. Почему нельзя просто `await` в Client Components вместо use()?
	1. `await` нельзя использовать напрямую в теле функционального компонента — он синхронный и блокирует. `use()` позволяет React управлять состоянием ожидания асинхронного результата в рамках Fiber и Suspense.

#### **8. Debugging and Internals**

67. В чём разница между `useLayoutEffect` и `useEffect` с точки зрения Fiber?
	 1. `useLayoutEffect` — синхронный, блокирующий эффект, полезен для измерений DOM и синхронных манипуляций. выполняется в **phase commit**, **после того, как React применил изменения к DOM**, но **до того, как браузер обновил экран**
    2. `useEffect` — асинхронный, неблокирующий, выполняется после отрисовки, оптимален для сетевых запросов, подписок и не критичных к времени операций. выполняется **после фазы commit и после того, как браузер отрисовал обновлённый UI**
68. Как React делит работу на чанки и приостанавливает рендеринг для более важных задач?
	1. React Fiber разбивает работу рендеринга на небольшие части (чанки). При этом рендеринг **приостанавливается** (interruptible rendering), если появляется задача с более высоким приоритетом (например, пользовательский ввод)
69. Как React обрабатывает "зависшие" компоненты (например, при загрузке данных).
	1. При загрузке данных, если компонент возвращает Promise, React **приостанавливает его рендеринг**, показывая запасной UI (fallback) через Suspense. Когда данные загружены, React продолжает рендеринг компонента с этими данными
70. что такое Selective Hydration?
	1. Selective Hydration — это техника, при которой React при гидратации на клиенте сначала  гидратирует только самые важные или видимые части UI, а остальные части гидратируются позже, по мере необходимости.
71. Разница между срочными (urgent) и отложенными (non-urgent) обновлениями и Как это связано с приоритетами в Scheduler.
	1. Срочные (urgent) обновления — это события с высоким приоритетом, как ввод пользователя или клики, которые React должен обработать немедленно.
	2. Отложенные (non-urgent) обновления — менее важные задачи, например, обновление неактивных компонентов, которые можно выполнить позже.  
	3. Scheduler React управляет этими приоритетами, позволяя прерывать низкоприоритетные задачи для срочных, поддерживая отзывчивость UI.
72. что такое interruptible rendering?
	1. Interruptible rendering — возможность React прерывать текущий процесс рендеринга в любой момент, чтобы переключиться на более приоритетную работу, а затем продолжать с места остановки
73. Почему Server Components не имеют состояния и хуков?
	1. Server Components рендерятся на сервере и не имеют жизненного цикла или интерактивности, поэтому состояние и хуки им не нужны
74. Как server Components уменьшают размер бандла.
	1. Потому что Server Components не включаются в клиентский бандл JavaScript — они полностью рендерятся на сервере и передают клиенту уже готовый HTML
75. Как работают `React.lazy` и `Suspense` для динамического импорта компонентов?
	1. React.lazy` динамически импортирует компонент (через `import()`), возвращая промис.
	2. Пока компонент загружается — `Suspense` показывает fallback UI.
	3. После загрузки компонент рендерится как обычно.
76. Какие бывают варианты fallback UI и как работает вложенность в `Suspense`?
	1. Fallback — любой React-элемент, показываемый во время загрузки.
	2. Вложенные Suspense показывают самый близкий fallback для загрузки в своей области.
77. Какие основные этапы монтирования, обновления и размонтирования компонентов в функциональном React?
	1. Монтирование: рендер + запуск эффектов с пустым массивом зависимостей (`useEffect(() => {}, [])`).
	2. Обновление: повторный рендер + эффекты с изменившимися зависимостями.
	3. Размонтирование: вызов очисток эффектов (функций, возвращаемых из `useEffect`
78. Как компоненты ведут себя в разных режимах рендера (синхронном и конкурентном)?
	1. Sync: рендер блокирует UI до конца.
	2. Concurrent: рендер можно приостанавливать, приоритеты обновлений.

#### **9. Component Patterns and State Management**

79. Как реализуется однонаправленный поток данных в React?
	1. Однонаправленный поток данных в React означает, что данные всегда идут сверху вниз — от родительских компонентов к дочерним через props
	2. Родитель хранит состояние и передаёт его дочерним, которые могут только читать эти props, но не менять их напрямую. Изменения состояния происходят в родителе через коллбэки, переданные вниз
80. Что такое "lifting state up" и как его правильно использовать?
	1. это когда состояние, нужное нескольким компонентам, поднимается к их ближайшему общему родителю. Вместо того чтобы каждый компонент держал своё локальное состояние и пытался синхронизировать его, состояние централизуется в одном компоненте-родителе, а дочерним передаются через props и коллбэки для изменения.
81. В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?
	1. **Контролируемые компоненты** — это компоненты, где состояние формы полностью управляется React через `state` и обновляется через обработчики (`onChange`). Значение поля всегда берётся из состояния, а не из DOM.
	2. **Неконтролируемые компоненты** — это компоненты, где состояние формы хранится непосредственно в DOM, а React лишь получает доступ через  ref. React не управляет значением, а читает его при необходимости.
	3. Контролируемые компоненты позволяют сразу валидировать, управлять вводом, делать условный рендер элементов формы.

#### **10. React Features and APIs**

82. Как и зачем применять `React.Fragment`?
	1. Позволяет сгруппировать несколько элементов без добавления лишнего DOM-узла.
83. Когда и как правильно использовать порталы в React?
	1. Используйте порталы, когда UI-элемент должен визуально выходить за пределы текущей иерархии DOM — например, модальные окна, тултипы, всплывающие меню, уведомления
84. Какие особенности управления событиями и фокусом возникают при работе с порталами?
	2. События всплывают по React-дереву, а не по DOM — обработчики работают как обычно, несмотря на другой DOM-узел
	3. Фокусом нужно управлять вручную: при открытии модалки ставить фокус в портал, при закрытии — возвращать на исходный элемент.
85. Какие аргументы принимает cratePortal?
	1. children** — React-элементы, которые нужно отрендерить (JSX, компоненты, строки, фрагменты и т.п.).
	2. domNode** — DOM-узел, куда будет помещён этот контент. Этот узел должен уже существовать в DOM.
	3. key** (опционально) — уникальный ключ (строка или число) для идентификации портала, особенно при рендере списков порталов.
86. Какие стандартные атрибуты и API React помогают создавать доступный UI?
	1. aria-* (`aria-label`, `aria-labelledby`, `aria-describedby`, `aria-hidden`) для описания элементов для скринридеров.
	2. tabIndex - для настройки порядка табуляции и возможности фокусировки.
87. Как правильно реализовать контролируемые и неконтролируемые компоненты форм?
	1. Контролируемые компоненты:** значение хранится в состоянии (`useState`), обновляется через `onChange`. React полностью управляет вводом.
	2. **Неконтролируемые компоненты:** значение хранится в DOM, доступ через `ref`. React не управляет вводом напрямую.
88. Как обрабатывать события `onChange` и `onSubmit` в формах?
	1. **onChange:** обновляет состояние для контролируемых компонентов.
	2. o**nSubmit:** отменяет стандартное поведение и обрабатывает данные из состояния или `ref`.
89. Как сделать простую валидацию без сторонних библиотек?
	1. выполняется прямо в обработчике `onSubmit` или `onChange` — проверяем значения на нужные условия с сохранением ошибок в состоянии
	2. HTML-атрибуты валидации `required`, `minLength`, `pattern`
90. Как реализовать анимации с помощью CSS?
	1. Создаёшь CSS-классы с `transition` (для плавных переходов свойств) или `@keyframes` (для сложных анимаций).
91. Как работает система `SyntheticEvent` в React?
	1. `SyntheticEvent` — это обёртка над нативными событиями браузера, которую React создаёт для обеспечения **кроссбраузерного** и **одинакового API** при работе с событиями.
92. В чём основные отличия между Synthetic Events и нативными событиями браузера?
	1. **Кроссбраузерность**  
	    1. `SyntheticEvent` предоставляет единый интерфейс, который одинаково работает во всех браузерах. Нативные события могут иметь отличия в свойствах и поведении между браузерами.
	2. **Поведение всплытия**  
	    События в React всплывают **по React-иерархии компонентов**, даже если DOM-структура другая (например, при использовании `createPortal`). Нативные события всплывают **по DOM-дереву**.
	3. **Совместимость с React API**  
	    1. Только `SyntheticEvent` работает корректно с системой приоритетов событий в concurrent режиме. Нативные события об этом "не знают".
	4. **API одинаково везде**  
	    1. У `SyntheticEvent` всегда есть стандартные свойства (`type`, `target`, `currentTarget`, `preventDefault()`, `stopPropagation()` и т.п.), даже если браузер этого не поддерживает напрямую.
93. Как ведёт себя Strict Mode?
	1. В Strict Mode компоненты и хуки специально монтируются, размонтируются и монтируются заново _в режиме разработки_. Это имитация двойного вызова жизненных циклов для выявления побочных эффектов
94. Почему компоненты и хуки вызываются повторно в Strict Mode?
	1. React повторно вызывает функции компонентов и эффекты, чтобы проверить, правильно ли они чистят ресурсы и не вызывают неожиданных сайд-эффектов при монтировании/размонтировании
95. Как  Strict Mode  помогает улучшить качество кода и отловить ошибки?
	1. Такая проверка помогает заранее выявлять баги, неправильное управление эффектами и состояние, делая код более устойчивым и предсказуемым перед продакшен-сборкой
96. Как настроить Strict Mode?
	1. обернуть компонент в `<React.StrictMode>`.
97. Как получить доступ к контексту без хуков?
	через компонент `<MyContext.Consumer>`. В него передают функцию, которая получает текущее значение контекста.
98. Какие проблемы с производительностью возникают при частых обновлениях контекста?
	1. При изменении значения в провайдере все дочерние компоненты использующие контекст перерендериваются, даже если используют лишь часть данных или не затронуты логикой/
99. Как JSX трансформируется в вызовы `React.createElement`?
	1. JSX — это синтаксический сахар, который во время сборки транспилируется в вызовы `React.createElement`
100. Что такое `ReactElement` и чем он отличается от компонента?
	1. `ReactElement` — это обычный объект, который описывает элемент React: тип (тег или компонент), пропсы и детей. Это «план» для реального DOM. Он не является компонентом и не содержит логики — это результат вызова компонента или JSX.

#### **11. React 18+ Features**

101. Как Automatic Batching работает с промисами и таймерами?
	1. В React 18 Automatic Batching работает со всеми асинхронными операциями. Когда несколько setState вызываются внутри промиса или setTimeout, React автоматически объединяет их в один рендер, что значительно улучшает производительность.
102. В чем разница между React 17 и React 18 batching?
	1. React 17: batching работал только в обработчиках событий React (onClick, onChange и т.д.)
	2. React 18: batching работает везде, включая промисы, таймеры, сетевые запросы и любые другие асинхронные операции
103. Как `flushSync` обходит Automatic Batching?
	1. `flushSync` принудительно выполняет обновление синхронно, игнорируя Automatic Batching. Это полезно когда нужно немедленно применить изменения, например, для измерений DOM или интеграции с внешними библиотеками.
104. Что такое React Compiler?
	1. React Compiler — это  инструмент, который автоматически оптимизирует React код во время компиляции. Он анализирует код и применяет оптимизации, которые раньше требовали ручного написания useMemo, useCallback и других оптимизаций.
105. Как React Compiler оптимизирует код?
	1. React Compiler автоматически мемоизирует компоненты и функции, удаляет ненужные ререндеры, оптимизирует пропсы и состояния. Он делает это на уровне компиляции, что более эффективно чем ручные оптимизации.

## Hooks

106. **Правила хуков**:
	1. Вызывайте их на верхнем уровне в теле компонента функции
	2. Вызывайте их на верхнем уровне в теле пользовательского хука
	3. Не вызывайте хуки внутри условий или циклов.
	4. Не называйте хуки после условного `return` оператора.
	5. Не вызывайте хуки в обработчиках событий.
	6. Не вызывайте хуки в компонентах класса.
	7. Не вызывайте хуки внутри функций, переданных в `useMemo`, `useReducer`, или `useEffect`

**useState**

107. Для чего нужен `useState`?
	1. Чтобы создать локальное состояние в функциональном компоненте.
108. Что возвращает `useState`?
	1. Массив из двух элементов: текущее значение и функция для его обновления
109. Как изменить состояние `useState`?
	1. Вызов setState(newValue) или setState(prev => computeNext(prev))
110. Как обновлять состояние на основе предыдущего значения?
	1. setState(prev => computeNext(prev))
111. Почему `setState` асинхронен, и как это влияет на обновления?
	1. batching группирует обновления, чтобы не делать лишнюю работу. Поэтому `state` не обновляется сразу после вызова `setState`.
112. Что произойдет, если вызвать `setState` с тем же значением?
	1. React использует `Object.is` для сравнения. Если значение не изменилось — ререндер не произойдёт.
113. Как работает shallow compare в `useState`?
	1. Shallow сравнение — `Object.is(prev, next)`. Для объектов и массивов — сравниваются только ссылки.
114. Как работает `useState` при повторных рендерах?
	1. React сохраняет значение в ячейке хука. Инициализация выполняется один раз — при первом рендере.
115. Как правильно обновлять состояние, если оно — объект или массив?
	1. Иммутабельно: setState(prev => ({ ...prev, updated: true }))
116. Почему нельзя вызывать `useState` условно?
	1. Потому что порядок вызовов хуков должен быть стабильным между рендерами
117. В чем отличие `useState` от `useReducer`?
	1. `useState` — для простого состояния. `useReducer` — для сложной логики и вложенных структур. `useReducer` даёт больше контроля и лучше масштабируетс
118. Как ведет себя `useState` при размонтировании компонента?
	1. Хук отрабатывает только при монтировании. После анмаунта `setState` ничего не делает.
119. Как сделать ленивую инициализацию состояния в `useState`?
	1. useState(() => computeExpensiveInitial())
120. В чем разница между `useState(someFunction())`, `useState(someFunction)`, `useState(() => someFunction())`?
	1. `someFn()` — вызов сразу, значение — результат.
	2. `someFn` — функция как значение, не вызовется.
	3. `() => someFn()` — ленивый вызов, только при первом рендере.
121. Можно ли мемоизировать `setState` с помощью `useCallback`?
	1. Можно, но не нужно.`setState` стабилен, ссылка не меняется.
122. Что произойдёт, если передать пропсы как начальное значение в `useState`, а затем эти пропсы изменятся?
	1. Ничего не произойдёт. Начальное значение читается **только при монтировании**. Для синхронизации с пропсами нужен `useEffect`.
123. Как синхронизировать значение useState с передаваемыми компоненту пропсами?
	1. Чтобы синхронизировать `state` с пропсами, нужно использовать `useEffect` с подпиской на нужные пропсы.
124. Что будет если useState при значении объекта через setState присвоить этот же объект.
	1. setObj((obj) => obj) - ничего не будет так как ссылка такая же.
	2. setObj((obj) => {...obj}) - произойдет перерендер так как ссылку уже будет другой.
125. Как избежать stale-значений при обновлении состояния в async-колбэках или таймерах?
	1. Использовать функциональный `setState(prev => ...)`
126. Почему `setState` внутри `useEffect` может зациклить рендер?
	1. Если `setState` вызывается без условий, и обновляемое состояние входит в `deps`, произойдёт бесконечный цикл
127. Как работает batching в React 18 и какие кейсы нарушают его (например, `setTimeout`, промисы)?
	1. React **batch'ит**  несколько вызовов `setState` в один ререндер
	2. после 18 версии  всё, что запущено внутри одного "tick" (микро/макрозадачи), будет батчиться.
	3. flushSync принудительно ререндерит компонент игнорируя batch(инг)


---

**useEffect** и useLayoutEffect

120. Для чего нужен `useEffect`?
	1. `useEffect` позволяет выполнять побочные эффекты
121. Когда вызывается `useEffect`?
	1. После рендера, **асинхронно**, уже после того как браузер нарисовал DOM.
122. какие параметры принимает useEffect?
	1. callback: () => void — основная функция с эффектом;
	2. `deps: any[]` — массив зависимостей (опционально)
123. Что возвращает useEffect?
	1. Ничего сам по себе (undefined). Но колбэк может вернуть **функцию очистки** — она вызовется при размонтировании или перед следующим выполнением эффекта.
124. Как работает массив зависимостей?
	1. React сравнивает зависимости (по `Object.is`). Эффект выполняется **только если хотя бы одна зависимость изменилась**. Если массив пустой — выполнится один раз при монтировании.
125. Что будет, если не указать зависимости?
	1. Эффект будет выполняться **после каждого рендера**
126. Как выполнить эффект только примонтировании?
	1. Передать пустой массив зависимостей:
127. Как использовать `useEffect` с асинхронными функциями?
	1. Нельзя сделать сам `useEffect` async, но можно в callback создать асинхронную функцию и вызвать ее
128. Что такое функция очистки (cleanup)?
	1. Это функция, которую может возвращать callback. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента.
	2. Используется для отмены подписок, таймеров, abort-controllers и т.п.
129. Когда вызывается функция очистки?
	1. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента.
130. Как отменять асинхронные операции в useEffect?
	1. AbortController для запросов
	2. флаг переменную 
131. Чем `useEffect` отличается от `useLayoutEffect`?
	1. `useEffect`: вызывается **асинхронно**, **после** рендера и отрисовки.
	2. `useLayoutEffect`: вызывается **синхронно**, **до** отрисовки браузером и может блокировать отрисовку.
136. Что такое “useEffect первого рендера” и “useEffect обновления”? Как их различать?
	1. **useEffect первого рендера**: выполняются один раз при монтировании (`useEffect(() => {...}, [])`).
	2. **useEffect обновления**: выполняются при изменении зависимостей (`useEffect(() => {...}, [a, b])`).
134. Как избежать гонки состояний (race conditions) в асинхронных эффектах?
	1. Используй `AbortController`, флаги `isMounted`
135. Почему нельзя делать `await` напрямую в `useEffect(callback)`?
	1. Потому что `useEffect` должен возвращать либо **undefined**, либо **функцию очистки**.  `async` функция **всегда возвращает Promise**, что нарушает контракт
136. Как правильно использовать эффекты с подписками на внешние источники (WebSocket, Observer, EventListener)?
	1. Создай подписку в `useEffect`
	2. Вернуть функцию очистки, чтобы отписаться при размонтировании или повторном вызове.
137. Что произойдёт, если не использовать функцию очистки при подписке?
	1. Повторные подписки → **дублирование событий**
	2. неактуальные колбэки
	3. **Утечка ресурсов**
138. Чем отличается порядок выполнения нескольких `useEffect` в одном компоненте?
	1. Они **выполняются сверху вниз**, в **порядке объявления**. Это важно, если между ними есть зависимость:
142. Как влияет Strict Mode на вызовы `useEffect` (дважды)? Как это влияет на эффекты с побочками?
	1. `useEffect` вызывается **дважды** (монтирование → размонтирование → повторное монтирование)
	2. Цель — поймать ошибки в **нечистых эффектов**, например, без `cleanup` 

---

**useRef**

147. Для чего нужен `useRef`?
	1. Также — для доступа к DOM-элементам.
	2. Чтобы хранить значения, которые **не вызывают ререндер** при изменении. 
148. Варианты использования useRef?
	1. Доступ к DOM
	2. Хранение значения между рендерами
	3. Предыдущее значение
	4. Флаг "монтирован"
	5. Таймеры, id, внешние инстансы
149. Как получить доступ к DOM-элементу с помощью `useRef`
	1. Прокинуть в атрибут ref html тега переменную которой присвоили useRef()
150. Что хранится в `.current`?
	1. В поле `.current` хранится **текущее значение**, которое  туда положили. По умолчанию — значение, переданное в `useRef(initialValue)`
151. Можно ли изменять `.current`?
	1. Да, через ref.current = newValue
152. Вызывает ли изменение `.current` перерендер?
	1. `useRef` не триггерит повторный рендер, в отличие от `useState`.
153. Как использовать `useRef` для хранения значений между рендерами?
	1. Любое значение присвоенное ref.current мутабельно, достпуно для использования и сохраняется между перерендерами.
154. Чем `useRef` отличается от `useState`?
	1. `useRef` не вызывает ререндер при изменении.
	2. `useState` — триггерит ререндер.
155. Как использовать `useRef` для хранения предыдущего значения?
	1. Любое значение присвоенное ref.current мутабельно, достпуно для использования и сохраняется между перерендерами.
156. Как `useRef` помогает избежать лишнего рендера в `onScroll`, `onResize` и других частых ивентах?
	1. При `onScroll`, `onResize` и подобных событиях **состояние часто обновляется**, но перерендер при каждом изменении — дорого. `useRef` позволяет **сохранять значения между рендерами**, не триггеря ререндер.
157. Можно ли использовать `useRef` как глобальный стейт? Почему это плохая идея?
	1. **Можно, но не нужно.** так как 
		1. `useRef` — **локален компоненту**
		2. не вызывает ререндер
		3. не реактивен — другие компоненты не узнают об изменении
158. Как связать `useRef` и `forwardRef` для передачи доступа к DOM наружу?
	1. `forwardRef` нужен, чтобы пробросить `ref` от родителя к DOM-элементу внутри компонента.
---

**useMemo**
159. Что такое `useMemo`?
	1. `useMemo` — это хук, который **мемоизирует результат вычисления** между рендерами, чтобы не пересчитывать заново, если зависимости не изменились
160. Какие аргументы принимает `useMemo`?
	1. Функция, которая возвращает значение
	2. Массив зависимостей (`deps`)
161. Что возвращает `useMemo`?
	1. Результат выполнения переданной функции — **мемоизированное значение**.
162. Когда применять `useMemo`?
	1. Дорогие вычисления
	2. Передача стабильной ссылки в зависимости
	3. Оптимизация рендеров дочерних компонентов
163. Когда `useMemo` бесполезен?
	1. Преждевременная мемоизация **нагружает память и CPU**.
	2. Если вычисление дешёвое
	3. Если часто меняются зависимости и значение всегда пересчитывается
	4. Если нет проблем с производительностью
164. Как работает мемоизация в `useMemo`?
	1. React **запоминает результат** выполнения функции
	2. При следующем рендере **сравнивает зависимости**
	3. Если зависимости **не изменились** (`Object.is`) — возвращает **кэш, иначе — **пересчитывает**
165. Что произойдёт, если не указать массив зависимостей?
	1. Функция будет **перевычисляться при каждом рендере**
166. Когда `useMemo` может навредить производительности?
	1. Если мемоизируется **дешёвая логика**
	2. Если зависимости часто меняются
	3. Если много `useMemo` — **меньше GC**, **больше памяти**
167. Как `useMemo` сравнивает зависимости (по ссылке или по значению)?
	1. По ссылке, через `Object.is()`:
168. Как `useMemo` ведёт себя в React Concurrent Mode?
	1. В Concurrent Mode `useMemo` ведёт себя также, как и другие React-хуки: результат мемоизации сохраняется **только после коммита**. Если рендер был прерван, результат `useMemo` **не сохраняется**, и при следующем рендере функция будет вызвана снова
169. Чем `useMemo` отличается от мемоизации вне React (например, lodash.memoize)?
	1. `useMemo` — это **hook**, встроенный в React-цикл рендеринга и зависящий от зависимостей и жизненного цикла компонента. Он **автоматически сбрасывается** при размонтировании компонента.  
	2. В отличие от него, `lodash.memoize` — это **императивная мемоизация**, работающая вне контекста React и требующая ручного контроля над кэшем. Она сохраняет результат в глобальном или внешнем кэше и не зависит от ререндеров.
170. Как `useMemo` влияет на память и сборку мусора?
	1. Каждый `useMemo` сохраняет результат в кэше до тех пор, пока компонент не размонтируется или зависимости не изменятся. Если `useMemo` используется без нужды (например, для дешёвых вычислений), это может **увеличить потребление памяти**, замедлить сборку мусора и создать **лишнюю нагрузку на CPU** из-за отслеживания зависимостей
171. Как `useMemo` взаимодействует с Suspense?
	1. В режиме Suspense, если рендер компонента прерывается из-за "зависания" на промисе (например, в data fetching), `useMemo` работает аналогично Concurrent Mode: результат **не кэшируется**, пока не произойдёт успешный коммит. Это значит, что функция в `useMemo` может вызываться **повторно** при каждом новом рендере, до тех пор, пока Suspense не завершит ожидание.
172. Какие ошибки возникают при неправильном указании зависимостей?
	1. Если зависимости `useMemo` указаны неправильно (например, не указаны значения, от которых зависит вычисление), могут возникнуть **баги со stale values**: мемоизированное значение будет пересчитываться реже, чем нужно, и может стать **неактуальным**. Это приводит к неконсистентному UI, неверным данным или логике.

---

**useCallback**

173. Что такое `useCallback`?
	1. `useCallback` — это хук, который **мемоизирует функцию**, чтобы она сохраняла **стабильную ссылку** между рендерами, если не изменились зависимости.
174. Какие аргументы принимает `useCallback`?
	1. Колбэк-функция (возвращается как есть, **не вызывается**)
	2. Массив зависимостей
175. Что возвращает `useCallback`?
	1. Мемоизированную функцию
176. Когда применять `useCallback`?
	1. Когда нужно **передать функцию в memoized-компонент**
	2. В `useEffect` / `useMemo` / `setInterval` — когда функция зависит от стабильности ссылки
	3. Для оптимизации компонентов, избегающих лишнего рендера по ссылке на колбэк
177. Когда `useCallback` бесполезен?
	1. Если компонент не зависит от стабильности функции
	2. Если функция пересоздаётся каждый раз из-за нестабильных зависимостей
	3. Если перерисовки и так дешёвые
178. Что будет, если функция в useCallback зависит от внешних значений, а они не указаны в зависимостях?
	1.  баг: внутри функции будут **устаревшие значения** (stale closure).
179. Чем отличается `useCallback` от `useMemo`?
	1. useCallback
		1. Мемоизирует **функцию**
		2. Возвращает саму функцию
	2. useMemo
		1. Мемоизирует **значение**
		2. Возвращает результат вызова
180. Когда стоит предпочесть `useCallback` вместо обычной функции?
	1. Когда функция **передаётся вниз** (в props) и нужно **избежать лишнего рендера** дочернего `React.memo` компонента
	2. Когда функция участвует в **зависимостях эффекта**, и  нужна **стабильная ссылка**
181. можно ли заменить useCallback c помощью useMemo?
	1. Да. но не рекомендуется из-за неочевидности:
182. Как избежать stale closure (устаревших значений) при использовании `useCallback`?
	1. Чтобы избежать stale closure, необходимо указывать в массиве зависимостей все значения, на которые ссылается колбэк: пропсы, стейт и любые переменные из внешней области. Это гарантирует, что функция будет пересоздана при изменении нужных данных и всегда работать с актуальными значениями.**
183. Как `useCallback` работает в Concurrent Mode?
	1. `useCallback` — не сохраняется между прерванными рендерами, пока не завершится коммит.
	2. Но после успешного коммита, возвращаемая функция будет **стабильна**, если зависимости не поменялись.
184. Почему нельзя мемоизировать колбэк с пустым массивом зависимостей, если внутри используются пропсы/стейт?
	1. Пустой массив зависимостей фиксирует колбэк навсегда после первого рендера. Если в теле функции используются внешние значения, они будут захвачены однажды и больше не обновятся. Это приведёт к использованию устаревших данных и нарушит ожидаемое поведение компонента.
185. Можно ли комбинировать `useCallback` с `useMemo`? В каких случаях?
	1. Комбинация возможна и уместна, когда требуется создать мемоизированную структуру, содержащую функции, и сохранить стабильность всей структуры между рендерами.
186. Чем `useCallback` отличается от простого объявления функции внутри компонента?
	1. Функция, объявленная внутри компонента без `useCallback`, пересоздаётся при каждом рендере и всегда имеет новую ссылку. `useCallback` позволяет сохранить ссылку на функцию между рендерами при условии, что зависимости не изменились


---

**useId**

187. Для чего используется `useId`?
	1. нужен для генерации **уникального, стабильного ID**, который синхронизируется между сервером и клиентом. 
	2. полезен для привязки `label` ↔ `input`, `aria-describedby`, и в компонентах, рендерящихся и на сервере, и на клиенте.
188. Как работает `useId`?
	1. React генерирует **уникальный, стабильный префикс** независимо от количества ререндеров
189. можно ли использвоать хук useId в серверных компонентах?
	1. Да. `useId` **безопасен для Server Components** и работает и на сервере, и на клиенте. Это одна из его задач — **избежать mismatch при гидратации**
190. Как `useId` помогает при серверном рендеринге (SSR)?
	1. `useId` гарантирует **одинаковый ID** на обеих сторонах (в отличии от `Math.random()`, `uuid`), потому что React сам контролирует генерацию и встраивает метаданные в HTML.
191. В чём отличие `useId` от генерации ID через `Math.random()` или другие способы?
	1. Стабильный между рендерами
	2. Работает при SSR-гидратации
	3. безопасен для accessibility
192. Можно ли использовать `useId` для генерации ключей в списках?
	1. **Нет.** Ключи в списках должны быть **детерминированы по данным**, иначе при изменении порядка или количества элементов React будет **пере-монтировать** всё.
193. Что будет, если использовать `useId` в компоненте, который ререндерится много раз?
	1. `useId` стабилен — он выдаёт **одно и то же значение** между рендерами, пока компонент не размонтируется.
194. Какие проблемы решает `useId` в контексте accessibility?
	1. Для доступности важно, чтобы `label` имел `htmlFor={id}`, а `input` — `id={sameId}`. Если ID разные на сервере и клиенте — атрибут `for` указывает не туда → **screen reader не сможет связать label и поле**. `useId` даёт **одинаковый ID** и решает эту проблему.
195. Как `useId` ведёт себя при гидратации SSR?
	1. React знает, как синхронизировать ID, сгенерированные на сервере и клиенте, чтобы избежать ошибок.  Это происходит через встроенные маркеры в HTML, которые позволяют React **восстановить правильный state без mismatch**.
196. Как `useId` генерирует ID в конкурентном режиме?
	1. `useId()` генерирует **стабильный уникальный ID**, который:
	2. **Не зависит от порядка рендера** и не сбивается даже при конкурентных прерываниях (`concurrent rendering`), т.к. не использует счётчики, как `useRef` или инкремент.
197. Есть ли ограничения по количеству вызовов `useId` в одном компоненте?
	1. Нет, **жёстких ограничений нет** —  можно вызывать `useId` сколько угодно раз и каждый вызов `useId()` вернёт **уникальный ID**, даже в одном компоненте.
198. Как `useId` ведёт себя при гидратации в SSR с использованием React Suspense?
	1. - **React гарантирует**, что `useId()` возвращает **одинаковое значение** на сервере и клиенте. Это особенно важно при использовании `Suspense`, где часть дерева может быть отложена, что **меняет порядок вызова хуков**.
	2. ID детерминированный, стабилен даже при `Suspense`, `startTransition`, и других асинхронных рендерах.

---


**useContext**

199. Для чего нужен `useContext`?
	1. Чтобы получать значение из контекста
200. Как создать и экспортировать контекст в React?
	1. export const ThemeContext = React.createContext(null);
201. Как использовать `useContext` для получения значения из контекста?
	1. const theme = useContext(ThemeContext);
202. Можно ли использовать `useContext` вне компонента? Почему?
	1. Нельзя. `useContext` — это хук, он должен вызываться **внутри функционального компонента** или другого хука
203. Как `useContext` работает при обновлении значения в провайдере?
	1. Если значение контекст меняется, **все потомки**, использующие `useContext`, **перерисуются**.  
	2. React сравнивает по `Object.is`.
204. Как избежать лишних рендеров при использовании `useContext`?
	1. Мемоизировать value
	2. Разделить контексты: один для данных, другой для диспатча (Pattern: `StateContext` + `DispatchContext`)
	3. Вынести `useContext` ближе к месту, где нужен
205. Можно ли использовать несколько контекстов одновременно? Как это делать?
	1. Да. Просто вложив провайдеры друг в друга
206. Когда использовать `useContext`, а когда — глобальные стейты типа Redux или Zustand?
	1. Используй `useContext` для **UI-состояния и небольших кусков**, Redux/Zustand — если **данные масштабируются и делятся между многими частями приложения**.
207. Как работает `useContext` с серверным рендерингом (SSR)?
	1. unknow
208. Какие ограничения и подводные камни есть у `useContext`?
	1. Все потребители перерисуются при **любом изменении value**
	2. Плохая производительность при больших объектах в value
	3. Нельзя вызывать вне компонента
	4. Мутирование объекта в value не вызовет ререндер
209. Как работает обновление контекста при вложенных провайдерах с одинаковым типом?
	1. Если компонент обернут во **вложенные `<Context.Provider>` одного и того же контекста**, то `useContext(Context)` всегда читает **ближайший вверх по дереву** `Provider`
210. Как `useContext` влияет на производительность в больших приложениях?
	1. при **любом изменении value** в `Provider`, все компоненты, читающие этот контекст (через `useContext`), **перерисовываются**, даже если они используют только часть value.
	2. Это связано с тем, что React делает сравнение по `Object.is(value)` на уровне `Provider`.
211. Как обрабатывать ошибки при чтении контекста вне провайдера?
	1. Создай обёртку-хук:
	2. function useStrictContext() {
		  const context = useContext(MyContext);
		  if (!context) {
	    throw new Error('useMyContext должен вызываться внутри <MyContext.Provider>');
		  }
		  return context;
		}
212. Какие альтернативы `useContext` для глобального состояния и когда их лучше применять?
	1. Zustand, Redux + RTK, Recoil
	2. `useContext` хорошо работает для:
		1. UI-состояния
	    2. локальных настроек
		3. небольшого шаринга между родителем и потомками

---

**useReducer**

213. Что такое `useReducer` и для чего он нужен?
	1. Это хук для управления **сложным или предсказуемым состоянием**
214. Какие параметры принимает useReducer?
	1. `reducer`: Редюсер — чистая функция, которая определяет логику обновления состояния. Редюсер принимает два аргумента – состояние и действие, и возвращает следующее состояние. Состояние и действие могут быть любых типов.
	2. `initialArg`: Значение на основе которого вычисляется начальное состояние. Значение начального состояния может быть любого типа. То как из него будет вычисляться начальное состояние, зависит от аргумента `init`.
	3. `init`:(jgwbjyfkmyj) Функция инициализатора, которая возвращает начальное состояние. Если она не указана, то начальное состояние устанавливается в `initialArg`. В противном случае начальное состояние устанавливается в результат вызова `init(initialArg)`.
215. Чем отличается `useReducer` от `useState`?
	1. `useState` → императивный: напрямую задаёшь новое значение
	2. `useReducer` → декларативный: ты диспатчишь событие (`dispatch(action)`), и **редьюсер решает**, как изменится состояние.
	3. `useReducer` легче масштабировать
216. Как устроена редьюсер-функция? Какие параметры она принимает?
	1. Редьюсер — это чистая функция:
	2. (state, action) => newState, где 
		1. `state` — текущее состояние.
		2. `action` — объект, описывающий событие
	3. Возвращает новое состояние. Не мутирует предыдущее.
217. Что возвращает `useReducer`?
	1. Массив из двух значений: 
		1. - `state` — текущее состояние.
		2. `dispatch` — функция, которая запускает редьюсер.
218. Что такое функция dispatch?
	1. `dispatch(action)` — это функция, которая передаёт `action` в редьюсер и вызывает пересчёт нового состояния.
219. Как задать начальное состояние и как сделать ленивую инициализацию?
	1. через initFn
	2. `initialArg` — любое значение (можно `undefined`).
	3. `initFn(initialArg)` - возвращает **начальное состояние** (вызывается один раз).  
220. Как работает dispatch? Можно ли вызывать dispatch асинхронно?
	1. `dispatch` **синхронно ставит обновление в очередь**, но **перерендер происходит асинхронно** (в batched-режиме React).
	2. `dispatch` сам не поддерживает `async/await`, но  можно вызывать его из `useEffect`, `async function`, `setTimeout` и т.д.
221. Как использовать `useReducer` с асинхронными операциями?
	1. Асинхронность обрабатывается **вне редьюсера**, а сам редьюсер — синхронный.
222. Как использовать `useReducer` вместе с `useContext` для глобального стейта?
	1. Создаёшь контекст, в который кладёшь `[state, dispatch]`.
	2. Оборачиваешь `Context.Provider` вокруг `<App>`.
	3. Любой компонент может использовать `useContext(Context)` - получает `state` и `dispatch`.
223. Как React 18+ улучшает работу с `useReducer` (например, конкурентный режим и приоритеты обновлений)?
	1. Обновления через `dispatch` теперь участвуют в **automatic batching**.
224. Что происходит, если вызвать dispatch после размонтирования компонента?
	1. Никакой ошибки не будет, но `dispatch` вызовет **ничего** — компонент уже не существует.
	2. Решение — проверять `isMounted` через `useRef` или отменять побочные эффекты в `cleanup`.
225. Почему редьюсер должен быть чистой функцией? Какие проблемы возникают при мутации?
	1. Редьюсер обязан быть чистой функцией, потому что React полагается на **сравнение по ссылке**, чтобы понять, произошло ли изменение состояния.Если  внутри редьюсера мутировть объект, но возвращать ту же ссылку, React не задетектит изменения и не перерендерит компонент
226. Как избежать вызова dispatch после размонтирования компонента?
	1. В `useEffect` можно установить флаг при монтировании и сбросить его в `cleanup`
	2. Перед вызовом `dispatch` проверять этот флаг.
227. Можно ли использовать несколько редьюсеров в одном компоненте?
	1. Да, можно, каждый `useReducer` управляет своей частью данных и не зависит от других.
228. Как обновлять части состояния, если state — объект или массив, чтобы избежать мутаций?
	1. Вместо мутаций  создавать новую версию объекта или массива, копируя неизменённые части.
229. В чём различия между `useReducer` и Redux-подходом?
	1. `useReducer` — это локальный инструмент, предназначенный для управления сложным состоянием внутри одного компонента или изолированной части UI. Redux — это глобальный store, ориентированный на управление состоянием всего приложения

-----
1. useTransition
    
2. useDeferredValue
    
3. useSyncExternalStore
    
4. useInsertionEffect
    
5. useImperativeHandle
    
6. useDebugValue
    
7. useEvent
    
8. useOptimistic
    
9. useActionState

---