#### 1. Virtual DOM и Reconciliation

1. Что такое Virtual DOM в React и зачем он нужен?
	1. Virtual DOM - это абстрактное представление UI в виде дерева обычных JavaScript-объектов, которые отражают структуру реального DOM. React использует его, чтобы оптимизировать и контролировать обновления интерфейса.
2. Как работает Virtual DOM в React — от создания до обновления реального DOM?
	1. Компонент возвращает JSX которое затем превращается в дерево Virtual DOM.
	2. При изменении состояния или пропсов React создаёт новое дерево VDOM.
	3. React сравнивает новое и старое дерево (алгоритм diff).
	4. Вычисляется минимальный набор изменений (patch)
	5. Реальный DOM обновляется точечно, на основе diff-а.
3. Какие события в React приводят к пересозданию/обновлению Virtual DOM?
	1. Изменение props компонента
	2. Изменение контекста через useContext
	3. Монтирование и размонтирование компонентов
	4. Изменение состояния через useState или useReducer
	5. Любые изменения данных, влияющие на вывод JSX
4. Где выполняется Virtual DOM в React (в какой среде/памяти)?
	1. Virtual DOM работает в памяти JavaScript-движка, то есть в оперативной памяти (RAM) браузера, внутри JavaScript-окружения
5. Из каких структур данных состоит Virtual DOM в React?
	1. Virtual DOM состоит из JavaScript-объектов, каждый из которых представляет один UI-элемент (аналог узла DOM)
6. Почему Virtual DOM эффективнее прямых манипуляций с DOM?
	1. Прямые манипуляции с DOM вызывают дорогостоящие затраты браузера на layout/repaint.
	2. Virtual DOM работает с UI в памяти
	3. Обновления происходят в памяти, что позволяет вычислять минимальный набор изменений (diffing) и применять их пакетно, снижая количество дорогостоящих операций с реальным DOM
7. Как работает алгоритм diffing в React при сравнении изменений в Virtual DOM и какова его сложность?
	1. React использует эффективный алгоритм diffing с линейной сложностью O(n)
	2. Сравнивает элементы сверху вниз и слева направо.
	3. Если у элементов разный type (например, div и span или разные компоненты), React полностью заменяет соответствующее поддерево.
	4. Если type совпадает, React сравнивает props и рекурсивно переходит к сравнению детей.
	5. При сравнении детей React ориентируется на позицию элементов и key
		1. Если ключи присутствуют, используется сопоставление по ним для эффективной обработки добавлений, удалений и перемещений.
		2. Без ключей сравнение идёт по индексу, что менее эффективно и может привести к лишним обновлениям.
8. Что такое ключи (key) в React и как они влияют на сравнение элементов в списках?
	1. Ключи (key) — это уникальные идентификаторы элементов списка, которые React использует для сопоставления элементов между старым и новым деревом
	2. Если ключи присутствуют, React сопоставляет элементы по ним, что позволяет эффективно выявлять  добавленные, удалённые перемещённые элементы.
	3. Без ключей React сравнивает элементы по их позиции (индексу) в массиве

#### 2. Fiber Architecture

9. Что такое архитектура React Fiber и чем она отличается от прежнего Stack Reconciler?
	1. Прерываемость
	2. Приоритезация
	3. Инкрементальный рендеринг
10. В чём недостатки старого синхронного reconciler'а по сравнению с React Fiber?
	1. Старый Virtual DOM работал синхронно и непрерываемо, что приводило к блокировкам UI при больших обновлениях.
	2. Отсутствие приоритезации обновлений: все обновления обрабатывались с одинаковым приоритетом.
	3. Нельзя было прервать, отложить или отменить рендеринг, что негативно влияло на отзывчивость интерфейса.
	4. Отсутствие инкрементального (пошагового) рендеринга
	5. Отсутствие возможности прерывать и возобновлять рендеринг с учётом приоритетов.
11. Почему React Fiber использует связный список для обхода дерева, а не рекурсию?
	1. Связный список позволяет React:
		1. Выполнять обход дерева итеративно, без глубокого рекурсивного стека, что снижает риск переполнения стека
		2. Прерывать и возобновлять рендеринг
		3. Управлять приоритетами задач и планировать работу по частям
	2. Рекурсия же требует полного прохода и не позволяет прерывать работу посередине.
12. Как используется связный список узлов в React Fiber для обхода дерева?
	1. это структура из объектов FiberNode, где каждый узел содержит ссылки:
		1. child — на первого потомка,
		2. sibling — на следующего брата (соседа),
		3. return — на родителя.  
    1. Так можно пройти всё дерево последовательно, переходя от родителя к первому ребёнку, потом к соседям, обходя дерево без рекурсии.
13. Что такое FiberNode в React и как он устроен?
	1. FiberNode — это объект, представляющий один узел дерева Fiber. Он содержит всю информацию, необходимую React для управления рендерингом и обновлением конкретного UI-элемента
14. Какие ключевые поля содержит объект FiberNode и что каждое из них означает?
	1. stateNode — ссылка на реальный инстанс, связанный с этим узлом (DOM-элемент, экземпляр класса, или null для функциональных компонентов).
	2. return — ссылка на родительский FiberNode, позволяющая подниматься вверх по дереву.
	3. child — ссылка на первый дочерний FiberNode, начало обхода детей.
	4. sibling — ссылка на следующий соседний FiberNode на том же уровне.
	5. flags — битовая маска, указывающая, какие операции (вставка, обновление, удаление) нужно выполнить с этим узлом.
15. Как поля return, child и sibling в FiberNode обеспечивают безрекурсивный обход дерева Fiber?
	1. Поле child позволяет спуститься вниз по дереву
	2. поле sibling — перейти к соседнему узлу на том же уровне
	3. поле return — подняться вверх к родителю после обхода всех детей.
	4. Вместе они реализуют итеративный обход дерева, заменяющий рекурсию, что даёт контроль над процессом рендеринга и позволяет прерывать и возобновлять работу.
16. Какие бывают типы флагов (flags) в FiberNode и какие операции они обозначают?
	1. flags — это битовая маска, которая сообщает React, какие действия нужно выполнить над узлом на этапе commit. Основные флаги:
		1. Placement — узел нужно вставить в DOM (новый элемент).
    	1. Update — узел нужно обновить (например, props или DOM-атрибуты).
		1. Deletion — узел нужно удалить из DOM.
		2. ChildDeletion — удалить одного или нескольких потомков.
		3. Ref — обновить ref.
		4. Passive — выполнить эффекты useEffect.
17. Что такое двойная буферизация (double buffering) в React Fiber и зачем она нужна?
	1. Двойная буферизация в Fiber — это хранение двух деревьев (current и working) для безопасного обновления UI без блокировок: изменения делают в рабочем дереве, а после завершения заменяют текущее.

#### 3. Fiber Render Process

18. Что такое work loop в React Fiber и как он организует процесс рендеринга?
	1. Work loop в React Fiber — это основной цикл, в котором React пошагово обходит дерево Fiber, создаёт/обновляет FiberNode'ы и готовит дерево к коммиту. Он лежит в основе инкрементального, прерываемого рендеринга.
19. Как связный список в React Fiber позволяет прерывать и возобновлять рендеринг?
	1. обход дерева — это итеративный процесс с явным хранением текущей позиции, это позволяет просто сохранить состояние обхода (текущий узел), остановить цикл и освободить основной поток для других задач, при следующем вызове React продолжит обход с сохранённого узла, а не начинает заново или не уходит в глубокую рекурсию
20. Как обновляется UI в React Fiber: полный цикл от setState до отрисовки?
	1. Инициирование обновления
		1. создаётся объект обновления, который добавляется в очередь обновлений соответствующего FiberNode.
	2. Приоритезация
		1. Обновление получает приоритет через систему Lanes.  
	3. Планирование задачи (Scheduler)
		1. Scheduler решает, когда запускать работу: сразу (высокий приоритет) или отложить (низкий).
	4. Render-фаза (Reconciliation) - эта фаза прерываема и инкрементальна, может быть приостановлена и возобновлена.
		1. Создаётся новое дерево work-in-progress (рабочее дерево Fiber) на основе текущего.
		2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов
	5. Завершение render-фазы
		1. После обхода дерева React формирует полный список эффектов для commit-фазы.
	6. Commit-фаза (синхронная, непрерываемая)
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала useLayoutEffect cleanup, потом useEffect cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции useLayoutEffect
		4. Выполняются функции useEffect
	7. Обновление текущего дерева
		1. Рабочее дерево work-in-progress становится текущим (current), старое может быть удалено или повторно использовано
21. Какие фазы включает процесс обновления в React Fiber?
	1. Reconciliation (render фаза) - Прерываемая и инкрементальная.
	2. Commit фаза - Синхронная и непрерываемая.
22. Чем отличаются фазы в Fiber и какую роль они играют в обновлении UI?
	1. Reconciliation (render фаза) - отвечает за подготовку и планирование изменений
	2. commit фаза - за их окончательное применение и взаимодействие с DOM.
23. Что происходит в React в фазе Render (reconciliation)?
	1. Создаётся новое дерево work-in-progress на основе текущего.
	2. React обходит дерево итеративно (work loop), создаёт новые или обновляет существующие FiberNode'ы, собирает список эффектов
	3. После обхода дерева React формирует полный список эффектов для commit-фазы.
	4. Фаза может быть прервана и возобновлена, чтобы избежать блокировки основного потока
24. Что происходит в React в фазе Commit?
		1. Фаза размонтирования эффектов
			Запускаются функции очистки (cleanup) эффектов из предыдущего рендера: сначала useLayoutEffect cleanup, потом useEffect cleanup
		2. Mutation этап
			1. React применяет изменения в DOM: удаление, вставка, обновление
		3. Выполняются функции useLayoutEffect
		4. Выполняются функции useEffect
		5. Commit-фаза не прерывается, чтобы гарантировать консистентность DOM
25. Что такое Effect List в React Fiber и для чего он используется?
	1. это связанный список узлов Fiber с помеченными изменениями, которые React последовательно применяет к DOM и запускает соответствующие эффекты в фазе commit.
26. Как в React формируется и используется Effect List?
	1. Во время render-фазы React при обходе work-in-progress дерева помечает каждый FiberNode с изменениями специальными флагами
	2. Эти помеченные узлы собираются в Effect List — связанный список эффектов, которые нужно применить.
	3. В commit-фазе React последовательно проходит по Effect List и выполняет соответствующие операции

#### 4. Priority System and Scheduling

27. Как работает система приоритетов в React Fiber и как она влияет на рендеринг?
	1. Каждое обновление получает приоритет — через механизм Lanes.
	2. React сначала обрабатывает более приоритетные задачи (например, ввод), менее важные — откладывает.
28. Что такое модель приоритетов Lane в React и как она работает?
	1. Lane-модель — система приоритизации обновлений в React Fiber, где каждое обновление относится к одной или нескольким lanes — битовым флагам разного приоритета.
29. Какие типы (lanes) существуют (SyncLane, InputContinuousLane, DefaultLane и др.)?
	1. SyncLane — максимальный приоритет, обновления должны выполниться сразу (например, flushSync).
	2. InputContinuousLane — приоритет интерактивного ввода, чтобы UI был отзывчивым.
	3. DefaultLane — обычные фоновые обновления.
30. Что такое Scheduler в React и за что он отвечает?
	1. Это планировщик задач React, который решает, когда и с каким приоритетом запускать работу по обновлению UI. Он координирует выполнение render-фазы, позволяя прерывать низкоприоритетные задачи ради более важных
31. Как Scheduler в React выбирает приоритет задач?
	1. Scheduler использует lanes и сопоставляет их с уровнями приоритетов.
	2. Задачи с более высоким приоритетом прерывают текущие и запускаются раньше
32. Что делает flushSync и как он обходит приоритезацию?
	1. flushSync — функция, которая запускает обновление синхронно, игнорируя систему приоритетов и асинхронность Scheduler. Она принудительно выполняет render и commit сразу, чтобы обновление UI произошло немедленно
33. Что такое конкурентный рендеринг (Concurrent Features) в React и чем он отличается от синхронного?
	1. Concurrent Mode - новый способ работы React с рендерингом, при котором React не блокирует основной поток на долгое время, а разбивает работу на небольшие части (инкрементальный рендеринг).
	2. Позволяет React приостанавливать, возобновлять и приоритезировать работу по обновлению интерфейса.
34. Что такое time slicing в React и зачем он нужен?
	1. механизм в React Fiber, который разбивает работу по рендерингу на небольшие части. React выполняет эти части по очереди, прерываясь по тайм-ауту, чтобы дать браузеру возможность обрабатывать пользовательские события и другие задачи.
	2. Time slicing реализуется за счёт итеративного обхода дерева Fiber с сохранением состояния, чтобы при возобновлении рендеринга продолжить с того места, где остановились.
35. Как React прерывает и возобновляет рендеринг (time slicing)?
	1. React разбивает работу рендера на небольшие задачи — единицы работы (units of work).
	2. При достижении лимита времени текущая задача прерывается, текущее состояние обхода (nextUnitOfWork) сохраняется.
	3. В следующий момент React возобновляет обход с сохранённой позиции, позволяя браузеру обрабатывать важные события между этими фрагментами работы
36. Как React Suspense использует механизм прерывания рендера?
	1. Suspense позволяет React прервать рендеринг компонента, если он «зависает» на асинхронной операции (например, загрузке данных или кода).
	2. React отменяет текущую работу по рендеру, показывает fallback UI, а затем возобновляет рендеринг, когда асинхронная операция завершена.

#### 5. Server-Side Rendering and Hydration

37. Как в React работает гидратация (hydration) после серверного рендеринга (SSR)?
	1. Сервер присылает готовую страницу с уже заполненным HTML
	2. Браузер показывает этот HTML — пользователь сразу видит контент, даже если JS ещё не загрузился.
	3. После загрузки JS React берёт этот HTML и «подключает» к нему свою логику: навешивает обработчики событий, создаёт внутренние структуры для управления состоянием.
	4. React не рисует заново весь UI, а работает поверх уже существующего DOM, делая его интерактивным.
38. Что такое selective hydration в React и как она ускоряет загрузку?
	1. Selective hydration — это стратегия, при которой React не гидратирует сразу всё дерево, а по частям и с приоритетом. Например, сначала гидратируются видимые пользователю интерактивные части, а остальные — позже или при взаимодействии.
39. Что такое React Server Components и чем они отличаются от клиентских?
	1. Server Components — это React-компоненты, которые рендерятся только на сервере. Они не попадают в клиентский бандл, не запускают JS в браузере и позволяют значительно уменьшить размер кода на клиенте. Серверные компоненты могут напрямую обращаться к базе данных или файловой системе и отправлять готовый HTML, облегчая загрузку и повышая производительность
40. Что такое серверные функции (Server Actions) в React и когда их использовать?
	1. Серверные функции (Server Actions) — это функции, которые выполняются на сервере по вызову из React-компонента. Они могут обрабатывать данные, выполнять бизнес-логику или работать с API, при этом не отправляя клиенту лишний JavaScript
41. Что означает директива use client в React и когда её использовать?
	1. строчка в начале файла которая указывает, что компонент должен рендериться и работать на клиенте.
42. Что означает директива use server в React и когда её использовать?
	1. строчка в начале файла указывает, что функция или компонент выполняется только на сервере.
43. Что можно делать в серверных компонентах React, чего нельзя в клиентских?
	1. доступ к базе данных, файловой системе, секретам
	2. использовать серверные зависимости (например, fs, pg, bcrypt)
44. Что можно делать в клиентских компонентах React, чего нельзя в серверных?
	1. использовать:
		1. браузерные API
		2. Хуки react
		3. обработчики событий
		4. манипулировать с DOM
45. Что такое Streaming SSR в React и как он работает?
	1. Streaming SSR — это возможность React отдавать HTML по мере готовности дерева пока React рендерит все по частям
	2. Работает через renderToPipeableStream (Node.js) или renderToReadableStream (Edge/Cloud).
46. Что такое hydration mismatch в React и почему он возникает?
	1. Hydration mismatch — это ситуация, когда HTML, пришедший с сервера (SSR) не совпадает с тем, что React "ожидает" при клиентской гидратации.
47. Как избежать hydration mismatch в приложениях React с SSR?
	1. Соблюдать одинаковую логику рендера на сервере и клиенте.
		1. не использовать случайные значения (Math.random(), Date.now()),
		2. window, document и любые browser-only API.
		3. Использовать useEffect, а не useLayoutEffect для client-only логики
48. Почему важно, чтобы SSR и клиентский рендер в React генерировали одинаковый DOM?
	1. React при гидратации подключается к существующему серверному HTML и ожидает, что структура совпадёт. Если DOM не совпадает — происходит hydration mismatch, React показывает предупреждения и может перерисовать большие участки UI
49. Что происходит на клиенте при hydration mismatch в React?
	1. React покажет warning, а иногда — перерисует весь DOM узел
50. Как useLayoutEffect может повлиять на гидратацию (hydration) после SSR в React?
	1. useLayoutEffect выполняется до отрисовки, только на клиенте — и может синхронно изменить DOM, не совпадающий с HTML от сервера, что приводит к hydration mismatch
51. Как SSR в React помогает уменьшить Time to First Byte (TTFB)?
	1. SSR позволяет серверу сразу отправить полностью сформированный HTML, благодаря чему браузер начинает отображать контент сразу после получения первого байта без задержек на загрузку и выполнение JS
52. Как в React/Next.js избежать отправки лишнего JavaScript на клиент?
	1. Использовать Server Components, которые рендерятся только на сервере и не попадают в клиентский бандл.
	2. Применять use client директиву строго там, где нужна интерактивность.
	3. Делать код-сплиттинг и динамический импорт для загрузки JS только при необходимости.
	4. Минимизировать зависимости и не импортировать клиентские библиотеки в серверные компоненты.
	5. Использовать selective hydration, чтобы загружать JS по частям и с приоритетом.
53. Как работают Suspense и ленивая загрузка серверных данных и компонентов в React/Next.js?
	1. Серверные компоненты могут использовать асинхронные функции (например, await fetch()) прямо внутри тела компонента. React ждёт их завершения или отдаёт fallback, обеспечивая эффективный ленивый рендеринг и загрузку.
	2. После загрузки данных React «дозаписывает» оставшийся HTML по стриму (Streaming SSR), обеспечивая эффективный ленивый рендеринг и быструю первую отрисовку.
	3. На клиенте Suspense переключается между fallback и готовым UI по мере завершения загрузки, поддерживая плавный переход.
54. Какие хуки доступны в React Server Components?
	1. useId - Генерация стабильных ID

#### 6. Performance Optimization

55. Как React избегает лишних ререндеров?
	1. Virtual DOM и сравнение (reconciliation)
	2. Мемоизация с React.memo
	3. Хуки useMemo и useCallback
	4. Контроль ключей (key) в списках
56. Как работает batching обновлений состояния в React?
	1. это механизм объединения нескольких обновлений состояния (state updates) в один цикл рендера
	2. внутри обработчика вызывается несколько setState или обновлений, React объединяет (batch) их и выполняет один рендер после завершения обработчика
57. Как Fiber улучшает отзывчивость UI (например, при анимациях)?
	1. Приоритизация обновлений
	2. Прерываемость рендера
	3. благодаря time slicing и прерывистому рендеру, браузер может своевременно обновлять кадры анимаций и избегать "фризов".

#### 7. Advanced Patterns and Features

58. Как архитектура React Fiber учитывает асинхронные операции при обновлении UI?
	1. Fiber сам по себе не выполняет асинхронные операции, но он управляет их результатами и обновлением UI с учётом приоритетов
59. Как работает Suspense для данных в React?
	1. Suspense для данных приостанавливает рендер компонента, если данные ещё не готовы, бросая Promise. React показывает fallback UI, пока Promise не разрешится, после чего рендер возобновляется с готовыми данными.
60. Что такое API use() в React и для чего оно нужно?
	1. use() — это React API для чтения значения ресурса, такого как Promise или контекст
61. Для чего нужен use() в React и какие ресурсы он читает?
	1. Чтобы "подписаться" на Promise или контекст и получить их значение, интегрируясь с Suspense и Error Boundaries.
62. Как работает use() с Promise и контекстом в React?
	1. Если передан Promise, React "приостанавливает" рендер компонента до его разрешения (Suspense fallback показывается).
	2. Если Promise отклонён — срабатывает ближайший Error Boundary.
	3. Если передан контекст — use() возвращает его значение, как useContext, но может использоваться в условных и циклах.
63. Где доступен use() в React (SSR или CSR) и когда его применять?
	1. Работает и на сервере, и на клиенте, но преимущественно используется для чтения ресурсов в Client Components
64. Как новый хук use() взаимодействует с Fiber?
	1. use() интегрируется с механизмом Suspense в Fiber: при ожидании Promise Fiber приостанавливает рендер и переключается на fallback, а после разрешения возобновляет рендер с полученными данными.
65. Как использовать use() для чтения контекста вместо useContext?
	1. Использование use с контекстом способ читать значение контекста, аналогичный useContext, но с преимуществом возможности вызывать use внутри условных блоков и циклов.
66. Почему нельзя просто await в Client Components вместо use()?
	1. await нельзя использовать напрямую в теле функционального компонента — он синхронный и блокирует. use() позволяет React управлять состоянием ожидания асинхронного результата в рамках Fiber и Suspense.

#### 8. Debugging and Internals

67. В чём разница между useLayoutEffect и useEffect с точки зрения Fiber?
	 1. useLayoutEffect — синхронный, блокирующий эффект, полезен для измерений DOM и синхронных манипуляций. выполняется в phase commit, после того, как React применил изменения к DOM, но до того, как браузер обновил экран
    1. useEffect — асинхронный, неблокирующий, выполняется после отрисовки, оптимален для сетевых запросов, подписок и не критичных к времени операций. выполняется после фазы commit и после того, как браузер отрисовал обновлённый UI
68. Как React делит работу на чанки и приостанавливает рендеринг для более важных задач?
	1. React Fiber разбивает работу рендеринга на небольшие части (чанки). При этом рендеринг приостанавливается (interruptible rendering), если появляется задача с более высоким приоритетом (например, пользовательский ввод)
69. Как React обрабатывает "зависшие" компоненты (например, при загрузке данных)?
	1. При загрузке данных, если компонент возвращает Promise, React приостанавливает его рендеринг, показывая запасной UI (fallback) через Suspense. Когда данные загружены, React продолжает рендеринг компонента с этими данными
70. Что такое Selective Hydration в React на клиенте?
	1. Selective Hydration — это техника, при которой React при гидратации на клиенте сначала  гидратирует только самые важные или видимые части UI, а остальные части гидратируются позже, по мере необходимости.
71. В чём разница между срочными (urgent) и отложенными (non-urgent) обновлениями в React, и как это связано с приоритетами Scheduler?
	1. Срочные (urgent) обновления — это события с высоким приоритетом, как ввод пользователя или клики, которые React должен обработать немедленно.
	2. Отложенные (non-urgent) обновления — менее важные задачи, например, обновление неактивных компонентов, которые можно выполнить позже.  
	3. Scheduler React управляет этими приоритетами, позволяя прерывать низкоприоритетные задачи для срочных, поддерживая отзывчивость UI.
72. Что такое interruptible rendering в React и зачем он нужен?
	1. Interruptible rendering — возможность React прерывать текущий процесс рендеринга в любой момент, чтобы переключиться на более приоритетную работу, а затем продолжать с места остановки
73. Почему React Server Components не имеют состояния и хуков?
	1. Server Components рендерятся на сервере и не имеют жизненного цикла или интерактивности, поэтому состояние и хуки им не нужны
74. Как React Server Components уменьшают размер клиентского бандла?
	1. Server Components не включаются в клиентский бандл JavaScript — они полностью рендерятся на сервере и передают клиенту уже готовый HTML
75. Как работают React.lazy и Suspense для динамического импорта компонентов?
	1. React.lazy динамически импортирует компонент (через import()), возвращая промис.
	2. Пока компонент загружается — Suspense показывает fallback UI.
	3. После загрузки компонент рендерится как обычно.
76. Какие варианты fallback UI поддерживает React Suspense и как работает вложенность?
	1. Fallback — любой React-элемент, показываемый во время загрузки.
	2. Вложенные Suspense показывают самый близкий fallback для загрузки в своей области.
77. Какие основные этапы монтирования, обновления и размонтирования компонентов в функциональном React?
	1. Монтирование: рендер + запуск эффектов с пустым массивом зависимостей (useEffect(() => {}, [])).
	2. Обновление: повторный рендер + эффекты с изменившимися зависимостями.
	3. Размонтирование: вызов очисток эффектов (функций, возвращаемых из useEffect)
78. Как компоненты ведут себя в разных режимах рендера (синхронном и конкурентном)?
	1. Sync: рендер блокирует UI до конца.
	2. Concurrent: рендер можно приостанавливать, приоритеты обновлений.

#### 9. Component Patterns and State Management

79. Как реализуется однонаправленный поток данных в React?
	1. Однонаправленный поток данных в React означает, что данные всегда идут сверху вниз — от родительских компонентов к дочерним через props
	2. Родитель хранит состояние и передаёт его дочерним, которые могут только читать эти props, но не менять их напрямую. Изменения состояния происходят в родителе через коллбэки, переданные вниз
80. Что такое "lifting state up" и как его правильно использовать?
	1. это когда состояние, нужное нескольким компонентам, поднимается к их ближайшему общему родителю. Вместо того чтобы каждый компонент держал своё локальное состояние и пытался синхронизировать его, состояние централизуется в одном компоненте-родителе, а дочерним передаются через props и коллбэки для изменения.
81. В чём разница между контролируемыми и неконтролируемыми компонентами? Как это влияет на работу с формами?
	1. Контролируемые компоненты — это компоненты, где состояние формы полностью управляется React через state и обновляется через обработчики (onChange). Значение поля всегда берётся из состояния, а не из DOM.
	2. Неконтролируемые компоненты — это компоненты, где состояние формы хранится непосредственно в DOM, а React лишь получает доступ через  ref. React не управляет значением, а читает его при необходимости.
	3. Контролируемые компоненты позволяют сразу валидировать, управлять вводом, делать условный рендер элементов формы.

#### 10. React Features and APIs

82. Как и зачем применять React.Fragment?
	1. Позволяет сгруппировать несколько элементов без добавления лишнего DOM-узла.
83. Когда и как правильно использовать порталы в React?
	1. Используйте порталы, когда UI-элемент должен визуально выходить за пределы текущей иерархии DOM — например, модальные окна, тултипы, всплывающие меню, уведомления
84. Как работает ReactDOM.createPortal и как он участвует в Fiber-дереве?
	1. ReactDOM.createPortal рендерит элемент в другой DOM-узел, но оставляет его частью того же Fiber-дерева. Компонент внутри портала получает контексты, участвует в рендеринге, Suspense, ErrorBoundary и сохраняет порядок событий.
85. Как ведёт себя React при вложенных Suspense и цепочках fallback (suspense cascade)?
	1. При вложенных Suspense, React строит цепочку fallback’ов: если inner Suspense переходит в состояние ожидания (suspend), React показывает его fallback.
	2. Если fallback-контент тоже вызывает suspend (например, ленивый компонент или async server компонент), React поднимается к ближайшему родительскому Suspense выше по компонентному дереву (не по DOM) и рендерит уже его fallback. Этот процесс продолжается вверх, пока не найдётся fallback, который можно отрендерить синхронно.
	3. Это называется suspense cascade — поведение предсказуемо, и важно, что цепочка строится по дереву компонентов, а не по DOM
86. Какие особенности управления событиями и фокусом возникают при работе с порталами?
	1. События всплывают по React-дереву, а не по DOM — обработчики работают как обычно, несмотря на другой DOM-узел
	2. Фокусом нужно управлять вручную: при открытии модалки ставить фокус в портал, при закрытии — возвращать на исходный элемент.
87. Какие аргументы принимает ReactDOM.createPortal?
	1. children — React-элементы, которые нужно отрендерить (JSX, компоненты, строки, фрагменты и т.п.).
	2. domNode — DOM-узел, куда будет помещён этот контент. Этот узел должен уже существовать в DOM.
	3. key (опционально) — уникальный ключ (строка или число) для идентификации портала, особенно при рендере списков порталов.
88. Какие стандартные атрибуты и API React помогают создавать доступный UI?
	1. aria-* (aria-label, aria-labelledby, aria-describedby, aria-hidden) для описания элементов для скринридеров.
	2. tabIndex - для настройки порядка табуляции и возможности фокусировки.
89. Как правильно реализовать контролируемые и неконтролируемые компоненты форм?
	1. Контролируемые компоненты: значение хранится в состоянии (useState), обновляется через onChange. React полностью управляет вводом.
	2. Неконтролируемые компоненты: значение хранится в DOM, доступ через ref. React не управляет вводом напрямую.
90. Как в React обрабатывать события onChange и onSubmit в формах?
	1. onChange: обновляет состояние для контролируемых компонентов.
	2. onSubmit: отменяет стандартное поведение и обрабатывает данные из состояния или ref.
91. Как сделать простую валидацию без сторонних библиотек?
	1. выполняется прямо в обработчике onSubmit или onChange — проверяем значения на нужные условия с сохранением ошибок в состоянии
	2. HTML-атрибуты валидации required, minLength, pattern
92. Как реализовать анимации с помощью CSS в React-приложении?
	1. Создаёшь CSS-классы с transition (для плавных переходов свойств) или @keyframes (для сложных анимаций).
93. Как работает система SyntheticEvent в React?
	1. SyntheticEvent — это обёртка над нативными событиями браузера, которую React создаёт для обеспечения кроссбраузерного и одинакового API при работе с событиями.
94. В чём основные отличия между Synthetic Events и нативными событиями браузера?
	1. Кроссбраузерность  
	    1. SyntheticEvent предоставляет единый интерфейс, который одинаково работает во всех браузерах. Нативные события могут иметь отличия в свойствах и поведении между браузерами.
	2. Поведение всплытия  
	    События в React всплывают по React-иерархии компонентов, даже если DOM-структура другая (например, при использовании createPortal). Нативные события всплывают по DOM-дереву.
	3. Совместимость с React API  
	    1. Только SyntheticEvent работает корректно с системой приоритетов событий в concurrent режиме. Нативные события об этом "не знают".
	4. API одинаково везде  
	    1. У SyntheticEvent всегда есть стандартные свойства (type, target, currentTarget, preventDefault(), stopPropagation() и т.п.), даже если браузер этого не поддерживает напрямую.
95. Как ведёт себя React Strict Mode в режиме разработки и зачем он нужен?
	1. В Strict Mode компоненты и хуки специально монтируются, размонтируются и монтируются заново в режиме разработки. Это имитация двойного вызова жизненных циклов для выявления побочных эффектов
96. Почему компоненты и хуки вызываются повторно в Strict Mode?
	1. React повторно вызывает функции компонентов и эффекты, чтобы проверить, правильно ли они чистят ресурсы и не вызывают неожиданных сайд-эффектов при монтировании/размонтировании
97. Как  Strict Mode  помогает улучшить качество кода и отловить ошибки?
	1. Такая проверка помогает заранее выявлять баги, неправильное управление эффектами и состояние, делая код более устойчивым и предсказуемым перед продакшен-сборкой
98. Как включить React Strict Mode в приложении?
	1. обернуть компонент в <React.StrictMode>.
99. Как получить доступ к React Context без хуков?
	через компонент <MyContext.Consumer>. В него передают функцию, которая получает текущее значение контекста.
100. Какие проблемы с производительностью возникают при частых обновлениях контекста?
	1. При изменении значения в провайдере все дочерние компоненты использующие контекст перерендериваются, даже если используют лишь часть данных или не затронуты логикой/
101. Как JSX трансформируется в вызовы React.createElement?
	1. JSX — это синтаксический сахар, который во время сборки транспилируется в вызовы React.createElement
102. Что такое ReactElement и чем он отличается от компонента?
	1. ReactElement — это обычный объект, который описывает элемент React: тип (тег или компонент), пропсы и детей. Это «план» для реального DOM. Он не является компонентом и не содержит логики — это результат вызова компонента или JSX.

#### 11. React 18+ Features

103. Как Automatic Batching в React 18 работает с промисами и таймерами?
	1. В React 18 Automatic Batching работает со всеми асинхронными операциями. Когда несколько setState вызываются внутри промиса или setTimeout, React автоматически объединяет их в один рендер, что значительно улучшает производительность.
104. В чем разница между React 17 и React 18 batching?
	1. React 17: batching работал только в обработчиках событий React (onClick, onChange и т.д.)
	2. React 18: batching работает везде, включая промисы, таймеры, сетевые запросы и любые другие асинхронные операции
105. Как flushSync обходит Automatic Batching?
	1. flushSync принудительно выполняет обновление синхронно, игнорируя Automatic Batching. Это полезно когда нужно немедленно применить изменения, например, для измерений DOM или интеграции с внешними библиотеками.
106. Что такое React Compiler и какую роль он играет в оптимизации React-кода?
	1. React Compiler — это  инструмент, который автоматически оптимизирует React код во время компиляции. Он анализирует код и применяет оптимизации, которые раньше требовали ручного написания useMemo, useCallback и других оптимизаций.
107. Как React Compiler оптимизирует код?
	1. React Compiler автоматически мемоизирует компоненты и функции, удаляет ненужные ререндеры, оптимизирует пропсы и состояния. Он делает это на уровне компиляции, что более эффективно чем ручные оптимизации.

## Hooks

108. Какие правила использования хуков React нужно соблюдать?
	1. Вызывайте их на верхнем уровне в теле компонента функции
	2. Вызывайте их на верхнем уровне в теле пользовательского хука
	3. Не вызывайте хуки внутри условий или циклов.
	4. Не называйте хуки после условного return оператора.
	5. Не вызывайте хуки в обработчиках событий.
	6. Не вызывайте хуки в компонентах класса.
	7. Не вызывайте хуки внутри функций, переданных в useMemo, useReducer, или useEffect

useState

109. Для чего нужен useState?
	1. Чтобы создать локальное состояние в функциональном компоненте.
110. Что возвращает useState?
	1. Массив из двух элементов: текущее значение и функция для его обновления
111. Как изменить состояние useState?
	1. Вызов setState(newValue) или setState(prev => computeNext(prev))
112. Как обновлять состояние на основе предыдущего значения?
	1. setState(prev => computeNext(prev))
113. Почему setState асинхронен, и как это влияет на обновления?
	1. batching группирует обновления, чтобы не делать лишнюю работу. Поэтому state не обновляется сразу после вызова setState.
114. Что произойдет, если вызвать setState с тем же значением?
	1. React использует Object.is для сравнения. Если значение не изменилось — ререндер не произойдёт.
115. Как работает shallow compare в useState?
	1. Shallow сравнение — Object.is(prev, next). Для объектов и массивов — сравниваются только ссылки.
116. Как работает useState при повторных рендерах?
	1. React сохраняет значение в ячейке хука. Инициализация выполняется один раз — при первом рендере.
117. Как правильно обновлять состояние, если оно — объект или массив?
	1. Иммутабельно: setState(prev => ({ ...prev, updated: true }))
118. Почему нельзя вызывать useState условно?
	1. Потому что порядок вызовов хуков должен быть стабильным между рендерами
119. В чем отличие useState от useReducer?
	1. useState — для простого состояния. useReducer — для сложной логики и вложенных структур. useReducer даёт больше контроля и лучше масштабируетс
120. Как ведет себя useState при размонтировании компонента?
	1. Хук отрабатывает только при монтировании. После анмаунта setState ничего не делает.
121. Как сделать ленивую инициализацию состояния в useState?
	1. useState(() => computeExpensiveInitial())
122. В чем разница между useState(someFunction()), useState(someFunction), useState(() => someFunction())?
	1. someFn() — вызов сразу, значение — результат.
	2. someFn — функция как значение, не вызовется.
	3. () => someFn() — ленивый вызов, только при первом рендере.
123. Можно ли мемоизировать setState с помощью useCallback?
	1. Можно, но не нужно.setState стабилен, ссылка не меняется.
124. Что произойдёт, если передать пропсы как начальное значение в useState, а затем эти пропсы изменятся?
	1. Ничего не произойдёт. Начальное значение читается только при монтировании. Для синхронизации с пропсами нужен useEffect.
125. Как синхронизировать значение useState с передаваемыми компоненту пропсами?
	1. Чтобы синхронизировать state с пропсами, нужно использовать useEffect с подпиской на нужные пропсы.
126. Что будет если useState при значении объекта через setState присвоить этот же объект?
	1. setObj((obj) => obj) - ничего не будет так как ссылка такая же.
	2. setObj((obj) => {...obj}) - произойдет перерендер так как ссылку уже будет другой.
127. Как избежать stale-значений при обновлении состояния в async-колбэках или таймерах?
	1. Использовать функциональный setState(prev => ...)
128. Почему setState внутри useEffect может зациклить рендер?
	1. Если setState вызывается без условий, и обновляемое состояние входит в deps, произойдёт бесконечный цикл
129. Как работает batching в React 18 и какие кейсы нарушают его (например, setTimeout, промисы)?
	1. React batch'ит  несколько вызовов setState в один ререндер
	2. после 18 версии  всё, что запущено внутри одного "tick" (микро/макрозадачи), будет батчиться.
	3. flushSync принудительно ререндерит компонент игнорируя batch(инг)


---

useEffect и useLayoutEffect

130. Для чего нужен useEffect?
	1. useEffect позволяет выполнять побочные эффекты
131. Когда вызывается useEffect?
	1. После рендера, асинхронно, уже после того как браузер нарисовал DOM.
132. Какие параметры принимает useEffect и что они означают?
	1. callback: () => void — основная функция с эффектом;
	2. deps: any[] — массив зависимостей (опционально)
133. Что возвращает useEffect?
	1. Ничего сам по себе (undefined). Но колбэк может вернуть функцию очистки — она вызовется при размонтировании или перед следующим выполнением эффекта.
134. Как работает массив зависимостей?
	1. React сравнивает зависимости (по Object.is). Эффект выполняется только если хотя бы одна зависимость изменилась. Если массив пустой — выполнится один раз при монтировании.
135. Что будет, если не указать зависимости?
	1. Эффект будет выполняться после каждого рендера
136. Как выполнить эффект только при монтировании компонента?
	1. Передать пустой массив зависимостей:
137. Как использовать useEffect с асинхронными функциями?
	1. Нельзя сделать сам useEffect async, но можно в callback создать асинхронную функцию и вызвать ее
138. Что такое функция очистки (cleanup)?
	1. Это функция, которую может возвращать callback. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента.
	2. Используется для отмены подписок, таймеров, abort-controllers и т.п.
139. Когда вызывается функция очистки?
	1. Она вызывается перед повторным выполнением эффекта либо при размонтировании компонента.
140. Как отменять асинхронные операции в useEffect?
	1. AbortController для запросов
	2. флаг переменную 
141. Чем useEffect отличается от useLayoutEffect?
	1. useEffect: вызывается асинхронно, после рендера и отрисовки.
	2. useLayoutEffect: вызывается синхронно, до отрисовки браузером и может блокировать отрисовку.
142. Что такое "useEffect первого рендера" и "useEffect обновления"? Как их различать?
	1. useEffect первого рендера: выполняются один раз при монтировании (useEffect(() => {...}, [])).
	2. useEffect обновления: выполняются при изменении зависимостей (useEffect(() => {...}, [a, b])).
143. Как избежать гонки состояний (race conditions) в асинхронных эффектах?
	1. Используй AbortController, флаги isMounted
144. Почему нельзя делать await напрямую в useEffect(callback)?
	1. Потому что useEffect должен возвращать либо undefined, либо функцию очистки.  async функция всегда возвращает Promise, что нарушает контракт
145. Как правильно использовать эффекты с подписками на внешние источники (WebSocket, Observer, EventListener)?
	1. Создай подписку в useEffect
	2. Вернуть функцию очистки, чтобы отписаться при размонтировании или повторном вызове.
146. Что произойдёт, если не использовать функцию очистки при подписке?
	1. Повторные подписки → дублирование событий
	2. неактуальные колбэки
	3. Утечка ресурсов
147. Чем отличается порядок выполнения нескольких useEffect в одном компоненте?
	1. Они выполняются сверху вниз, в порядке объявления. Это важно, если между ними есть зависимость:
148. Как влияет Strict Mode на вызовы useEffect? Как это влияет на эффекты с побочками?
	1. useEffect вызывается дважды (монтирование → размонтирование → повторное монтирование)
	2. Цель — поймать ошибки в нечистых эффектов, например, без cleanup 


useRef

149. Для чего нужен useRef?
	1. Также — для доступа к DOM-элементам.
	2. Чтобы хранить значения, которые не вызывают ререндер при изменении. 
150. Какие варианты использования useRef в React?
	1. Доступ к DOM
	2. Хранение значения между рендерами
	3. Предыдущее значение
	4. Флаг "монтирован"
	5. Таймеры, id, внешние инстансы
151. Как получить доступ к DOM-элементу с помощью useRef?
	1. Прокинуть в атрибут ref html тега переменную которой присвоили useRef()
152. Что хранится в .current?
	1. В поле .current хранится текущее значение, которое  туда положили. По умолчанию — значение, переданное в useRef(initialValue)
153. Можно ли изменять .current?
	1. Да, через ref.current = newValue
154. Вызывает ли изменение .current перерендер?
	1. useRef не триггерит повторный рендер, в отличие от useState.
155. Как использовать useRef для хранения значений между рендерами?
	1. Любое значение, присвоенное ref.current, мутабельно, доступно для использования и сохраняется между перерендерами.
156. Чем useRef отличается от useState?
	1. useRef не вызывает ререндер при изменении.
	2. useState — триггерит ререндер.
157. Как использовать useRef для хранения предыдущего значения?
	1. Любое значение, присвоенное ref.current, мутабельно, доступно для использования и сохраняется между перерендерами.
158. Как useRef помогает избежать лишнего рендера в onScroll, onResize и других частых ивентах?
	1. При onScroll, onResize и подобных событиях состояние часто обновляется, но повторный рендер при каждом изменении — дорог. useRef позволяет сохранять значения между рендерами, не вызывая лишних повторных рендеров.
159. Можно ли использовать useRef как глобальный стейт? Почему это плохая идея?
	1. Можно, но не нужно. так как 
		1. useRef — локален компоненту
		2. не вызывает ререндер
		3. не реактивен — другие компоненты не узнают об изменении
160. Как связать useRef и forwardRef для передачи доступа к DOM наружу?
	1. forwardRef нужен, чтобы пробросить ref от родителя к DOM-элементу внутри компонента.
---

useMemo
161. Что такое хук useMemo в React и для чего он используется?
	1. useMemo — это хук, который мемоизирует результат вычисления между рендерами, чтобы не пересчитывать заново, если зависимости не изменились
162. Какие аргументы принимает useMemo и что они означают?
	1. Функция, которая возвращает значение
	2. Массив зависимостей (deps)
163. Что возвращает useMemo при успешной мемоизации?
	1. Результат выполнения переданной функции — мемоизированное значение.
164. Когда имеет смысл применять useMemo в React-компонентах?
	1. Дорогие вычисления
	2. Передача стабильной ссылки в зависимости
	3. Оптимизация рендеров дочерних компонентов
165. В каких случаях useMemo не приносит пользы и может навредить?
	1. Преждевременная мемоизация нагружает память и CPU.
	2. Если вычисление дешёвое
	3. Если часто меняются зависимости и значение всегда пересчитывается
	4. Если нет проблем с производительностью
166. Как устроена мемоизация в useMemo под капотом?
	1. React запоминает результат выполнения функции
	2. При следующем рендере сравнивает зависимости
	3. Если зависимости не изменились (Object.is) — возвращает кэш, иначе — пересчитывает
167. Что произойдёт в useMemo, если не указать массив зависимостей?
	1. Функция будет перевычисляться при каждом рендере
168. В каких случаях useMemo может ухудшить производительность приложения?
	1. Если мемоизируется дешёвая логика
	2. Если зависимости часто меняются
	3. Если много useMemo — меньше GC, больше памяти
169. Как useMemo сравнивает зависимости: по ссылке или по значению?
	1. По ссылке, через Object.is():
170. Как useMemo ведёт себя в конкурентном рендеринге (Concurrent Mode)?
	1. В Concurrent Mode useMemo ведёт себя также, как и другие React-хуки: результат мемоизации сохраняется только после коммита. Если рендер был прерван, результат useMemo не сохраняется, и при следующем рендере функция будет вызвана снова
171. Чем useMemo отличается от мемоизации вне React (например, lodash.memoize)?
	1. useMemo — это hook, встроенный в React-цикл рендеринга и зависящий от зависимостей и жизненного цикла компонента. Он автоматически сбрасывается при размонтировании компонента.  
	2. В отличие от него, lodash.memoize — это императивная мемоизация, работающая вне контекста React и требующая ручного контроля над кэшем. Она сохраняет результат в глобальном или внешнем кэше и не зависит от ререндеров.
172. Как useMemo влияет на использование памяти и работу сборщика мусора?
	1. Каждый useMemo сохраняет результат в кэше до тех пор, пока компонент не размонтируется или зависимости не изменятся. Если useMemo используется без нужды (например, для дешёвых вычислений), это может увеличить потребление памяти, замедлить сборку мусора и создать лишнюю нагрузку на CPU из-за отслеживания зависимостей
173. Как useMemo взаимодействует с режимом Suspense в React?
	1. В режиме Suspense, если рендер компонента прерывается из-за "зависания" на промисе (например, в data fetching), useMemo работает аналогично Concurrent Mode: результат не кэшируется, пока не произойдёт успешный коммит. Это значит, что функция в useMemo может вызываться повторно при каждом новом рендере, до тех пор, пока Suspense не завершит ожидание.
174. Какие ошибки возникают при неправильном указании зависимостей в useMemo?
	1. Если зависимости useMemo указаны неправильно (например, не указаны значения, от которых зависит вычисление), могут возникнуть баги со stale values: мемоизированное значение будет пересчитываться реже, чем нужно, и может стать неактуальным. Это приводит к неконсистентному UI, неверным данным или логике.

---

useCallback

175. Что такое хук useCallback в React и для чего он используется?
	1. useCallback — это хук, который мемоизирует функцию, чтобы она сохраняла стабильную ссылку между рендерами, если не изменились зависимости.
176. Какие аргументы принимает useCallback и что они означают?
	1. Колбэк-функция (возвращается как есть, не вызывается)
	2. Массив зависимостей
177. Что возвращает useCallback и когда ссылка на функцию остаётся стабильной?
	1. Мемоизированную функцию
178. Когда имеет смысл применять useCallback в React-компонентах?
	1. Когда нужно передать функцию в memoized-компонент
	2. В useEffect / useMemo / setInterval — когда функция зависит от стабильности ссылки
	3. Для оптимизации компонентов, избегающих лишнего рендера по ссылке на колбэк
179. В каких случаях useCallback бесполезен и не даёт выигрыша?
	1. Если компонент не зависит от стабильности функции
	2. Если функция пересоздаётся каждый раз из-за нестабильных зависимостей
	3. Если перерисовки и так дешёвые
180. Что произойдёт, если колбэк в useCallback зависит от внешних значений, но их нет в зависимостях?
	1. баг: внутри функции будут устаревшие значения (stale closure).
181. Чем отличается useCallback от useMemo?
	1. useCallback
		1. Мемоизирует функцию
		2. Возвращает саму функцию
	2. useMemo
		1. Мемоизирует значение
		2. Возвращает результат вызова
182. Когда стоит предпочесть useCallback вместо обычного объявления функции в компоненте?
	1. Когда функция передаётся вниз (в props) и нужно избежать лишнего рендера дочернего React.memo компонента
	2. Когда функция участвует в зависимостях эффекта, и  нужна стабильная ссылка
183. Можно ли заменить useCallback с помощью useMemo? Почему это не рекомендуется?
	1. Да. но не рекомендуется из-за неочевидности:
184. Как избежать stale-замыканий (устаревших значений) при использовании useCallback?
	1. Чтобы избежать stale closure, необходимо указывать в массиве зависимостей все значения, на которые ссылается колбэк: пропсы, стейт и любые переменные из внешней области. Это гарантирует, что функция будет пересоздана при изменении нужных данных и всегда работать с актуальными значениями.
185. Как useCallback ведёт себя в конкурентном рендеринге (Concurrent Mode)?
	1. useCallback — не сохраняется между прерванными рендерами, пока не завершится коммит.
	2. Но после успешного коммита, возвращаемая функция будет стабильна, если зависимости не поменялись.
186. Почему нельзя мемоизировать колбэк с пустым массивом зависимостей, если внутри используются пропсы/состояние?
	1. Пустой массив зависимостей фиксирует колбэк навсегда после первого рендера. Если в теле функции используются внешние значения, они будут захвачены однажды и больше не обновятся. Это приведёт к использованию устаревших данных и нарушит ожидаемое поведение компонента.
187. Можно ли комбинировать useCallback с useMemo и когда это оправдано?
	1. Комбинация возможна и уместна, когда требуется создать мемоизированную структуру, содержащую функции, и сохранить стабильность всей структуры между рендерами.
188. Чем useCallback отличается от простого объявления функции внутри компонента?
	1. Функция, объявленная внутри компонента без useCallback, пересоздаётся при каждом рендере и всегда имеет новую ссылку. useCallback позволяет сохранить ссылку на функцию между рендерами при условии, что зависимости не изменились


---

useId

189. Для чего используется хук useId в React и какие задачи он решает?
	1. нужен для генерации уникального, стабильного ID, который синхронизируется между сервером и клиентом. 
	2. полезен для привязки label ↔ input, aria-describedby, и в компонентах, рендерящихся и на сервере, и на клиенте.
190. Как работает useId и почему его ID стабильны между рендерами?
	1. React генерирует уникальный, стабильный префикс независимо от количества ререндеров
191. Можно ли использовать useId в серверных компонентах React (RSC)?
	1. Да. useId безопасен для Server Components и работает и на сервере, и на клиенте. Это одна из его задач — избежать mismatch при гидратации
192. Как useId помогает при серверном рендеринге (SSR) избежать mismatch?
	1. useId гарантирует одинаковый ID на обеих сторонах (в отличие от Math.random(), uuid), потому что React сам контролирует генерацию и встраивает метаданные в HTML.
193. Чем useId отличается от генерации ID через Math.random() и сторонние библиотеки?
	1. Стабильный между рендерами
	2. Работает при SSR-гидратации
	3. безопасен для accessibility
194. Можно ли использовать useId для генерации ключей (key) в списках React?
	1. Нет. Ключи в списках должны быть детерминированы по данным, иначе при изменении порядка или количества элементов React будет пере-монтировать всё.
195. Что будет, если использовать useId в компоненте, который часто ререндерится?
	1. useId стабилен — он выдаёт одно и то же значение между рендерами, пока компонент не размонтируется.
196. Какие проблемы useId решает в контексте доступности (a11y)?
	1. Для доступности важно, чтобы label имел htmlFor={id}, а input — id={sameId}. Если ID разные на сервере и клиенте — атрибут for указывает не туда → screen reader не сможет связать label и поле. useId даёт одинаковый ID и решает эту проблему.
197. Как useId ведёт себя при гидратации после SSR?
	1. React знает, как синхронизировать ID, сгенерированные на сервере и клиенте, чтобы избежать ошибок.  Это происходит через встроенные маркеры в HTML, которые позволяют React восстановить правильный state без mismatch.
198. Как useId генерирует стабильные ID в конкурентном режиме (Concurrent Mode)?
	1. useId() генерирует стабильный уникальный ID, который:
	2. Не зависит от порядка рендера и не сбивается даже при конкурентных прерываниях (concurrent rendering), т.к. не использует счётчики, как useRef или инкремент.
199. Есть ли ограничения по количеству вызовов useId в одном компоненте?
	1. Нет, жёстких ограничений нет — можно вызывать useId сколько угодно раз, и каждый вызов useId() вернёт уникальный ID, даже в одном компоненте.
200. Как useId ведёт себя при гидратации SSR в сочетании с React Suspense?
	1. - React гарантирует, что useId() возвращает одинаковое значение на сервере и клиенте. Это особенно важно при использовании Suspense, где часть дерева может быть отложена, что меняет порядок вызова хуков.
	2. ID детерминированный, стабилен даже при Suspense, startTransition, и других асинхронных рендерах.

---


useContext

201. Для чего нужен хук useContext в React и что он возвращает?
	1. Чтобы получать значение из контекста
202. Как создать и экспортировать контекст в React?
	1. export const ThemeContext = React.createContext(null);
203. Как использовать useContext для получения значения из контекста?
	1. const theme = useContext(ThemeContext);
204. Можно ли использовать useContext вне компонента? Почему?
	1. Нельзя. useContext — это хук, он должен вызываться внутри функционального компонента или другого хука
205. Как useContext работает при обновлении значения в провайдере?
	1. Если значение контекст меняется, все потомки, использующие useContext, перерисуются.  
	2. React сравнивает по Object.is.
206. Как избежать лишних рендеров при использовании useContext?
	1. Мемоизировать value
	2. Разделить контексты: один для данных, другой для диспатча (Pattern: StateContext + DispatchContext)
	3. Вынести useContext ближе к месту, где нужен
207. Можно ли использовать несколько контекстов одновременно? Как это делать?
	1. Да. Просто вложив провайдеры друг в друга
208. Когда использовать useContext, а когда — глобальные стейты типа Redux или Zustand?
	1. Используй useContext для UI-состояния и небольших кусков, Redux/Zustand — если данные масштабируются и делятся между многими частями приложения.
209. Как работает useContext с серверным рендерингом (SSR)?
	1. Неизвестно (нужна доработка раздела).
210. Какие ограничения и подводные камни есть у useContext?
	1. Все потребители перерисуются при любом изменении value
	2. Плохая производительность при больших объектах в value
	3. Нельзя вызывать вне компонента
	4. Мутирование объекта в value не вызовет ререндер
211. Как работает обновление контекста при вложенных провайдерах с одинаковым типом?
	1. Если компонент обернут во вложенные <Context.Provider> одного и того же контекста, то useContext(Context) всегда читает ближайший вверх по дереву Provider
212. Как useContext влияет на производительность в больших приложениях?
	1. при любом изменении value в Provider, все компоненты, читающие этот контекст (через useContext), перерисовываются, даже если они используют только часть value.
	2. Это связано с тем, что React делает сравнение по Object.is(value) на уровне Provider.
213. Как обрабатывать ошибки при чтении контекста вне провайдера?
	1. Создай обёртку-хук:
	2. function useStrictContext() {
		  const context = useContext(MyContext);
		  if (!context) {
	    throw new Error('useMyContext должен вызываться внутри <MyContext.Provider>');
		  }
		  return context;
		}
214. Какие альтернативы useContext для глобального состояния и когда их лучше применять?
	1. Zustand, Redux + RTK, Recoil
	2. useContext хорошо работает для:
		1. UI-состояния
	    1. локальных настроек
		1. небольшого шаринга между родителем и потомками

---

useReducer

215. Что такое useReducer и для чего он нужен?
	1. Это хук для управления сложным или предсказуемым состоянием
216. Какие параметры принимает useReducer и что они означают?
	1. reducer: Редюсер — чистая функция, которая определяет логику обновления состояния. Редюсер принимает два аргумента – состояние и действие, и возвращает следующее состояние. Состояние и действие могут быть любых типов.
	2. initialArg: Значение на основе которого вычисляется начальное состояние. Значение начального состояния может быть любого типа. То как из него будет вычисляться начальное состояние, зависит от аргумента init.
	3. init(опционально): функция-инициализатор, возвращающая начальное состояние. Если не указана — состояние устанавливается в initialArg. Если указана — используется результат init(initialArg).
217. Чем отличается useReducer от useState?
	1. useState → императивный: напрямую задаёшь новое значение
	2. useReducer → декларативный: ты диспатчишь событие (dispatch(action)), и редьюсер решает, как изменится состояние.
	3. useReducer легче масштабировать
218. Как устроена редьюсер-функция? Какие параметры она принимает?
	1. Редьюсер — это чистая функция:
	2. (state, action) => newState, где 
		1. state — текущее состояние.
		2. action — объект, описывающий событие
	3. Возвращает новое состояние. Не мутирует предыдущее.
219. Что возвращает useReducer?
	1. Массив из двух значений: 
		1. - state — текущее состояние.
		2. dispatch — функция, которая запускает редьюсер.
220. Что такое функция dispatch?
	1. dispatch(action) — это функция, которая передаёт action в редьюсер и вызывает пересчёт нового состояния.
221. Как задать начальное состояние в useReducer и сделать ленивую инициализацию?
	1. через initFn
	2. initialArg — любое значение (можно undefined).
	3. initFn(initialArg) - возвращает начальное состояние (вызывается один раз).  
222. Как работает dispatch в useReducer? Можно ли вызывать его асинхронно?
	1. dispatch синхронно ставит обновление в очередь, но повторный рендер происходит асинхронно (в режиме батчинга React).
	2. dispatch сам не поддерживает async/await, но  можно вызывать его из useEffect, async function, setTimeout и т.д.
223. Как использовать useReducer с асинхронными операциями?
	1. Асинхронность обрабатывается вне редьюсера, а сам редьюсер — синхронный.
224. Как использовать useReducer вместе с useContext для глобального стейта?
	1. Создаёшь контекст, в который кладёшь [state, dispatch].
	2. Оборачиваешь Context.Provider вокруг <App>.
	3. Любой компонент может использовать useContext(Context) - получает state и dispatch.
225. Как React 18+ улучшает работу с useReducer (например, конкурентный режим и приоритеты обновлений)?
	1. Обновления через dispatch теперь участвуют в automatic batching.
226. Что происходит, если вызвать dispatch после размонтирования компонента?
	1. Никакой ошибки не будет, но dispatch вызовет ничего — компонент уже не существует.
	2. Решение — проверять isMounted через useRef или отменять побочные эффекты в cleanup.
227. Почему редьюсер должен быть чистой функцией? Какие проблемы возникают при мутации?
	1. Редьюсер обязан быть чистой функцией, потому что React полагается на сравнение по ссылке, чтобы понять, произошло ли изменение состояния. Если внутри редьюсера мутировать объект и возвращать ту же ссылку, React не обнаружит изменения и не перерендерит компонент.
228. Как избежать вызова dispatch после размонтирования компонента?
	1. В useEffect можно установить флаг при монтировании и сбросить его в cleanup
	2. Перед вызовом dispatch проверять этот флаг.
229. Можно ли использовать несколько редьюсеров в одном компоненте?
	1. Да, можно, каждый useReducer управляет своей частью данных и не зависит от других.
230. Как обновлять части состояния, если state — объект или массив, чтобы избежать мутаций?
	1. Вместо мутаций  создавать новую версию объекта или массива, копируя неизменённые части.
231. В чём различия между useReducer и Redux-подходом?
	1. useReducer — это локальный инструмент, предназначенный для управления сложным состоянием внутри одного компонента или изолированной части UI. Redux — это глобальный store, ориентированный на управление состоянием всего приложения

-----
### useTransition

232. Что делает useTransition и как отличить его поведение от обычного обновления?
	1. Без startTransition обновление может блокировать весь рендер; с startTransition — критичные части UI обновятся сразу, а «тяжёлые» — позже.
233. Как startTransition влияет на приоритет обновлений в React?
	1. React снижает приоритет запускаемых внутри startTransition обновлений до TransitionLane (в React scheduler), т.е. это concurrent и прерываемые обновления, в отличие от синхронных (DefaultLane, SyncLane) — они могут быть отложены, отменены или заблокированы Suspense
234. Что происходит, если вызвать startTransition внутри уже идущего startTransition?
	1. Никакого дополнительного эффекта не будет — вложенные startTransition не стекуются и не создают вложенные транзакции. Все вложенные обновления также будут иметь TransitionLane, то есть они остаются низкоприоритетными
235. Как React решает, когда прервать отложенный ререндер?
	1. Во время рендера React использует cooperative scheduling. Если текущий transition-рендер занимает слишком много времени (time slicing), он может быть прерван, чтобы отрисовать более приоритетные обновления (например, ввод). После прерывания запускается повторный рендер с учётом новых данных.
236. Как isPending синхронизирован между render-фазами?
	1. isPending — это значение, возвращаемое из useTransition, оно обновляется при старте и завершении transition-обновлений. Он не гарантирует точное состояние рендера, так как обновляется асинхронно и может отставать на один тик. Это флаг для UI-индикации, не для логики.
237. Как отменяется отложенное обновление, если пришёл новый input?
	1. Если во время transition приходит новый ввод, React прерывает текущий рендер и перезапускает его с актуальными данными. Предыдущая версия не применяется. Это возможно благодаря тому, что transition — прерываемый рендер.
238. Почему useTransition не вызывает повторного рендера сразу?
	1. Обновления внутри startTransition попадают в очередь с низким приоритетом. React может отложить их выполнение, если есть более важные дел
239. Как useTransition взаимодействует с Suspense?
	1. Если отложенное обновление внутри startTransition приводит к загрузке (<Suspense> fallback), React отрендерит fallback UI. Так как это transition, fallback будет временным, и пользователь может продолжать взаимодействие.
240. Как useTransition работает с React.memo, и влияет ли отложенное состояние на сравнение props?
	1. сли переданные props приходят из useDeferredValue или useTransition'а (через state), то React.memo сравнивает их обычным shallowEqual.
    
### useDeferredValue

241. Что делает useDeferredValue и в чём отличие от useTransition?
	1. useDeferredValue(value) возвращает отложенную версию value, которая обновляется с низким приоритетом.
	2. В отличие от useTransition, который оборачивает setState, useDeferredValue применяется к уже вычисленному значению.
242. Что произойдёт, если useDeferredValue применяется к primitive, object, array, function?
	1. useDeferredValue Работает с любыми типами.
	2. для объектов/массивов/функций важно, что сравнение идёт по ссылке, не по содержимому
243. Как работает сравнение значений prev vs deferred – shallow или deep?
	1. React сравнивает по ссылке (reference equality)
244. Когда useDeferredValue может не вызвать повторного рендера?
	1. Когда value изменился, но новое значение === предыдущему (для примитивов — по значению, для объектов — по ссылке).
	2. Также, если deferredValue всё ещё "догоняет" старое значение и не успел обновиться
245. Как работает с React.memo — что попадёт в areEqual(prevProps, nextProps)?
	1. React.memo сравнивает deferredValue, а не оригинальный value
246. Что происходит, если исходное значение меняется чаще, чем deferred успевает обновиться?
	1. deferredValue может "зависнуть" на старом значение
	2. React может пропустить промежуточные значения и применит только последнее, когда появится «окно» времени.
	3. Это поведение делает его похожим на автоматический дебаунс.
247. Как использовать useDeferredValue с Suspense и fallback UI?
	1. useDeferredValue можно применять к данным, загружаемым через Suspense.
	2. Отложенный переход позволит сначала показать fallback, не блокируя основной поток.
	3. Часто комбинируется с useMemo и React.lazy.
248. Может ли useDeferredValue вызывать tearing или лаги?
	1. да, если value и deferredValue попадают в разные рендеры компонентов
	2. Важно избегать чтения value и deferredValue одновременно в одном компоненте, чтобы не получить рассинхрон.
    
###  useSyncExternalStore
249. Что делает useSyncExternalStore и в каких случаях он необходим?
	1. useSyncExternalStore — это хук React, позволяющий синхронизировать состояние React-компонента с внешним (не React) стором или API.  
	2. Его основная задача — гарантировать, что подписка и чтение состояния извне происходит синхронно и без рассинхронизации. Это особенно важно для Concurrent Mode и SSR.
250. Какие аргументы принимает useSyncExternalStore и что он возвращает?
	1. subscribe — функция подписки на изменения внешнего стора. Она принимает коллбек, который вызывается при изменении данных, и возвращает функцию отписки.
	2. getSnapshot — функция, которая синхронно возвращает актуальный снимок (snapshot) состояния из стора. React вызывает её при рендере, чтобы получить текущее состояние.
	3. getServerSnapshot? — опциональная функция, которая возвращает snapshot для серверного рендера. Используется при SSR для генерации начального состояния, чтобы клиент и сервер были синхронизированы.
	4. возвращает текущее состояние (snapshot), которое получено из getSnapshot (или из getServerSnapshot при серверном рендере)
251. Почему нельзя использовать useState/useEffect для подписки на внешний store?
	1. useState + useEffect создают асинхронные обновления, которые могут привести к рассинхронизации UI,
	2. При SSR useEffect не вызывается, поэтому компонент на сервере и клиенте может получить разное состояние
	3. React не может гарантировать согласованность между рендером и подпиской
252. Какие проблемы решает useSyncExternalStore?
	1. Обеспечивает, что React читает актуальное состояние синхронно во время рендера
	2. Позволяет корректно подписываться на внешние изменения и автоматически отписываться при размонтировании или изменении подписки
	3. Обеспечивает согласованность состояния между серверным рендером и клиентской гидрацией.
253. Как работает getSnapshot и когда он должен быть стабилен?
	1. - getSnapshot — функция, которая возвращает текущее значение из внешнего стора.
	2. Она должна быть чистой и стабильной: при отсутствии изменений — возвращать одно и то же значение (сравнение через Object.is).
	3. Если данные в сторе не изменились — возвращать тот же объект/примитив , чтобы избежать лишних ререндеров.
	4. Если getSnapshot возвращает новый объект при каждом вызове — React будет ререндерить компонент бесконечно.
254. Что произойдёт, если getSnapshot возвращает новое значение при каждом вызове?
	1. приведёт к бесконечному циклу ререндеров
255. Как работает подписка — синхронно или асинхронно?
	1. Подписка через subscribe вызывается синхронно при изменениях в сторе
	2. React при получении уведомления вызывает getSnapshot и запускает ререндер.
	3. Подписка должна возвращать функцию отписки.
256. В чём разница между subscribe и getSnapshot по таймингу?
	1. subscribe — устанавливает слушателя изменений. Вызывается один раз при монтировании или обновлении хука. subscribe говорит React, когда вызвать getSnapshot.
	2. getSnapshot — вызывается при каждом рендере и при оповещении о событии изменения, чтобы получить актуальное значение.
257. Как работает SSR-поддержка через useSyncExternalStoreWithSelector?
	1. В SSR используется третий аргумент getServerSnapshot — возвращает начальное значение стора на сервере.
	2. При SSR getServerSnapshot вызывается только на сервере и при гидрации клиента.
	3. Если getServerSnapshot не передан, SSR рендер выбросит ошибку.
258. Что происходит, если snapshot меняется во время рендера?
	1. React запускает повторный рендер.
	2. Это связано с Concurrent Mode: React может дважды вызвать getSnapshot — перед и после применения изменений.
259. Какие ошибки возникают при нестабильном snapshot или unsubscribe?
	1. Бесконечные ререндеры.
	2. Если subscribe объявлен внутри компонента и меняется на каждом рендере, React будет переподписываться слишком часто, снижая производительность.
	3. Неправильный unsubscribe приведёт к утечке ресурсов.
    
### useInsertionEffect
260. Чем useInsertionEffect отличается от useEffect и useLayoutEffect?
	1. useInsertionEffect вызывается — до того, как React вставит DOM-узлы и выполнит useLayoutEffect. Это самый ранний эффект, нужен для синхронной вставки стилей перед любой отрисовкой.
261. Почему useInsertionEffect нужен для библиотек CSS-in-JS ?
	1. useInsertionEffect позволяет вставить стили до запуска любых layout-эффектов, тем самым гарантируя, что компоненты отрендерятся уже с правильными стилями.
262. Что произойдёт, если внутри useInsertionEffect сделать setState?
	1. React бросит ошибку или предупредит, потому что вызов обновления состояния в useInsertionEffect может привести к бесконечным циклам рендера и рассинхронизации фаз рендера.
	2. useInsertionEffect предназначен только для побочных эффектов, не меняющих состояние компонента.
263. Почему нельзя читать DOM внутри useInsertionEffect?
	1. В момент вызова useInsertionEffect DOM ещё не обновлён новым рендером.
	2. Чтение DOM может вернуть устаревшие данные или привести к ошибкам, поскольку React только начинает фазу commit, но ещё не применил изменения к DOM.
264. Как useInsertionEffect влияет на порядок вставки CSS и приоритет specificity?
	1. useInsertionEffect гарантирует, что стили вставляются раньше всех других эффектов, включая useLayoutEffect. Это обеспечивает правильный порядок <style>-тегов в <head>, что важно для корректного применения CSS-правил с нужным приоритетом (specificity).
265. Что произойдёт, если useInsertionEffect недоступен (например, SSR)?
	1. useInsertionEffect не вызывается на сервере, так как там нет DOM.
    
### useImperativeHandle
266. Как работает useImperativeHandle и зачем он нужен?
	1. позволяет кастомизировать объект, который родитель получит через ref.
267. Почему важно передавать второй аргумент в forwardRef, а не использовать useRef напрямую?
	1. В React 18 и ниже ref не приходит как проп — его нужно явно проксировать через forwardRef
	2. в React 19 forwardRef не нужен и ref можно прокидывать обычным пропсом
268. Можно ли в useImperativeHandle возвращать функции, которые используют stale props/state?
	1. Да, можно, если правильно указать зависимости:
269. В каких случаях стоит избегать useImperativeHandle вообще?
	1. Нет необходимости инкапсулировать доступ к DOM.
	2. Нужное поведение — декларативное, а не императивное.
	3. Применяется, когда это единственный способ выразить поведение: scroll, focus, animation trigger и т.д.
270. Что произойдёт, если ref в forwardRef null или изменится тип?
	1. Если ref === null, useImperativeHandle не выполнится — React ничего не запишет.
	2. Если ref изменит тип (например, с useRef() на колбэк-реф), React:
		1. сначала вызовет cleanup предыдущего handle (если был),
		2. потом вызовет createHandle для нового рефа.
    
### useDebugValue
271. Как работает useDebugValue и влияет ли он на продакшн-бандл?
	1. useDebugValue(value, formatFn?) — это хук, который используется исключительно для отладки в React DevTools.
	2. не влияет на поведение компонента, не вызывает побочные эффекты, удаляется на продакшн-сборке
### useOptimistic
272. Что делает useOptimistic и как он связан с Server Actions?
	1. useOptimistic(state, updateFn) позволяет временно подменять state UI-объектом, отражающим предполагаемый результат асинхронного действия, пока оно не завершится.
	2. useOptimistic позволяет сразу обновить UI, пока Server Action выполняется.
	3. После завершения Server Action (успешного или с ошибкой), произойдёт сброс optimistic state, и UI обновится с новыми реальными данными
273. Как выглядит типичная схема: optimistic update → реальный результат → reconcile?
	1. Пользователь отправляет данные
	2. addOptimistic(message) вызывается, UI сразу обновляется через updateFn
	3. В фоне стартует Server Action (или любой async logic).
	4. Когда async завершился:
		1. Если SSR — сервер возвращает новый state.
		2. Если CSR — клиент получает новые данные.
	5. UI «reconciles» — т.е. сбрасывается optimisticState → state
274. Как отменить optimistic state при отмене запроса или ошибке?
	1. Нет прямого API для отмены optimistic update вручную — React автоматически сбрасывает optimistic state
		1. произойдёт новый render с обновлённым state (например, после fetch),
		2. компонент размонтируется.
275. Можно ли использовать useOptimistic без form и Server Actions?
	1. Да. useOptimistic — универсальный хук, он не зависит от form или Server Actions, может использоваться в startTransition, onClick, onSubmit, внутри обычного async-обработчика.
276. Что произойдёт, если optimistic value конфликтует с новым реальным state?
	1. При следующем ререндере UI заменит optimistic state новым state, полученным извне
	2. Конфликтов не будет — useOptimistic не делает дифф между ними.
277. Как useOptimistic влияет на Suspense и конкурентный рендеринг?
	1. useOptimistic полностью совместим с Concurrent Mode.
	2. Он может использоваться внутри startTransition для немутирующего UI-обновления.
	3. Работает как низкоприоритетный рендер и не блокирует основной рендер.
	4. Если используется в дереве с <Suspense>, то optimistic UI отрендерится до suspense-фолбека.
278. Как работает updateFn и почему важно возвращать новый объект, а не мутировать?
	1. updateFn(state, optimisticValue) должен возвращать новый state.
	2. React ожидает иммутабельность — мутирование state не вызовет правильного рендера и может сломать работу.
279. Может ли useOptimistic быть использован с внешними state management (Redux/Zustand)?
	1. Да, но useOptimistic — локальный хук, он не управляет внешним хранилищем.
	2. Он не должен напрямую мутировать Zustand/Redux state.
	3. Оптимистичное состояние может быть только для UI, а после успешного запроса обновляется реальный стор:
    
### useActionState

280. Чем useActionState отличается от обычного useState + useEffect?
	1. useActionState объединяет в себе управление локальным состоянием и вызов асинхронной формы-ориентированной функции (action), обновляя состояние по результату action.
	2. В отличие от useState + useEffect, где нужно вручную слушать изменения и обновлять состояние, useActionState автоматически синхронизирует состояние с результатом последнего вызова action.
281. Для чего нужен useActionState?
	1. Управление состоянием, которое обновляется в результате отправки формы или вызова асинхронного action.
	2. Синхронизация UI с результатом серверной функции (Server Action) при прогрессивной гидратации и взаимодействии.
	3. Облегчение написания интерактивных форм и асинхронных действий без громоздких эффектов.
282. Какие аргументы принимает useActionState?
	1. - actionFn: асинхронная функция или Server Action, вызываемая при отправке формы. Получает первым аргументом текущий (или предыдущий) state, затем formData.
	2. initialState начальное значение состояния до первой отправки формы.
	3. permalink (опционально): URL для прогрессивного улучшения на динамических страницах (редиректы до гидратации).
283. Что возвращает useActionState?
	1. Состояние (state) — это значение, которое возвращает переданная функция после выполнения. Изначально оно равно initialState, а потом обновляется при каждом вызове.
	2. Функция действия (action) — обёртка над твоей функцией. Её можно передать как action={...} в форму или вызывать вручную. Она принимает formData и вызывает переданную функцию с prevState и formData.
	3. Флаг isPending — указывает, выполняется ли сейчас action. Автоматически становится true при запуске и false после завершения, даже если внутри используется await.
284. Как useActionState помогает обрабатывать формы и асинхронные действия?
	1. Возвращает изменяемый state, который отражает результат последнего выполненного action.
	2. Возвращает модифицированный action (formAction), который следует использовать в <form action={formAction}> или в кнопке с formAction.
	3. Автоматически управляет состоянием ожидания (isPending) для UI.
	4. Обновляет state после завершения action, вызывая ререндер компонента
285. Что делает action(prevState, formData) и как использовать formData внутри?
	1. action — функция с подписью (prevState, formData) => newState | Promise<newState>.
	2. prevState — текущее состояние формы/компонента до отправки.
	3. formData — объект FormData с данными формы, передаваемый при отправке.
	4. Внутри action можно обрабатывать formData, вычислять новое состояние на основе предыдущего, возвращать результат синхронно или асинхронно.
286. Как работает взаимодействие с Server Actions?
	1. При использовании с Server Actions useActionState позволяет получить результат выполнения серверной функции и сразу обновить локальное состояние.
	2. При этом форма может быть интерактивной до полной гидратации, так как React уже знает, как обновлять состояние на основе ответа сервера.
	3. - permalink позволяет задать URL для прогрессивного улучшения на серверных маршрутах.
287. Что происходит, если action возвращает ошибку — влияет ли это на UI?
	1. Если action выбрасывает ошибку (reject), useActionState не обновит состояние.
	2. Ошибка не перехватывается внутри хука — нужно обрабатывать её вручную (например, try/catch внутри action или обрабатывать ошибки глобально).
	3. В UI состояние останется прежним, и isPending перейдёт в false.
	4. Для отображения ошибок лучше использовать отдельный state или структуру данных, возвращаемую из action.
288. Можно ли вызвать setState внутри action напрямую?
	1. Нет. action — чистая функция, которая должна возвращать новое состояние.
	2. Вызовы локальных React setState вне компонента из action невозможны.
	3. Все обновления состояния происходят через возвращаемое значение action и механизм useActionState.
289. Как сбрасывается state, если отправка формы отменена или изменилась?
	1. Если отправка отменена (например, переход на другую страницу), состояние useActionState остаётся текущим до следующей успешной отправки.
	2. Если меняется initialState при повторном рендере, он игнорируется после первого действия — состояние сохраняется между отправками.
	3. Для сброса состояния нужно либо использовать отдельную логику, либо заново размонтировать компонент
290. Как useActionState влияет на retry, Suspense и optimistic UI?
	1. useActionState автоматически обновляет состояние по результату action, что упрощает retry — достаточно повторить вызов action.
	2. Поддержка Suspense и progressive hydration реализуется через серверные механизмы React и Server Actions.
	3. Для сложного optimistic UI лучше использовать useOptimistic или сторонние подходы, так как useActionState ориентирован на результат action, а не промежуточное состояние.
291. Как синхронизировать состояние useActionState с пропсами?
	1. useActionState не синхронизируется с пропсами автоматически. Он использует initialState только один раз при инициализации и больше не реагирует на его изменени
	2. Для синхронизации с внешними данными (пропсами или глобальным стором) нужно либо использовать локальный useState и синхронизировать его вручную через useEffect, либо вообще не использовать useActionState и управлять стейтом внешне

292. Когда уместно использовать React.memo для функциональных компонентов?
293. Как React.memo сравнивает пропсы по умолчанию и какие есть ограничения такого сравнения?
294. В каких случаях следует передавать areEqual(prevProps, nextProps) в React.memo и что имеет смысл сравнивать внутри него?
295. Какие анти‑паттерны применения React.memo приводят к ложной оптимизации и росту сложности?
296. Почему мемоизация малозатратных компонентов может ухудшить производительность приложения?
297. Как React.memo взаимодействует с контекстом (Context): когда изменения провайдера инвалидируют мемоизацию?
298. Как мемоизация колбэков через useCallback влияет на работу React.memo у дочерних компонентов?
299. Как разграничить роли useMemo, useCallback и React.memo, и где границы ответственности каждого?
300. В чём отличия createRef и useRef по жизненному циклу и типичным сценариям использования?
301. Когда предпочтительно использовать callback‑refs вместо объектных ref и какие у этого подхода подводные камни?
302. Какие особенности и риски у callback‑refs (многократные вызовы, порядок обновления, стабильность ссылок)?
X3. Зачем задавать displayName для компонентов, использующих forwardRef, и когда это помогает отладке?
303. В каких случаях стоит хранить временное состояние в ref вместо state, и какие риски у такого решения?
304. Почему обновление ref не вызывает рендер и как это использовать в производительных обработчиках?
305. Какие задачи решают утилиты React.Children.map/forEach/toArray/only и когда их применять?
306. Когда уместно использовать React.cloneElement и как избежать проблем с ключами (key) и ref при композиции?
307. Как проверить, что значение является валидным React‑элементом с помощью React.isValidElement и зачем это нужно?
308. Какие паттерны передачи пропсов вниз можно реализовать с помощью cloneElement и/или контекста без «проп‑дриллинга»?
309. Как безопасно прокидывать ключевые пропсы (key, ref) при композиции элементов и HOC‑паттернах?
310. Как React приоритизирует события в конкурентном режиме и какие уровни приоритета событий существуют?
311. Чем Pointer Events отличаются от Mouse/Touch событий и как правильно работать с ними в React?
312. Как ведут себя stopPropagation и preventDefault в системе SyntheticEvent по сравнению с нативными событиями?
313. Почему stopPropagation может не остановить обработчики вне React (на документе/окне), и как это учитывать в архитектуре?
314. Почему не рекомендуется использовать индекс массива как key при рендере списков и какие бывают исключения?
315. Как обеспечить стабильность ключей при сортировках, вставках и удалениях элементов списка?
316. Как некорректные ключи влияют на локальное состояние и эффекты дочерних компонентов (mount/unmount, сохранность input‑значений)?
317. Как подбирать key при наличии дублирующихся данных (одинаковые названия) и отсутствии уникальных идентификаторов?
318. Что такое Error Boundary в React и какие ошибки он перехватывает?
319. Какие ошибки не перехватываются Error Boundary (обработчики событий, async‑ошибки, SSR)?
320. Где располагать Error Boundary в дереве и сколько границ имеет смысл заводить?
321. Как проектировать fallback UI и стратегию восстановления (reset) для Error Boundary?
322. Как сбрасывать Error Boundary (например, через смену key у границы/поддерева)?
323. Как Error Boundary взаимодействует с Suspense и что перехватывается при ошибке загрузки?
324. Какие ограничения у Error Boundary для функциональных компонентов и какие есть альтернативы?
325. Что такое React.Profiler и для чего он используется?
326. Как работает onRender у React.Profiler (сигнатура колбэка, фазы mount/update)?
327. Когда использовать DevTools Profiler и какие представления смотреть (Flamegraph, Ranked)?
328. Как корректно проводить измерения в React: сборка для продакшена, прогрев, стабильные сценарии?
329. Какие типичные сигналы профилирования указывают на проблемы (частые рендеры, долгие коммиты)?
330. Чем createRoot отличается от legacy ReactDOM.render и почему его следует использовать?
331. Когда применять hydrateRoot вместо createRoot и как это связано с SSR/гидратацией?
332. Какие опции поддерживает Root API (onRecoverableError, identifierPrefix) и когда они полезны?
333. Как переход на createRoot влияет на Strict Mode и поведение эффектов в dev‑режиме?
334. Какие уровни приоритета событий в React существуют (discrete, continuous, default)?
335. Какие события относятся к каждому приоритету и как это влияет на отзывчивость UI?
336. Как работает реплей событий при гидратации и какие события повторяются после инициализации?
337. Какие риски у реплея событий (дубликаты, порядок), и как их минимизировать на практике?
338. Что делает act() в тестах React и зачем оборачивать в него обновления состояния/DOM?
339. Какие операции нужно оборачивать в act() (таймеры, промисы, события) и как работать с async‑act?
340. Какие типичные ошибки возникают при пропуске act() и как их отлаживать?
341. Что такое cache() в современном React и какие задачи решает (кэширование ресурсов/функций)?
342. Какие стратегии и ограничения у кэширования через cache() (ключи, инвалидация, TTL/политики)?
343. Как cache() соотносится с кэшами фреймворков (например, Next.js) и когда что выбирать?
344. Как работает React.lazy и чем он отличается от голого динамического import()?
345. Как обрабатывать ошибки загрузки при React.lazy (границы ошибок, повторная попытка)?
346. Какие приёмы предзагрузки/предвыборки есть для компонентов на React.lazy и как связать их с Suspense?
347. Какие ограничения у React.lazy при SSR и какие есть пути их обхода?
348. Что такое контекст‑селекторы и как они помогают снизить количество перерисовок при изменениях контекста?
349. Когда имеет смысл разделять значение провайдера на несколько контекстов (данные/диспатч/метаданные)?
350. Как реализовать паттерн селектора поверх контекста (через мемоизацию значения, useSyncExternalStore(WithSelector) и/или подписку на часть value)?
351. Какие подводные камни у контекста: нестабильная ссылка value, вложенные провайдеры, stale‑замыкания?
352. Как безопасно мемоизировать value провайдера (зависимости, структурная/частичная мемоизация, производительность)?
353. Когда контекст — неподходящий инструмент и лучше выбрать state‑manager (Redux/Zustand) или колокализацию состояния?
354. Чем всплытие/перехват в SyntheticEvent отличаются от нативного DOM и как это влияет на обработчики?
355. Как использовать фазу перехвата в React (onClickCapture) и когда это нужно?
356. Как соотносятся stopPropagation/preventDefault в синтетических событиях и нативных слушателях (в т.ч. на документе/окне)?
357. Что произойдёт с preventDefault() для пассивных слушателей (ограничения, когда вызов будет проигнорирован)?
358. Почему stopPropagation может не остановить нативные обработчики вне React‑дерева или в порталах?
359. Что изменилось с пуллингом событий (event pooling) в React 17+ и как это влияет на доступ к объекту события?
360. Как планируются/приоритизируются обработчики событий в конкурентном режиме и чем это отличается от синхронного?
361. Какие edge‑кейсы SSR встречаются при гидратации: прерывание/откат гидратации, recoverable errors?
362. Как обрабатываются пользовательские события, произошедшие до завершения гидратации (event replay) и какие есть ограничения?
363. Какие проблемы возникают при одновременных клиентских переходах (startTransition) во время гидратации и как их смягчить?
364. Как избежать каскадов Suspense при Streaming SSR и гарантировать предсказуемый порядок появления контента?
365. Какие причины у hydration mismatch в динамическом контенте (время, локаль, случайные значения) и как их исключить?
366. Как корректно гидратировать порталы и узлы, созданные вне корневого контейнера, чтобы избежать потери событий?
367. Как сочетать SSR/Streaming с React.lazy и что делать при ошибках загрузки чанков на клиенте?
368. Как согласовать серверные данные и их повторную загрузку на клиенте (double fetch, race conditions) без мигания UI?
369. Что такое captureOwnerStack в React и зачем собирается стек владельцев в dev‑режиме?
370. Как captureOwnerStack влияет на диагностические сообщения и производительность?