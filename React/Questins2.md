
292. Когда уместно использовать `React.memo` для функциональных компонентов?
293. Как `React.memo` сравнивает пропсы по умолчанию и какие есть ограничения такого сравнения?
294. В каких случаях следует передавать areEqual(prevProps, nextProps) в `React.memo` и что имеет смысл сравнивать внутри него?
295. Какие анти‑паттерны применения `React.memo` приводят к ложной оптимизации и росту сложности?
296. Почему мемоизация малозатратных компонентов может ухудшить производительность приложения?
297. Как `React.memo` взаимодействует с контекстом (Context): когда изменения провайдера инвалидируют мемоизацию?
298. Как мемоизация колбэков через `useCallback` влияет на работу `React.memo` у дочерних компонентов?
299. Как разграничить роли `useMemo`, `useCallback` и `React.memo`, и где границы ответственности каждого?
300. В чём отличия createRef и useRef по жизненному циклу и типичным сценариям использования?
301. Когда предпочтительно использовать callback‑refs вместо объектных ref и какие у этого подхода подводные камни?
302. Какие особенности и риски у callback‑refs (многократные вызовы, порядок обновления, стабильность ссылок)?
X3. Зачем задавать displayName для компонентов, использующих forwardRef, и когда это помогает отладке?
303. В каких случаях стоит хранить временное состояние в ref вместо `state`, и какие риски у такого решения?
304. Почему обновление ref не вызывает рендер и как это использовать в производительных обработчиках?
305. Какие задачи решают утилиты React.Children.map/forEach/toArray/only и когда их применять?
306. Когда уместно использовать React.cloneElement и как избежать проблем с ключами (key) и ref при композиции?
307. Как проверить, что значение является валидным React‑элементом с помощью React.isValidElement и зачем это нужно?
308. Какие паттерны передачи пропсов вниз можно реализовать с помощью cloneElement и/или контекста без «проп‑дриллинга»?
309. Как безопасно прокидывать ключевые пропсы (key, ref) при композиции элементов и HOC‑паттернах?
310. Как React приоритизирует события в конкурентном режиме и какие уровни приоритета событий существуют?
311. Чем Pointer Events отличаются от Mouse/Touch событий и как правильно работать с ними в React?
312. Как ведут себя stopPropagation и preventDefault в системе SyntheticEvent по сравнению с нативными событиями?
313. Почему stopPropagation может не остановить обработчики вне React (на документе/окне), и как это учитывать в архитектуре?
314. Почему не рекомендуется использовать индекс массива как key при рендере списков и какие бывают исключения?
315. Как обеспечить стабильность ключей при сортировках, вставках и удалениях элементов списка?
316. Как некорректные ключи влияют на локальное состояние и эффекты дочерних компонентов (mount/unmount, сохранность input‑значений)?
317. Как подбирать key при наличии дублирующихся данных (одинаковые названия) и отсутствии уникальных идентификаторов?
318. Что такое Error Boundary в React и какие ошибки он перехватывает?
319. Какие ошибки не перехватываются Error Boundary (обработчики событий, async‑ошибки, SSR)?
320. Где располагать Error Boundary в дереве и сколько границ имеет смысл заводить?
321. Как проектировать fallback UI и стратегию восстановления (reset) для Error Boundary?
322. Как сбрасывать Error Boundary (например, через смену key у границы/поддерева)?
323. Как Error Boundary взаимодействует с Suspense и что перехватывается при ошибке загрузки?
324. Какие ограничения у Error Boundary для функциональных компонентов и какие есть альтернативы?
325. Что такое React.Profiler и для чего он используется?
326. Как работает onRender у React.Profiler (сигнатура колбэка, фазы mount/update)?
327. Когда использовать DevTools Profiler и какие представления смотреть (Flamegraph, Ranked)?
328. Как корректно проводить измерения в React: сборка для продакшена, прогрев, стабильные сценарии?
329. Какие типичные сигналы профилирования указывают на проблемы (частые рендеры, долгие коммиты)?
330. Чем createRoot отличается от legacy ReactDOM.render и почему его следует использовать?
331. Когда применять hydrateRoot вместо createRoot и как это связано с SSR/гидратацией?
332. Какие опции поддерживает Root API (onRecoverableError, identifierPrefix) и когда они полезны?
333. Как переход на createRoot влияет на Strict Mode и поведение эффектов в dev‑режиме?
334. Какие уровни приоритета событий в React существуют (discrete, continuous, default)?
335. Какие события относятся к каждому приоритету и как это влияет на отзывчивость UI?
336. Как работает реплей событий при гидратации и какие события повторяются после инициализации?
337. Какие риски у реплея событий (дубликаты, порядок), и как их минимизировать на практике?
338. Что делает act() в тестах React и зачем оборачивать в него обновления состояния/DOM?
339. Какие операции нужно оборачивать в act() (таймеры, промисы, события) и как работать с async‑act?
340. Какие типичные ошибки возникают при пропуске act() и как их отлаживать?
341. Что такое cache() в современном React и какие задачи решает (кэширование ресурсов/функций)?
342. Какие стратегии и ограничения у кэширования через cache() (ключи, инвалидация, TTL/политики)?
343. Как cache() соотносится с кэшами фреймворков (например, Next.js) и когда что выбирать?
344. Как работает React.lazy и чем он отличается от голого динамического import()?
345. Как обрабатывать ошибки загрузки при React.lazy (границы ошибок, повторная попытка)?
346. Какие приёмы предзагрузки/предвыборки есть для компонентов на React.lazy и как связать их с Suspense?
347. Какие ограничения у React.lazy при SSR и какие есть пути их обхода?
348. Что такое контекст‑селекторы и как они помогают снизить количество перерисовок при изменениях контекста?
349. Когда имеет смысл разделять значение провайдера на несколько контекстов (данные/диспатч/метаданные)?
350. Как реализовать паттерн селектора поверх контекста (через мемоизацию значения, useSyncExternalStore(WithSelector) и/или подписку на часть value)?
351. Какие подводные камни у контекста: нестабильная ссылка value, вложенные провайдеры, stale‑замыкания?
352. Как безопасно мемоизировать value провайдера (зависимости, структурная/частичная мемоизация, производительность)?
353. Когда контекст — неподходящий инструмент и лучше выбрать `state`‑manager (`Redux`/`Zustand`) или колокализацию состояния?
354. Чем всплытие/перехват в SyntheticEvent отличаются от нативного DOM и как это влияет на обработчики?
355. Как использовать фазу перехвата в React (`onClick`Capture) и когда это нужно?
356. Как соотносятся stopPropagation/preventDefault в синтетических событиях и нативных слушателях (в т.ч. на документе/окне)?
357. Что произойдёт с preventDefault() для пассивных слушателей (ограничения, когда вызов будет проигнорирован)?
358. Почему stopPropagation может не остановить нативные обработчики вне React‑дерева или в порталах?
359. Что изменилось с пуллингом событий (event pooling) в React 17+ и как это влияет на доступ к объекту события?
360. Как планируются/приоритизируются обработчики событий в конкурентном режиме и чем это отличается от синхронного?
361. Какие edge‑кейсы SSR встречаются при гидратации: прерывание/откат гидратации, recoverable errors?
362. Как обрабатываются пользовательские события, произошедшие до завершения гидратации (event replay) и какие есть ограничения?
363. Какие проблемы возникают при одновременных клиентских переходах (`startTransition`) во время гидратации и как их смягчить?
364. Как избежать каскадов Suspense при Streaming SSR и гарантировать предсказуемый порядок появления контента?
365. Какие причины у hydration mismatch в динамическом контенте (время, локаль, случайные значения) и как их исключить?
366. Как корректно гидратировать порталы и узлы, созданные вне корневого контейнера, чтобы избежать потери событий?
367. Как сочетать SSR/Streaming с React.lazy и что делать при ошибках загрузки чанков на клиенте?
368. Как согласовать серверные данные и их повторную загрузку на клиенте (double fetch, race conditions) без мигания UI?
369. Что такое captureOwnerStack в React и зачем собирается стек владельцев в dev‑режиме?
370. Как captureOwnerStack влияет на диагностические сообщения и производительность?