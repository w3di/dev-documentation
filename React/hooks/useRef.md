 хук , который позволяет создавать изменяемую ссылку на DOM-элемент или любое другое значение, которое сохраняется между рендерами.


```jsx
//Inside of React  
function useRef(initialValue) {  
	const [ref, unused] = useState({ current: initialValue });  
	return ref;  
}
```

### useRef(initialValue) 

```jsx
import { useRef } from 'react';

function MyComponent() { 
	const intervalRef = useRef(0);
	const inputRef = useRef(null);  
	// ...
```

 **Аргумент**: `initialValue` — начальное значение свойства `current` объекта ссылки. Используется только при первом рендере.
 
-**Возврат**: объект со свойством `current`, которое можно менять между рендерами.

`useRef` сохраняет тот же объект между рендерами.

## Важные моменты

- **Изменяемость**: `ref.current` можно изменять, но не использовать для данных, влияющих на рендеринг.

- **Без перерендера**: Изменение `ref.current` не вызывает повторный рендер.

- **Чтение/запись**: Используйте `ref.current` для записи и чтения только вне рендеринга, иначе это может вызвать непредсказуемое поведение.


## Применение useRef

`useRef` подходит для хранения данных, которые не влияют на рендер. Например, чтобы сохранить идентификатор интервала:

```jsx
function handleStartClick() {
	const intervalId = setInterval(() => {
		// ... 
	}, 1000);
	intervalRef.current = intervalId;
}

function handleStopClick() {
	const intervalId = intervalRef.current;
	clearInterval(intervalId);
}
```

Здесь `intervalRef` сохраняет идентификатор интервала между вызовами, не вызывая повторный рендер.


## Когда использовать useState вместо useRef?

**Используйте `useState`, когда**:

- Нужно управлять значениями, которые влияют на интерфейс и требуют ререндера. Например, если изменение должно быть отображено в интерфейсе, лучше использовать `useState`, так как он вызывает повторный рендер.

**Используйте `useRef`, когда**:

- Нужно сохранить изменяемые данные или ссылки на DOM, которые не должны вызывать ререндер. Это подходит для хранения значений между рендерами или для доступа к DOM-элементам, поскольку изменения в `ref` не инициируют ререндер.

Таким образом, `useState` подходит для значений, влияющих на интерфейс, а `useRef` — для данных, которые не требуют обновления интерфейса.

| Параметр                     | Refs                                          | State                                         |
|------------------------------|-----------------------------------------------|----------------------------------------------|
| **Использование**            | Для доступа к DOM-элементам и хранения изменяемых значений, не вызывая повторный рендер. | Для управления состоянием компонентов, влияющим на рендер. |
| **Возвращаемое значение**    | Возвращает объект с полем `current`, содержащим текущее значение. | Возвращает массив: текущее значение состояния и функцию для его обновления. |
| **Изначальное значение**     | Необязательно передавать при инициализации. | Обязательно передавать при вызове `useState()`. |
| **Повторный рендер**         | Не вызывает повторный рендер при изменении значения. | Вызывает повторный рендер при изменении значения. |
| **Изменяемость**            | Значение можно изменять напрямую.            | Значение считается "неизменяемым"; для изменения необходимо использовать функцию обновления состояния. |
| **Чтение во время рендера**  | Не рекомендуется читать или записывать значение во время рендера. | Можно читать состояние в любое время; каждое рендеринг имеет свою собственную "снимок" состояния, который не меняется. |

### Когда использовать `refs` в React

- **Сохранения идентификаторов таймеров**: для данных, не влияющих на рендеринг.
- **Работы с DOM**: например, для программной фокусировки на элементе.
- **Хранения данных вне рендеринга**: для значений, не связанных с визуальным обновлением.


### Манипулирование DOM с помощью ссылки в React 

### Получение ссылки на DOM-узел

Импортируйте хук `useRef`:
```jsx
import { useRef } from 'react';
```

Объявите `ref` в компоненте:
```jsx
const myRef = useRef(null);
```

Передайте `ref` в атрибут `ref` JSX-тега:
```jsx
<div ref={myRef}></div>
```

`useRef` возвращает объект с свойством `current`, изначально равным `null`. Когда React создаст DOM-узел, он поместит ссылку в `myRef.current`, что позволит использовать браузерные API


### Управление списком рефов с помощью колбека рефа

Для создания рефов для динамического списка можно использовать колбек рефа. Это позволяет React вызывать ваш колбек с DOM-узлом для установки рефа и с `null` для очистки.

```jsx
  const itemsRef = useRef(null);
  const [catList, setCatList] = useState(setupCatList);

  function getMap() {
    if (!itemsRef.current) {
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }
	...
        <ul>
          {catList.map((cat) => (
            <li
              key={cat.id}
              ref={node => {
                const map = getMap();
                if (node) {
                  map.set(cat, node);
                } else {
                  map.delete(cat);
                }
              }}
            >
              {cat.name}
            </li>
          ))}
        </ul>
    ...
```

#### Альтернативный подход

Управление с функцией очистки:

```jsx
<li
  key={cat.id}
  ref={node => {
    const map = getMap();
    map.set(cat, node);
    
    return () => {
      map.delete(cat);
    };
  }}
>
  {cat.name}
</li>

```

## Удаление узла из DOM

При удалении узла из DOM React возвращает свойство `current` к `null`. Это позволяет управлять состоянием элементов без повторной отрисовки компонента. Хук `useRef` упрощает доступ к элементам DOM и сохраняет значения между перерисовками, не вызывая их обновление.

## Доступ к узлам DOM другого компонента

Когда вы добавляете `ref` к встроенному компоненту, например `<input />`, React устанавливает `inputRef.current` на соответствующий DOM-узел. Однако, если вы попытаетесь сделать то же самое с вашим компонентом `<MyInput />`, получите предупреждение:

```
Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?
```

Это происходит, потому что React не позволяет компонентам получать доступ к DOM-узлам. Чтобы это исправить, используйте `React.forwardRef`, чтобы ваш компонент мог принимать `ref` и передавать его дальше:

```jsx
const MyInput = React.forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});
```

Теперь, при использовании `<MyInput ref={inputRef} />`, `inputRef.current` будет указывать на DOM-узел `<input>`. В дизайн-системах рекомендуется перенаправлять `refs` для низкоуровневых компонентов, таких как кнопки и поля ввода, но избегать доступа к DOM-узлам высокоуровневых компонентов.


### Экспонирование подмножества API с помощью императивного обработчика

В примере `MyInput` предоставляет доступ к DOM-элементу ввода, позволяя родительскому компоненту вызывать любые манипуляции с компонентом. Однако, чтобы ограничить доступные функции, используйте `useImperativeHandle`:

```jsx
import {
  forwardRef, 
  useRef, 
  useImperativeHandle
} from 'react';

const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    // Экспонируем только метод focus и больше ничего
    focus() {
      realInputRef.current.focus();
    },
  }));
  return <input {...props} ref={realInputRef} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Сфокусировать ввод
      </button>
    </>
  );
}
```

Здесь `useImperativeHandle` позволяет родительскому компоненту получать доступ только к методу `focus`, исключая другие возможности взаимодействия с DOM.
В этом случае «обработчик» рефа не является DOM-узлом, а представляет собой настраиваемый объект, который вы создаёте внутри вызова `useImperativeHandle`.

## Когда React прикрепляет refs

React прикрепляет refs во время **этапа коммита**, который происходит после этапа рендеринга.

1. **Этап рендеринга:** React вызывает компоненты для определения, что должно отображаться. В этот момент refs еще недоступны.
2. **Этап коммита:**
    - Перед обновлением DOM React устанавливает `ref.current` в `null`.
    - После обновления DOM значения `ref.current` присваиваются соответствующим DOM-узлам.

Таким образом, доступ к refs рекомендуется получать из обработчиков событий или внутри эффектов, а не во время рендеринга.


### Синхронное обновление состояния с помощью flushSync

Чтобы решить проблему с асинхронным обновлением состояния в React и обеспечить прокрутку к последнему элементу списка при добавлении, используйте `flushSync` из `react-dom`. Это заставляет React обновить DOM сразу после выполнения обернутого кода. Вот исправленный код:

```jsx
import { useState, useRef } from 'react';
import { flushSync } from 'react-dom';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    flushSync(() => {
      setText('');
      setTodos([...todos, newTodo]);
    });
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={e => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}
```

Теперь при добавлении новой задачи прокрутка будет корректной.


## Резюме

- `Refs` хранят значения, которые не участвуют в рендеринге.
- `Ref` — это объект с полем `current`.
- `useRef` создаёт `ref`.
- Изменение `ref.current` не вызывает ререндер.
- Не изменяйте и не читайте `ref.current` в рендере.