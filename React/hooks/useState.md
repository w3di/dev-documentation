
`useState` используется для объявления переменной состояния в компоненте.

```js
import { useState } from 'react';

function MyComponent() {
  const [age, setAge] = useState(28);
  const [name, setName] = useState('Taylor');
  const [todos, setTodos] = useState(() => createTodos());
}
```

### Параметры

- `initialState`: Начальное значение состояния (любого типа). Если передать функцию, она будет вызвана при инициализации и её результат станет начальным состоянием.

### Возвращаемые значения

`useState` возвращает:
1. Текущее состояние.
2. Функцию `set`, которая обновляет состояние и вызывает ререндер.

### Ограничения функции set в React:

`set`Функции не имеют возвращаемого значения.

1. **Обновление состояния:** Функция `set` обновляет состояние только для следующего рендера. Чтение значения состояния сразу после вызова `set` вернёт старое значение.
    
2. **Оптимизация повторного рендера:** Если новое значение идентично текущему (по сравнению с `Object.is`), React пропускает повторный рендер компонента и его дочерних элементов.
    
3. **Группировка обновлений:** React группирует обновления состояния, обновляя экран только после завершения всех обработчиков событий, что предотвращает множественные рендеры - часть Батчинга.
    
4. **Использование flushSync:** В редких случаях, чтобы обновить экран раньше, можно использовать `flushSync`.
    
5. **Стабильная идентичность set:** Функция `set` имеет стабильную идентичность, поэтому её часто не включают в зависимости эффектов. Если линтер не выдаёт ошибок, это безопасно.
    
6. **Вызов set во время рендеринга:** Вызов `set` допустим только из текущего рендерящегося компонента. React проигнорирует вывод и снова попытается рендерить с новым состоянием.

7. **Асинхронность обновлений:** Обновления состояния в React асинхронны, что означает, что вызов функции `set` не приводит к немедленному обновлению состояния. Это важно учитывать, если необходимо выполнить какие-либо действия сразу после изменения состояния.
   

Вызов `set`функции **не** изменяет текущее состояние в уже выполняемом коде

```js
const [name, setName] = useState('Taylor');

function handleClick() {
	setName('Robin'); 
	console.log(name); // Still "Taylor"!
}
```

Это влияет только на то, что `useState`будет возвращено, начиная со _следующего_ рендера.


### Обновление состояния на основе предыдущего состояния в React

Если вы вызываете `setState` несколько раз с одним и тем же значением, обновления состояния не срабатывают последовательно. Например:

```js
function handleClick() {
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
}
```
После одного щелчка значение `age` будет равно 43, а не 45, так как каждое обновление использует старое состояние

Для правильного обновления состояния несколько раз в одном событии можно использовать функцию-обновитель:
```js
function handleClick() {
  setAge(a => a + 1); // setAge(42 => 43)
  setAge(a => a + 1); // setAge(43 => 44)
  setAge(a => a + 1); // setAge(44 => 45)
}
```

Вот `a => a + 1`ваша функция обновления. Она берет **состояние ожидания** и вычисляет из него следующее состояние .

React помещает ваши функции обновления в  затем, во время следующего рендеринга, он будет вызывать их в том же порядке:

#### Плюсы использования функции-обновителя:
1. **Гарантированная последовательность** — каждое обновление основано на актуальном значении состояния.
2. **Очередь обновлений** — React обновляет состояние в порядке вызова функций.
3. **Удобство при множественных обновлениях** — когда необходимо выполнить несколько обновлений в одном событии, использование функции-обновителя исключает проблемы с «устаревшими» значениями.

#### Рекомендации:
- Используйте функцию-обновитель, если новое состояние вычисляется на основе предыдущего.

### Обновление объектов и массивов в состоянии

Вы можете помещать объекты и массивы в состояние. В React состояние считается доступным только для чтения, поэтому **вам следует _заменить_ его, а не _изменять_ существующие объекты** .

```js
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleTitleChange() {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: Red Nana
      }
    });
  }
}
```


### Избежание повторного создания начального состояния

При использовании `useState` для инициализации состояния, функция для создания начального состояния может вызываться на каждом рендере, что может быть неэффективно, особенно если она выполняет тяжелые вычисления или создает большие массивы.

```js
function createInitialTodos() {
  console.log('Создание начального состояния');
  return [
    { id: 1, text: 'Купить молоко' },
    { id: 2, text: 'Прочитать книгу' },
  ];
}
```
    
2. В этом случае `createInitialTodos()` вызывается на каждом рендере, что неэффективно.
    
```js
const [todos, setTodos] = useState(createInitialTodos());
```
    
    
3. Здесь мы передаем саму функцию `createInitialTodos` в `useState`, и React вызовет её только при инициализации.
    
```js
const [todos, setTodos] = useState(createInitialTodos);
```

 4. Этот вариант также вызывает `createInitialTodos` только один раз, но обертывает его в стрелочную функцию. Ведет себя так же, как и предыдущий вариант.
 
```js
const [todos, setTodos] = useState(() => createInitialTodos());
```