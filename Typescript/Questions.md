### Основы и типы данных

1. Чем типы `any` и `unknown` отличаются в TypeScript и когда использовать каждый?
	1. `any` отключает проверку типов и позволяет делать со значением что угодно (любой доступ, вызов, присваивание).
	2. `unknown` безопаснее: требует сужения типа (type guard, проверка) или явного приведения перед использованием.
	3. `any` «протекает» в другие типы и ломает проверку вниз по цепочке; `unknown` останавливает небезопасные операции на границе.
2. Чем различаются типы `void` и `never` в TypeScript, и где они применяются?
	1. `void` — функция возвращает «ничего»; значение можно проигнорировать. `Promise<void>` значит «промис завершится без результата».
	2. `never` — функция не завершается успешно: бросает ошибку или бесконечно работает. Полезно для исчерпывающих проверок (exhaustiveness).
	3. `never` подтип любого типа; ни один тип не подтип `never` (кроме него самого).
3. В чём разница между модификатором `readonly` и утверждением `as const` в TypeScript?
	1. `readonly` (в типах/классах/массиве `ReadonlyArray<T>`) делает свойства/элементы неизменяемыми (поверхностно).
	2. `as const` фиксирует литеральные типы (строки/числа), делает объект/кортеж глубоко readonly на уровне вывода типов.
	3. Для глубокой иммутабельности в типах используют mapped types (например, `DeepReadonly`).
4. Что такое структурная типизация в TypeScript и чем она отличается от номинативной типизации?
	1. TypeScript — структурная типизация: совместимость по форме (совпадение набора свойств/сигнатур).
	2. Номинативная — по имени объявленного типа. В TS можно имитировать через «брендинг» (добавление уникального поля).

### Типизация в TypeScript

5. Когда уместнее использовать `type`, а когда `interface` в TypeScript? Приведите примеры?
	1. `type`: объединения/пересечения, условные/шаблонные типы, алиасы примитивов/кортежей.
	2. `interface`: описание форм объектов/классов; поддерживает `extends`, `implements` и декларативное слияние.
	3. `interface` может расширять `type`, если тот раскрывается в объектный тип (не союз/пересечение).
	4. Нельзя выразить union через `interface`; для этого используют `type`.
6. Что означает ключевое слово `implements` при объявлении класса в TypeScript?
	1. Класс обязан реализовать все свойства и методы интерфейса (совместимые типы и сигнатуры).
7. Что означает `extends` в контексте наследования и в ограничениях дженериков (`T extends U`)?
	1. Наследование классов/интерфейсов: добавляет/переопределяет члены.
	2. Ограничение дженериков: `T extends U` задаёт верхнюю грань для `T`.
8. Для чего используется `super` в классах TypeScript и когда вызывать `super()`?
	1. Доступ к членам базового класса и вызов конструктора `super()` в наследнике.
9. Как правильно типизировать асинхронные функции и значения `Promise` в TypeScript?
	1. `async function f(): Promise<R>` — всегда возвращает `Promise<R>`; `return` внутри превращается в `Promise.resolve`.
	2. Поддерживается `PromiseLike<T>`; ошибки не типизируются (исключения — структурно `unknown`).

### Работа с типами

10. Какая разница между объединением типов (`A | B`) и пересечением типов (`A & B`) в TypeScript?
	1. Union (`A | B`) — значение одного из вариантов; нужен narrowing для доступа к специфичным свойствам.
	2. Intersection (`A & B`) — требуется удовлетворить всем вариантам одновременно (пересечение свойств/контрактов).
11. Что такое условные типы (`Conditional Types`) в TypeScript и как они работают?
	1. Условные типы: `T extends U ? X : Y`.
	2. Дистрибутивность: `T` в «голом» виде распределяется по union. Чтобы отключить — обернуть: `[T] extends [U] ? X : Y`.
	3. Часто применяются с `infer` для извлечения частей типов.
12. Как устроены дженерики (обобщённые типы) в TypeScript и зачем они нужны?
	1. Обобщения параметризуют типы/функции/классы: `function id<T>(x: T): T`.
	2. Ограничения и значения по умолчанию: `T extends U = Default`.
	3. Важно располагать параметры по убыванию зависимости и задавать дефолты для удобства вызова.
13. Что делает ключевое слово `infer` в условных типах TypeScript? Приведите пример?
	1. Ключевое слово для вывода части типа в условных типах: `T extends Promise<infer R> ? R : T`.
	2. Поддерживает вариадические кортежи: `T extends [...infer H, infer L] ? ...`.
14. Что такое `asserts` в TypeScript и как им сужают типы (type narrowing)?
	1. Предикат: `asserts value is Type` — сужает тип при успешной проверке.
	2. Утверждение: `asserts condition` — сообщает компилятору, что условие истинно (используется для инвариантов/проверок).
15. Как вывести тип элемента массива или кортежа в TypeScript (например, `T[number]`)?
	1. `T[number]` для массива/кортежа; учитывает литеральные позиции в кортежах.

### Механизмы работы с типами

16. Как получить тип ключей (`keyof`) и тип значений (`T[keyof T]`) объекта в TypeScript?
	1. Ключи: `keyof T`.
	2. Ключи у значения: `keyof typeof obj`.
	3. Значения: `T[keyof T]`.
	4. Индексный доступ к конкретному свойству: `type Age = Person["age"]`.
	5. Замечание: индексные сигнатуры влияют на `keyof` (могут дать `string | number | symbol`).
17. Что такое вывод типов (Type Inference) в TypeScript и как он работает?
	1. Автоматический вывод типов: best common type, contextual typing (по месту использования), return type inference.
18. Какими способами TypeScript автоматически выводит типы (контекстный, по возвращаемому значению и т.д.)?
	1. По присваиваемому значению (включая литералы → литеральные типы, если не расширяются контекстом).
	2. По возвращаемому значению функций/методов (если тип не указан).
	3. По контексту (параметры колбэков, JSX, вызовы API) и анализу потока управления.
19. Что такое сужение типов (Type Narrowing) в TypeScript и для чего оно нужно?
	1. Сужение объединённых типов до более конкретного на основе проверок и анализа кода.
20. Какими способами TypeScript выполняет сужение типов: `typeof`, `in`, `instanceof`, дискриминант и пользовательские type guards?
	1. `typeof` — для примитивов (`typeof v === "string"`).
	2. Truthiness narrowing — проверка на truthy/falsy (`if (user) { ... }`).
	3. Equality narrowing — сравнение с литералами/`null`/`undefined`.
	4. Оператор `in` — наличие свойства в объекте.
	5. `instanceof` — проверка по прототипной цепочке.
	6. Discriminated unions — по общему дискриминатору в union.
	7. Пользовательские гарды: `function isA(x: unknown): x is A { ... }`.
21. Что такое утверждение типа (Type Assertion) в TypeScript и чем оно отличается от явных проверок?
	1. Явная подсказка компилятору о типе значения: `value as Type` (не меняет рантайм‑значение).
	2. Предпочитать гарды/проверки. Уголочные скобки `<Type>` недоступны в `.tsx` из‑за JSX.
	3. Для литеральных значений используйте `as const`.
22. Что такое отображаемые типы (Mapped Types) в TypeScript и как применять модификаторы `readonly` и `?`?
	1. Построение типа на основе другого: `{ [K in keyof T]: T[K] }`.
	2. Модификаторы: `+readonly/-readonly`, `+?/-?` для управления мутабельностью/обязательностью полей.
	3. Ремап ключей: `{ [K in keyof T as NewKey<K>]: ... }`.
23. Какие утилитные типы есть в TypeScript и для каких задач они используются?
	1. Ключевые: `Partial`, `Required`, `Readonly`, `Pick`, `Omit`, `Record`, `Exclude`, `Extract`, `NonNullable`, `ReturnType`, `InstanceType`, `Parameters`, `ConstructorParameters`, `ThisParameterType`, `OmitThisParameter`, `ThisType`, `Uppercase/Lowercase/Capitalize/Uncapitalize`.

### Современные концепции и расширения

24. Что такое вариадические кортежи (Variadic Tuple Types) в TypeScript и где они полезны?
	1. Кортежи переменной длины с распаковкой: `type T = [A, ...B[], C]`; `infer` поддерживает распаковку частей кортежа.
25. Что такое типы‑шаблоны строк (Template Literal Types) в TypeScript и как их сочетать с объединениями?
	1. Строковые шаблоны: можно комбинировать литералы и объединения (`"get-" | "set-"` + `"id" | "name"`).
	2. Модификаторы регистра: `Uppercase`, `Lowercase`, `Capitalize`, `Uncapitalize`.
26. Как объявлять перегрузки функций (Function Overloads) в TypeScript и как связана реализация с перегрузками?
	1. Несколько перегрузок (только сигнатуры) + одна реализация. Порядок — от более узких к более общим.
	2. Реализация должна покрывать все перегрузки; внутри — runtime‑проверки и сужения.
	3. альтернативой часто служат union‑аргументы и conditional types.
