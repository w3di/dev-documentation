### Основы и типы данных

1. Чем типы `any` и `unknown` отличаются в TypeScript и когда использовать каждый?
	- `any` отключает проверку типов и позволяет делать со значением что угодно (любой доступ, вызов, присваивание).
	- `unknown` безопаснее: требует сужения типа (type guard, проверка) или явного приведения перед использованием.
	- `any` «протекает» в другие типы и ломает проверку вниз по цепочке; `unknown` останавливает небезопасные операции на границе.

2. Чем различаются типы `void` и `never` в TypeScript, и где они применяются?
	- `void` — функция возвращает «ничего»; значение можно проигнорировать. `Promise<void>` значит «промис завершится без результата».
	- `never` — функция не завершается успешно: бросает ошибку или бесконечно работает. Полезно для исчерпывающих проверок (exhaustiveness).
	- `never` подтип любого типа; ни один тип не подтип `never` (кроме него самого).

3. В чём разница между модификатором `readonly` и утверждением `as const` в TypeScript?
	- `readonly` (в типах/классах/массиве `ReadonlyArray<T>`) делает свойства/элементы неизменяемыми (поверхностно).
	- `as const` фиксирует литеральные типы (строки/числа), делает объект/кортеж глубоко readonly на уровне вывода типов.
	- Для глубокой иммутабельности в типах используют mapped types (например, `DeepReadonly`).

4. Что такое структурная типизация в TypeScript и чем она отличается от номинативной типизации?
	- TypeScript — структурная типизация: совместимость по форме (совпадение набора свойств/сигнатур).
	- Номинативная — по имени объявленного типа. В TS можно имитировать через «брендинг» (добавление уникального поля).

### Типизация в TypeScript

5. Когда уместнее использовать `type`, а когда `interface` в TypeScript? Приведите примеры?
	- `type`: объединения/пересечения, условные/шаблонные типы, алиасы примитивов/кортежей.
	- `interface`: описание форм объектов/классов; поддерживает `extends`, `implements` и декларативное слияние.
	- `interface` может расширять `type`, если тот раскрывается в объектный тип (не союз/пересечение).
	- Нельзя выразить union через `interface`; для этого используют `type`.

6. Что означает ключевое слово `implements` при объявлении класса в TypeScript?
	- Класс обязан реализовать все свойства и методы интерфейса (совместимые типы и сигнатуры).

7. Что означает `extends` в контексте наследования и в ограничениях дженериков (`T extends U`)?
	- Наследование классов/интерфейсов: добавляет/переопределяет члены.
	- Ограничение дженериков: `T extends U` задаёт верхнюю грань для `T`.

8. Для чего используется `super` в классах TypeScript и когда вызывать `super()`?
	- Доступ к членам базового класса и вызов конструктора `super()` в наследнике.

9. Как правильно типизировать асинхронные функции и значения `Promise` в TypeScript?
	- `async function f(): Promise<R>` — всегда возвращает `Promise<R>`; `return` внутри превращается в `Promise.resolve`.
	- Поддерживается `PromiseLike<T>`; ошибки не типизируются (исключения — структурно `unknown`).

### Работа с типами

10. Какая разница между объединением типов (`A | B`) и пересечением типов (`A & B`) в TypeScript?
	- Union (`A | B`) — значение одного из вариантов; нужен narrowing для доступа к специфичным свойствам.
	- Intersection (`A & B`) — требуется удовлетворить всем вариантам одновременно (пересечение свойств/контрактов).

11. Что такое условные типы (`Conditional Types`) в TypeScript и как они работают?
	- Условные типы: `T extends U ? X : Y`.
	- Дистрибутивность: `T` в «голом» виде распределяется по union. Чтобы отключить — обернуть: `[T] extends [U] ? X : Y`.
	- Часто применяются с `infer` для извлечения частей типов.

12. Как устроены дженерики (обобщённые типы) в TypeScript и зачем они нужны?
	- Обобщения параметризуют типы/функции/классы: `function id<T>(x: T): T`.
	- Ограничения и значения по умолчанию: `T extends U = Default`.
	- Важно располагать параметры по убыванию зависимости и задавать дефолты для удобства вызова.

13. Что делает ключевое слово `infer` в условных типах TypeScript? Приведите пример?
	- Ключевое слово для вывода части типа в условных типах: `T extends Promise<infer R> ? R : T`.
	- Поддерживает вариадические кортежи: `T extends [...infer H, infer L] ? ...`.

14. Что такое `asserts` в TypeScript и как им сужают типы (type narrowing)?
	- Предикат: `asserts value is Type` — сужает тип при успешной проверке.
	- Утверждение: `asserts condition` — сообщает компилятору, что условие истинно (используется для инвариантов/проверок).

15. Как вывести тип элемента массива или кортежа в TypeScript (например, `T[number]`)?
	- `T[number]` для массива/кортежа; учитывает литеральные позиции в кортежах.

### Механизмы работы с типами

16. Как получить тип ключей (`keyof`) и тип значений (`T[keyof T]`) объекта в TypeScript?
	- Ключи: `keyof T`.
	- Ключи у значения: `keyof typeof obj`.
	- Значения: `T[keyof T]`.
	- Индексный доступ к конкретному свойству: `type Age = Person["age"]`.
	- Замечание: индексные сигнатуры влияют на `keyof` (могут дать `string | number | symbol`).

17. Что такое вывод типов (Type Inference) в TypeScript и как он работает?
	- Автоматический вывод типов: best common type, contextual typing (по месту использования), return type inference.

18. Какими способами TypeScript автоматически выводит типы (контекстный, по возвращаемому значению и т.д.)?
	- По присваиваемому значению (включая литералы → литеральные типы, если не расширяются контекстом).
	- По возвращаемому значению функций/методов (если тип не указан).
	- По контексту (параметры колбэков, JSX, вызовы API) и анализу потока управления.

19. Что такое сужение типов (Type Narrowing) в TypeScript и для чего оно нужно?
	- Сужение объединённых типов до более конкретного на основе проверок и анализа кода.

20. Какими способами TypeScript выполняет сужение типов: `typeof`, `in`, `instanceof`, дискриминант и пользовательские type guards?
	- `typeof` — для примитивов (`typeof v === "string"`).
	- Truthiness narrowing — проверка на truthy/falsy (`if (user) { ... }`).
	- Equality narrowing — сравнение с литералами/`null`/`undefined`.
	- Оператор `in` — наличие свойства в объекте.
	- `instanceof` — проверка по прототипной цепочке.
	- Discriminated unions — по общему дискриминатору в union.
	- Пользовательские гарды: `function isA(x: unknown): x is A { ... }`.

21. Что такое утверждение типа (Type Assertion) в TypeScript и чем оно отличается от явных проверок?
	- Явная подсказка компилятору о типе значения: `value as Type` (не меняет рантайм‑значение).
	- Предпочитать гарды/проверки. Уголочные скобки `<Type>` недоступны в `.tsx` из‑за JSX.
	- Для литеральных значений используйте `as const`.

22. Что такое отображаемые типы (Mapped Types) в TypeScript и как применять модификаторы `readonly` и `?`?
	- Построение типа на основе другого: `{ [K in keyof T]: T[K] }`.
	- Модификаторы: `+readonly/-readonly`, `+?/-?` для управления мутабельностью/обязательностью полей.
	- Ремап ключей: `{ [K in keyof T as NewKey<K>]: ... }`.

23. Какие утилитные типы есть в TypeScript и для каких задач они используются?
	- Ключевые: `Partial`, `Required`, `Readonly`, `Pick`, `Omit`, `Record`, `Exclude`, `Extract`, `NonNullable`, `ReturnType`, `InstanceType`, `Parameters`, `ConstructorParameters`, `ThisParameterType`, `OmitThisParameter`, `ThisType`, `Uppercase/Lowercase/Capitalize/Uncapitalize`.

### Современные концепции и расширения

24. Что такое вариадические кортежи (Variadic Tuple Types) в TypeScript и где они полезны?
	- Кортежи переменной длины с распаковкой: `type T = [A, ...B[], C]`; `infer` поддерживает распаковку частей кортежа.

25. Что такое типы‑шаблоны строк (Template Literal Types) в TypeScript и как их сочетать с объединениями?
	- Строковые шаблоны: можно комбинировать литералы и объединения (`"get-" | "set-"` + `"id" | "name"`).
	- Модификаторы регистра: `Uppercase`, `Lowercase`, `Capitalize`, `Uncapitalize`.

26. Как объявлять перегрузки функций (Function Overloads) в TypeScript и как связана реализация с перегрузками?
	- Несколько перегрузок (только сигнатуры) + одна реализация. Порядок — от более узких к более общим.
	- Реализация должна покрывать все перегрузки; внутри — runtime‑проверки и сужения.
	- альтернативой часто служат union‑аргументы и conditional types.