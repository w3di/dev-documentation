В DOM существует несколько способов добавления и удаления обработчиков событий. Они различаются по возможностям и сценариям использования. Вот основные способы:

### 1. Использование атрибутов HTML

Обработчик события можно задать прямо в HTML через атрибуты событий (например, `onclick`, `onchange`, и т.д.).

```js
<button onclick="alert('Button clicked!')">Click me</button>
```
### 2. Прямое присваивание через свойства DOM-элемента

Можно назначить функцию в качестве обработчика события через свойство элемента.
#### Добавление:

```js
const button = document.querySelector('button');
button.onclick = function() {
    alert('Button clicked!');
};
```

#### Удаление:

```js
button.onclick = null;
```

**Особенности:**

- При таком способе можно назначить только один обработчик на одно событие. Назначение нового обработчика перезапишет старый.

### 3. Использование `addEventListener()` и `removeEventListener()`

Этот способ позволяет добавлять несколько обработчиков на одно событие и дает больше контроля.

#### Добавление:

```js
const button = document.querySelector('button');
function handleClick() {
    alert('Button clicked!');
}
button.addEventListener('click', handleClick);
```
#### Удаление:

```js
button.removeEventListener('click', handleClick);
```

**Особенности:**

- Позволяет добавлять несколько обработчиков на одно событие.
- Функция для удаления обработчика должна быть той же самой, что и для его добавления.
- Поддерживает опции, такие как `once`, `capture`, и `passive`.

**Опции для `addEventListener`:**

- **`once: true`** – обработчик выполнится только один раз, после чего удалится автоматически:

```js
button.addEventListener('click', handleClick, { once: true });
```
    
- **`capture: true`** – обработчик будет срабатывать на этапе захвата, а не всплытия:

```js
button.addEventListener('click', handleClick, { capture: true });
```
  
- **`passive: true`** – обработчик не будет вызывать `preventDefault()`, что улучшает производительность при работе с прокруткой:

```js
button.addEventListener('scroll', handleScroll, { passive: true });
```

### 4. Использование методов DOM0 (`on*` свойства) и DOM2 (`addEventListener`)

DOM0 (например, `onclick`) ограничен одним обработчиком на событие, тогда как DOM2 (`addEventListener`) позволяет использовать несколько обработчиков и более гибкие настройки.

### 5. Делегирование событий

Делегирование позволяет назначать обработчики событий на родительский элемент и обрабатывать события дочерних элементов. Это особенно полезно для динамически добавляемых элементов.

```js
document.querySelector('#parent').addEventListener('click', function(event) {
    if (event.target.tagName === 'BUTTON') {
        alert('Button clicked!');
    }
});
```

### 6. Удаление обработчиков событий для анонимных функций

Удаление анонимных функций невозможно напрямую, так как у них нет ссылки.

#### Пример (не будет работать):

```js
button.addEventListener('click', function() {
    alert('Button clicked!');
});
button.removeEventListener('click', function() {
    alert('Button clicked!');
}); // Не сработает, так как функции разные.
```

Для успешного удаления обработчика нужно использовать именованную функцию или сохранять ссылку на анонимную функцию в переменной.

### 7. **Объект `EventHandler`**

Иногда в старых браузерах (например, Internet Explorer) использовались специфические методы для работы с событиями через объекты, такие как `attachEvent()` и `detachEvent()`.

```js
button.attachEvent('onclick', handleClick); // Для старых IE
button.detachEvent('onclick', handleClick);
```

**Примечание:** Эти методы устарели и не поддерживаются в современных браузерах. Вместо них следует использовать `addEventListener()` и `removeEventListener()`.


### 8. **Кастомные события**

В дополнение к встроенным событиям браузера, можно создавать свои собственные события с помощью конструктора `CustomEvent` и управлять ими.

```js
const customEvent = new CustomEvent('myEvent', {
    detail: { message: 'Hello from custom event!' }
});

button.addEventListener('myEvent', event => {
    console.log(event.detail.message);
});

button.dispatchEvent(customEvent);
```

### 9. **Объект `AbortController` для удаления обработчиков**

Новое API, которое позволяет удалять обработчики событий с помощью контроллера. Это полезно для очистки ресурсов.

```js
const controller = new AbortController();
const signal = controller.signal;

button.addEventListener('click', () => {
    console.log('Clicked!');
}, { signal });

controller.abort(); // Удаляет все события, связанные с этим сигналом.

```