
#### default.js

1. Что такое `default.js` и зачем он нужен в `Parallel Routes`?
	- `default.js` — это файл, который рендерится как `fallback` для слота, когда Next.js не может восстановить его активное состояние после жёсткой навигации (`full-page load`). Он нужен, чтобы слоты, не совпадающие с текущим URL, не показывали 404, а отображали заглушку

2. В каких случаях Next.js использует `default.js`?
	- При `hard navigation` (`F5` или прямой переход по ссылке)
	- Когда активное состояние слота не может быть восстановлено из URL
	- Для subpages, которые не совпадают с текущим URL

3. Чем отличается поведение слотов при `soft navigation` и `hard navigation`?
	- Soft navigation: Next.js отслеживает состояние каждого слота и рендерит его как есть
	- Hard navigation: Next.js не знает активное состояние слотов, поэтому для слотов без совпадения с URL рендерится `default.js` (или 404, если `default.js` нет)

4. Что произойдёт, если слот не имеет `default.js` и Next.js не может восстановить его состояние?
	- В таком случае Next.js рендерит 404 внутри этого слота

5. Почему нужно создавать `default.js` для implicit slot children?

#### Dynamic Segments

6. Что такое `Dynamic Route Segment` и как он создаётся?
    - Dynamic Segment используется, когда имена сегментов маршрута заранее неизвестны и определяются динамически. Создаётся с помощью квадратных скобок:

7. Как передаются dynamic `params` в компонент?
    - В `Server Components` они приходят через проп `params` (как promise).
    - В `Client Components` можно:
        - использовать `use`(`params`) для получения значения;
        - использовать хук `useParams`() в любом месте дерева клиента.

8. Что такое Catch-all Segments?
    - Catch-all [...slug] захватывает все последующие части пути в `Dynamic Route Segment`

9. Чем отличаются Catch-all и Optional Catch-all?
    - [...slug] → требует хотя бы один сегмент.
    - [[...slug]] → может быть без сегмента (/shop тоже матчится).

10. Что делает `generateStaticParams`?
    - Функция `generateStaticParams` позволяет заранее (на этапе сборки) сгенерировать динамические маршруты.

#### error.js

11. Что такое `error.js` и зачем он нужен в Next.js?
    - это специальный файл, который позволяет обрабатывать неожиданные runtime-ошибки и показывать `fallback` UI вместо того, чтобы страница падала полностью. Он работает как React `Error Boundary`, оборачивая сегмент маршрута и его дочерние элементы.

12. Почему `error.js` должен быть Client Component?
    - Error Boundaries в React могут быть реализованы только в `Client Components`. Поэтому `error.js` всегда должен начинаться с '`use client`'

13. Как работает `error.js` внутри сегмента маршрута?
    - Каждый сегмент маршрута может иметь свой `error.js`.
    - Если в сегменте или его дочерних компонентах происходит ошибка, Next.js рендерит `error.js` вместо содержимого сегмента
    - Если нужно, ошибка может "проброситься" выше к родительскому `error.js`

14. Какие пропсы получает `error.js` и что они означают?
    - error — объект ошибки
        - В dev-режиме включает сообщение ошибки (для удобной отладки)
        - В продакшене ошибки из `Server Components` передаются как безопасный объект с `digest` (чтобы не утекли чувствительные данные).
        - Ошибки из `Client Components` показывают оригинальное сообщение
    - reset — функция, которая позволяет попробовать перерисовать сегмент:

15. Чем отличаются ошибки из `Client Components` и `Server Components` в том, как они передаются в `error.js`?
    - `Client Components` → передаётся оригинальное сообщение ошибки
    - `Server Components` → передаётся обезличенное сообщение + `digest`, чтобы исключить утечку приватных данных.

16. Что делает функция reset() в `error.js`?
    - Она инициирует повторный рендер сегмента маршрута.

#### global-`error.js`

17. Чем global.js отличается от global.jsx и что и когда нужно применять?
    - `error.js` → обрабатывает ошибки локально, внутри конкретного сегмента и его дочерних страниц.
    - global-`error.js`x → глобальный обработчик, заменяющий root layout или template при ошибке. Используется для критических ошибок, которые ломают всё приложение

18. Почему в global-error нужно определять свои <html> и <body>?
    - global-`error.js`x заменяет root layout, у него нет доступа к общим обёрткам (layout, template)

#### instrumentation.js

19. Что такое `instrumentation.js` и зачем он нужен в Next.js?
    - `instrumentation.js` — это специальный файл для интеграции серверных инструментов наблюдаемости (observability) в Next.js. Он позволяет подключать системы вроде `OpenTelemetry`, `Sentry` или кастомные логгеры для отслеживания производительности, логирования ошибок и отладки в продакшене.

20. Где должен находиться файл `instrumentation.js`|ts?
    - В корне проекта

21. Когда вызывается функция `register`() и что в ней обычно делают?
    - `register`() вызывается один раз при инициализации нового экземпляра сервера Next.js. Обычно внутри неё подключают и настраивают библиотеку наблюдаемости, например `OpenTelemetry` или кастомный логгер

22. Для чего используется `onRequestError` и какие параметры он принимает?
    - `onRequestError` вызывается, когда Next.js сервер зафиксировал ошибку. Обычно его используют, чтобы отправить информацию об ошибках в сторонние сервисы
    - error — объект ошибки + `digest` (уникальный идентификатор ошибки).
    - request — данные запроса (path, method, `headers`).
    - context — контекст ошибки (тип роутера, сегмент, где упало: render, route, action, middleware).

23. Что такое `digest` у ошибки в `onRequestError`?
    - `digest` — уникальный хэш ошибки, который помогает связать ошибку в клиенте с соответствующими логами на сервере

24. Как можно разделить реализацию `register` и `onRequestError` для `Node.js` и `Edge` рантаймов?
    - Через process.env.`NEXT_RUNTIME`

#### instrumentation-client.js

25. Что такое `instrumentation-client.js` и для чего он используется?
    - `instrumentation-client.js`|ts — это файл для добавления клиентских инструментов наблюдаемости таких как аналитики, трекинга производительности, отслеживания ошибок, полифиллов и других side-effects, которые должны работать до того, как React станет интерактивным

26. Где должен находиться файл `instrumentation-client.js`|ts?
    - в корне приложения

27. В какой момент жизненного цикла приложения выполняется код из `instrumentation-client.js`?
    - после загрузки HTML но до гидратации React и возможности взаимодействия пользователя

28. Для чего используется `onRouterTransitionStart` и какие параметры она получает?
    - Функция вызывается при начале навигации внутри приложения
    - url: string — URL, на который происходит переход.
    - avigationType: 'push' | 'replace' | 'traverse' — тип навигации

#### Intercepting Routes

29. Что такое `Intercepting Routes` и для чего они используются?
    - `Intercepting Routes` позволяют загружать маршрут из другой части приложения в текущем layout. Это полезно, когда нужно показать контент без переключения основного контекста страницы

30. В чём разница между `soft navigation` и `hard navigation` при использовании `Intercepting Routes`?
    - Soft navigation — при клиентской навигации (например, клик по фото в ленте) маршрут перехватывается, URL маскируется, и фото показывается в модальном окне.
    - Hard navigation — при обновлении страницы или переходе по прямой ссылке весь маршрут рендерится как полноценная страница без перехвата.

31. Как работает (.), (..), (..)(..), и (...) при определении перехватываемых маршрутов?
    - (.) — перехватывает сегменты на том же уровне.
    - (..) — перехватывает сегменты на один уровень выше.
    - (..)(..) — на два уровня выше.
    - (...) — перехватывает сегменты начиная с корня app

32. Почему ( .. ) работает по сегментам маршрута, а не по файловой системе?
    - Потому что Next.js ориентируется на сегменты маршрутов, а не на структуру папок. Например, @slot в `Parallel Routes` не считается сегментом, поэтому относительность определяется только по route segments

#### layout.js

33. Что такое `layout.js` и для чего он используется в Next.js?
    - Layout — компонент, определяющий структуру интерфейса сегмента маршрута. Оборачивает дочерние сегменты и переиспользует общий UI 

34. Что такое root layout и чем он отличается от обычного layout?
    - Root layout — верхний layout в app/. Обязан содержать <html> и <body>, задаёт глобальный UI для всего приложения. Вложенные layouts применяются к своим сегментам.

35. Какие пропсы получает layout и как их использовать?
    - children — обязательный, содержит дочерние сегменты.
    - `params` — опциональный промис с динамическими параметрами от корневого сегмента до текущего layout.

36. Как использовать `LayoutProps` для типизации layout?
    - `LayoutProps` предоставляет типы для children, `params` и именованных слотов (@slot) на основе структуры директорий.

37. Могут ли layouts перерендериваться при навигации и почему?
    - Нет. Layouts сохраняются между переходами, чтобы избегать лишних запросов и вычислений; кэшируются на клиенте.

38. Как layout может работать с данными?
    - Может выполнять `fetch` и отображать данные внутри себя. Непосредственно передавать данные дочерним страницам нельзя. Запросы дочерних страниц дедуплицируются.

39. Как layout работает с query `params` и pathname?
    - Layouts не обновляются на навигации и не получают новые query `params` или pathname напрямую.
    - Для работы используют `use`SearchParams и `use`Pathname в `Client Components`.
    - Актуальное состояние обеспечивают дочерние страницы или клиентские компоненты внутри layout.

40. Как layout может взаимодействовать с дочерними сегментами?
    - Прямого доступа нет. Для определения активного сегмента используют `use`SelectedLayoutSegment или `use`SelectedLayoutSegments в `Client Components`.

41. Может ли layout быть клиентским (`CSR`)?
    - Root layout — нет; должен быть серверным и содержать <html> и <body>.
    - Вложенные layouts — да; можно сделать клиентскими с '`use client`'.
    - Ограничения клиентского layout: нет доступа к `headers`()/`cookies`()/`draftMode`(), нельзя делать серверный `fetch`, увеличивается размер бандла и время гидратации.

#### loading.js

42. Что такое `loading.js` и для чего он используется в Next.js?
    - `loading.js` — это специальный файл, который позволяет создавать понятный Loading UI с использованием React `Suspense`. Он показывает мгновенное состояние загрузки (`instant loading state`) с сервера, пока контент сегмента маршрута подгружается, и автоматически заменяет его на основной контент после завершения загрузки.

43. Где нужно размещать файл `loading.js` внутри маршрута?
    - Файл `loading.js` размещается в папке сегмента маршрута, внутри которого вы хотите показать состояние загрузки

44. Какой тип компонента по умолчанию имеет `loading.js` и можно ли его сделать Client Component?
    - По умолчанию `loading.js` является Server Component, но его можно сделать Client Component, добавив директиву '`use client`' в начале файла

45. Какие параметры принимает компонент `loading.js`?
    - Компонент `loading.js` не принимает никаких параметров

46. Что такое `instant loading state` и как его использовать?
    - Instant loading state — это UI, который показывается мгновенно при навигации, например скелетоны, спиннеры или небольшая часть будущего экрана. Он помогает пользователю понять, что приложение отвечает, и улучшает UX. Для этого создается `loading.js` с легковесным интерфейсом загрузки внутри соответствующего сегмента

47. Как `loading.js` взаимодействует с `layout.js` и `page.js` внутри сегмента маршрута?
    - `loading.js` автоматически оборачивает `page.js` и всех его потомков внутри <`Suspense`> границы, если находится в одной папке с `layout.js`. То есть при загрузке нового сегмента UI `fallback` из `loading.js` показывается до полного рендеринга страницы

48. Можно ли использовать `loading.js` при статическом экспорте сайта?
    - Нет, `loading.js` не поддерживается при статическом экспорте

49. Как вручную создавать `Suspense` Boundaries для своих компонентов и как это соотносится с `loading.js`?
    - Можно вручную обернуть любой асинхронный компонент в <`Suspense` `fallback`={...}>. В этом случае `fallback` UI работает аналогично `loading.js`, показывая UI пока выполняется асинхронное действие

50. Какие преимущества дает использование `Suspense` вместе с `loading.js`?
    - `Streaming Server Rendering` — прогрессивный рендеринг HTML с сервера на клиент
    - `Selective Hydration` — React делает интерактивными компоненты приоритетно, в зависимости от взаимодействия пользовател
    - Автоматическое отображение `fallback` UI и плавная замена его на основной контент

#### not-found.js

51. Для чего используется файл `not-found.js` в Next.js?
    - Он рендерит UI, когда внутри сегмента маршрута вызывается `notFound`(). Используется для обработки 404 на уровне конкретного сегмента.

52. Чем отличается `not-found.js` от global-`not-found.js`?
    - `not-found.js` работает в пределах сегмента и зависит от маршрута.
    - global-`not-found.js` используется для глобальной 404-страницы, если URL вообще не совпал ни с одним маршрутом.

53. Какой статус код возвращает Next.js при использовании `not-found.js`?
    - Для стриминговых ответов → 200.
    - Для нестриминговых → 404.

54. В каких случаях стоит использовать global-`not-found.js`?
    - Когда в приложении есть несколько root layout'ов.
    - Когда root layout определён с динамическими сегментами (например, app/[country]/`layout.js`).

55. Почему global-`not-found.js` должен возвращать полный HTML-документ?
    - Потому что он обходит обычный процесс рендеринга приложения, и Next.js ожидает полный HTML (с <html> и <body>).

56. Какие props принимают компоненты `not-found.js` и global-`not-found.js`?
    - Они не принимают никаких props

57. Можно ли в `not-found.js` выполнять серверный `fetch`?
    - Да, он является серверным компонентом и может быть `async`. Можно, например, использовать `headers`() и загружать данные для отображения кастомного 404-UI

58. Какие метаданные автоматически добавляет Next.js для страниц с 404?
    - Автоматически вставляется <`meta` name="`robots`" content="`noindex`" />, чтобы такие страницы не индексировались поисковиками.

#### page.js

59. Для чего используется файл `page.js` в Next.js?
    - Файл `page.js` используется для определения UI, уникального для маршрута. Это конечная точка (leaf) дерева маршрутов, которая делает сегмент публично доступным.

60. Является ли `page.js` обязательным для того, чтобы сегмент маршрута был публично доступен?
    - Да, без `page.js` сегмент маршрута не будет доступен пользователю напрямую.

61. Что означает, что страница всегда является листом (leaf) дерева маршрутов?
    - Это значит, что страница (`page.js`) всегда находится на нижнем уровне маршрута — она не может иметь вложенных сегментов под собой Вложенные сегменты должны определяться выше.

62. Какой компонент по умолчанию является `page.js` — серверным или клиентским? Можно ли его изменить?
    - По умолчанию `page.js` — Server Component, но его можно сделать Client Component, добавив директиву "`use client`" в начале файла.

63. Какие расширения файлов поддерживает Next.js для страниц?
    - Поддерживаются расширения: .js || .jsx || .tsx

64. Какие props доступны в `page.js` и для чего они нужны?
    - `params` — объект (`Promise`), содержащий динамические параметры маршрута ([slug], [id] и т.п.).
    - `searchParams` — объект (`Promise`), содержащий параметры строки запроса (?a=1&b=2).

65. В какой форме передаются `params` и `searchParams` в Next.js 15 и как они отличаются от версии 14?
    - В Next.js 15: `params` и `searchParams` передаются как `Promise`, их нужно обрабатывать через `await` или React `use`, В Next.js 14 и ниже: они были синхронными объектами

66. Как получить значения из `params` и `searchParams` в серверном компоненте?
    - Использовать `async`/`await`:

67. Как получить значения из `params` и `searchParams` в клиентском компоненте, где нельзя использовать `async`?
    - В клиентском компоненте можно использовать React-хук `use` для чтения `Promise`

68. Что происходит при использовании `searchParams` в странице относительно рендера (статический или динамический)?
    - Использование `searchParams` переводит страницу в динамический рендеринг на уровне запроса, так как их значения нельзя предсказать заранее.

69. Чем отличается `searchParams` от стандартного объекта `URLSearchParams`?
    - `searchParams` — это обычный JS-объект ({ a: '1', b: '2' }), а не экземпляр `URLSearchParams`.
    - Значения могут быть строкой или массивом строк (string | string[]).

70. Что такое `PageProps` helper и зачем его использовать?
    - `PageProps` — это глобально доступный TypeScript-хелпер, который позволяет типизировать `params` и `searchParams` на основе буквального маршрута, добавляет автодополнение ключей и строгую типизацию, автоматически генерируется при next dev, next build или next typegen.

#### Parallel Routes

71. Для чего нужны `Parallel Routes`?
    - Они позволяют одновременно или условно рендерить несколько страниц в одном layout. Это особенно полезно для динамических разделов, например, дашбордов или соцсетевых лент.

72. Что такое слоты и как они создаются?
    - Слоты — это именованные области внутри layout, создаваемые через папки с префиксом @. Например, @analytics или @team. Они передаются как пропсы в общий layout.

73. Влияют ли слоты на URL?
    - Нет. Слоты не формируют часть маршрута. Например, app/@analytics/views будет доступен по адресу /views.

74. Что такое implicit slot (children)?
    - children — это встроенный слот, который всегда присутствует. Файл app/`page.js` эквивалентен app/@children/`page.js`.

75. Для чего используется `default.js`?
    - `default.js` задаёт контент по умолчанию для слота, если при загрузке страницы или обновлении браузера Next.js не может восстановить активное состояние слота. Если файла нет — будет показан 404.

76. Soft navigation vs Hard navigation
    - Soft navigation (клиентская навигация) сохраняет состояние всех слотов, меняя только активный.
    - Hard navigation (перезагрузка страницы) сбрасывает состояние, и для неподходящих слотов рендерится `default.js` или 404.

77. Зачем нужен parallelRoutesKey в `use`SelectedLayoutSegment(s)?
    - Он позволяет определить активный сегмент маршрута внутри конкретного слота. Например, чтобы узнать, открыт ли /login в @auth.

78. Как использовать `Parallel Routes` для условного рендера?
    - Можно отобразить разные слоты в зависимости от условий (например, роли пользователя: `use`r или admin).

79. Что такое Tab Groups?
    - Это слоты с собственным layout, который позволяет пользователю переключаться между вложенными страницами, как между вкладками.

80. Как `Parallel Routes` помогают реализовать модальные окна?
    - Они позволяют открыть модальное окно через слот и `Intercepting Routes`, сохранив корректный URL, deep linking и восстановление состояния после обновления страницы.

81. Зачем нужен (.) в `Intercepting Routes`?
    - (.) указывает на перехват маршрута внутри слота (intercepting route), позволяя рендерить, например, модалку поверх текущей страницы.

82. Как закрывать модальное окно в `Parallel Routes`?
    - Через `router.back`(), через `Link` или подменяя слот компонентом, возвращающим null.

83. Когда нужен catch-all слот ([...catchAll])?
    - Когда нужно закрывать слот (например, модальное окно) при навигации на любые маршруты, которые не должны отображать его.

84. Можно ли определить отдельные loading и error состояния для каждого слота?
    - Да. Каждый слот может иметь собственные `loading.js` и `error.js`, которые обрабатываются независимо.

#### public Folder

85. Для чего используется папка `public` в Next.js?
    - Для хранения статических файлов, которые нужно отдать напрямую без обработки.

86. Как можно обратиться к файлу, находящемуся внутри `public`?
    - По пути, начиная с /. Например, `public`/avatars/me.png доступен по адресу /avatars/me.png.

87. Какой HTTP-заголовок кэширования применяется к файлам из `public` по умолчанию?
    - `Cache-Control`: `public`, max-age=0

88. Почему Next.js не кэширует файлы в `public` на длительное время?
    - Потому что содержимое файлов в `public` может изменяться, и Next.js не может безопасно гарантировать их долговременное кэширование.

89. Где рекомендуется хранить статические метаданные (`robots.txt`, `fav`icon`.ico` и т.п.) в новых проектах Next.js?
    - Внутри специальных `meta`data-файлов в папке app, а не в `public`

#### Route Groups

90. Что такое `Route Groups` в Next.js?
    - Это соглашение для организации маршрутов в папки, которые не влияют на URL.

91. Как создаётся группа маршрутов в файловой структуре?
    - Папку нужно обернуть в скобки, например: (shop) или (marketing).

92. Влияет ли название группы маршрутов (в скобках) на конечный URL?
    - Нет, оно используется только для организации структуры и не попадает в путь

93. Для чего обычно используют `Route Groups`?
    - для организации маршрутов по фичам или командам,
    - для создания нескольких root layouts,
    - разделить набор страниц по разным layout, не смешивая их

94. Можно ли с помощью `Route Groups` определить несколько root layout?
    - Да, каждая группа может иметь свой собственный root layout.

95. Что произойдёт при навигации между страницами, которые используют разные root layout?
    - Это приведёт к полной перезагрузке страницы (full page reload).

96. Какая проблема может возникнуть, если маршруты в разных группах разрешаются в один и тот же путь?
    - Возникнет конфликт: разные файлы будут пытаться отрендерить один и тот же URL, что вызовет ошибку.

97. Что нужно учитывать при использовании нескольких root layout и отсутствии общего top-level `layout.js`?
    - Нужно, чтобы маршрут / был определён хотя бы в одной из групп, например в app/(marketing)/`page.js`.
    
#### Route Segment Config

#### `src` Folder

98. Для чего используется папка `src` в Next.js и чем она удобна?
    - Папка `src` используется как альтернатива размещению специальных папок app или pages в корне проекта, она отделяет код приложения от конфигурационных файлов проекта, которые обычно находятся в корне.

99. Какие специальные папки можно перенести в `src`?
    - /`src`/app || `src`/pages и другие папки с кодом приложения

100. Можно ли использовать одновременно app или pages в корне и в `src`?
    - Нет, `src`/app или `src`/pages будут проигнорированы, если app или pages присутствуют в корневой директории так как Next.js приоритизирует папки в корне проекта над папками в `src`.

101. Где должна оставаться папка /`public`, если используется структура с `src`?
    - Папка /`public` должна оставаться в корне проекта.

102. Какие файлы должны оставаться в корне проекта при использовании `src`?
    - /`public` и конфигурационыне файлы

#### template.js

103. Что такое `template.js` и чем он отличается от `layout.js`?
    - `template.js` — это файл, похожий на `layout.js`, который оборачивает layout или page. В отличие от layouts, которые сохраняются между маршрутами и поддерживают состояние, templates получают уникальный ключ, что означает, что дочерние `Client Components` сбрасывают своё состояние при навигации.

104. Для чего используется `template.js`?
    - Для повторной синхронизации `use`Effect при навигации
    - Для сброса состояния дочерних `Client Components` при навигации (например, поля ввода)
    - Для изменения поведения фреймворка по умолчанию (например, `Suspense` boundaries в layouts показывают `fallback` только при первой загрузке, а в templates — при каждой навигации)

105. Какой порядок рендеринга у `template.js` в иерархии компонентов?
    - `template.js` рендерится между layout и его дочерними элементами
    - Структура: <Layout><Template key={routeParam}>{children}</Template></Layout>

106. Какие пропсы принимает `template.js`?
    - children (обязательный) — дочерние элементы

107. Какой тип компонента по умолчанию имеет `template.js`?
    - По умолчанию templates являются `Server Components`

108. Что происходит с `template.js` при навигации?
    - Templates получают уникальный ключ автоматически
    - Переход на новый маршрут вызывает перемонтирование template и его дочерних элементов

109. В чём основное отличие поведения `template.js` от `layout.js` при навигации?
    - Layouts сохраняются между маршрутами и поддерживают состояние
    - Templates перемонтируются при каждой навигации и сбрасывают состояние

110. Какие преимущества даёт использование `template.js` для сброса состояния?
    - Автоматический сброс состояния всех `Client Components` внутри template
    - Перезапуск `use`Effect при навигации
    - Полное пересоздание DOM элементов

111. Как `template.js` влияет на поведение `Suspense` boundaries?
    - `Suspense` boundaries внутри layouts показывают `fallback` только при первой загрузке
    - `Suspense` boundaries внутри templates показывают `fallback` при каждой навигации

112. Что означает "уникальный ключ" для `template.js`?
    - Next.js автоматически присваивает template уникальный ключ на основе параметров маршрута
    - Это заставляет React перемонтировать компонент при изменении ключа

113. Можно ли сделать `template.js` клиентским компонентом?
    - Да, можно добавить директиву '`use client`' в начало файла

114. Как `template.js` влияет на DOM элементы при навигации?
    - DOM элементы внутри template полностью пересоздаются при навигации

115. В каких случаях стоит использовать `template.js` вместо `layout.js`?
    - Когда нужно сбрасывать состояние форм при навигации
    - Когда нужно перезапускать `use`Effect при каждой навигации
    - Когда нужно изменить поведение `Suspense` boundaries

116. Что происходит с `use`Effect в `Client Components` внутри `template.js` при навигации?
    - `use`Effect перезапускается, так как компонент перемонтируется

117. Как `template.js` работает с `Server Components`?
    - По умолчанию `template.js` является Server Component
    - Может содержать `Server Components` внутри себя

118. Можно ли использовать `template.js` и `layout.js` одновременно в одном сегменте?
    - Да, `template.js` рендерится между layout и его дочерними элементами

119. Что происходит с состоянием формы в `template.js` при навигации?
    - Состояние формы полностью сбрасывается при навигации

120. Как `template.js` влияет на производительность приложения?
    - Может снижать производительность из-за постоянного перемонтирования компонентов
    - Увеличивает количество рендеров при навигации

121. Какие ограничения есть у `template.js` по сравнению с `layout.js`?
    - Постоянное перемонтирование может быть нежелательным для производительности
    - Не подходит для компонентов, которые должны сохранять состояние между навигациями

#### route.js

#### forbidden.js

#### mdx-components.js

#### middleware.js

#### unauthorized.js

#### Metadata Files
    ##### `favicon`, `icon`, and apple-`icon`
    ##### `manifest.json`
    ##### `opengraph-image` and `twitter-image`
    ##### `robots.txt`
    ##### `sitemap.xml`