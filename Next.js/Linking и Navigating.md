## Linking и Navigating (Навигация)

В Next.js маршруты по умолчанию рендерятся на сервере. Чтобы навигация оставалась быстрой и отзывчивой, фреймворк использует префетчинг, стриминг и клиентские переходы. Ниже — как это работает и как оптимизировать переходы, особенно для динамических маршрутов и медленных сетей.

---

## Как работает навигация

- **Server Rendering**: страницы и макеты — серверные компоненты по умолчанию. На первом заходе и при переходах сервер формирует Server Component Payload и отправляет клиенту. Бывает два режима:
  - **Статический рендер (Prerendering)** — на этапе сборки или при ревалидации, результат кэшируется.
  - **Динамический рендер** — на каждый запрос.
  Компромисс: клиент ждёт ответ сервера перед показом нового маршрута. Next.js сглаживает ожидание через префетчинг и клиентские переходы.

- **Prefetching (префетчинг)**: фоновая загрузка маршрутов до перехода.
- **Streaming (стриминг)**: по частям отправляет готовые части UI (layout, loading) без ожидания готовности всей страницы.
- **Клиентские переходы**: обновляют контент без полной перезагрузки страницы, сохраняя общий UI и состояние.

Полезно знать: для первичного визита также генерируется HTML.

---

## Prefetching

Префетчинг загружает маршрут в фоне ещё до клика, чтобы переход ощущался мгновенным. Next.js автоматически префетчит маршруты, связанные через компонент `<Link>`, когда ссылка попадает во вьюпорт.

Сколько префетчится:

- **Статический маршрут**: префетчится полностью.
- **Динамический маршрут**: может быть пропущен или частично префетчен, если есть `loading.tsx`.

Частичный префетч динамики экономит ресурсы сервера, но без стриминга переход может казаться «медленным» из‑за ожидания ответа. Помогает стриминг.

---

## Streaming

Стриминг позволяет серверу отдавать части динамического маршрута по мере готовности (например, общий layout и `loading`), не дожидаясь полной страницы. Пользователь видит UI раньше, даже если часть контента ещё грузится.

Для включения стриминга добавьте `loading.tsx` в папку маршрута:

Под капотом Next.js оборачивает содержимое `page.tsx` в `<Suspense>`. При префетче подгружается фолбэк, который будет показан сразу при переходе и заменён на контент, как только он готов.

Плюсы `loading.tsx`:

- Мгновенная навигация и визуальный отклик.
- Общие макеты остаются интерактивными, переходы прерываемые.
- Улучшение Core Web Vitals: TTFB, FCP, TTI.

---

## Клиентские переходы

Обычно переход на серверно‑рендеренную страницу вызывает полную перезагрузку, сбрасывая состояние и скролл. В Next.js `<Link>` делает клиентский переход: общий UI сохраняется, текущая страница заменяется на префетченный `loading` или готовую страницу.

В связке с префетчем и стримингом это даёт быстрые переходы даже для динамических маршрутов.

---

## Что замедляет переходы и как улучшить

### 1) Динамические маршруты без `loading.tsx`

Клиент ждёт ответ сервера, создаётся ощущение «зависания». Решение: добавьте `loading.tsx` для частичного префетча и мгновенной навигации.

### 2) Динамические сегменты без `generateStaticParams`

Если сегмент можно пререндерить, но нет `generateStaticParams`, будет динамический рендер на запрос. Добавьте `generateStaticParams`:

### 3) Медленные сети

На медленной/нестабильной сети префетч может не успеть. В этом случае `loading` может не появиться мгновенно. Покажите «инлайновый» индикатор состояния ссылки через `useLinkStatus`:

---

## Отключение префетчинга

Чтобы отказаться от префетча, передайте `prefetch={false}` в `<Link>` — полезно, например, в бесконечных списках:

Компромиссы:

- Статика загрузится только по клику.
- Динамика потребует серверного рендера до навигации.

Вместо полного отключения можно префетчить только по ховеру

---

## Гидратация не завершена

`<Link>` — клиентский компонент и должен пройти гидратацию, прежде чем начнёт префетчить. Большие бандлы могут задерживать гидратацию. Смягчается селективной гидратацией React. Дополнительно улучшите:

- Используйте `@next/bundle-analyzer` для поиска и сокращения крупных зависимостей.
- Переносите логику на сервер, где это возможно (см. Server vs Client Components).

---

## Примеры: нативный History API

Next.js позволяет использовать `window.history.pushState` и `window.history.replaceState` без перезагрузки страницы. Эти вызовы интегрируются с роутером Next.js и синхронизируются с `usePathname` и `useSearchParams`.

### `window.history.pushState`

Добавляет новую запись в историю — пользователь может вернуться назад. Пример сортировки списка товаров:


### `window.history.replaceState`

Заменяет текущую запись — пользователь не сможет вернуться назад к предыдущему состоянию. Пример переключения локали:



