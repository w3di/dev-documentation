## Server и Client Components

По умолчанию макеты и страницы в Next.js — это Server Components: вы можете получать данные на сервере, рендерить UI, кэшировать результат и стримить его на клиент. Для интерактивности и работы с браузерными API используйте Client Components.

---

## Когда что использовать

Используйте **Client Components**, когда нужны:

- Состояние и обработчики событий (`onClick`, `onChange`).
- Жизненный цикл (`useEffect`).
- Только клиентские API (`localStorage`, `window`, `Navigator.geolocation`, и т. п.).
- Пользовательские клиентские хуки.

Используйте **Server Components**, когда нужно:

- Получать данные из БД или API «близко к источнику».
- Прятать ключи/токены (не отдавать клиенту).
- Сократить объём JS, отправляемого в браузер.
- Улучшить FCP и стримить контент постепенно.

---

## Как это работает в Next.js

### На сервере

- Server Components рендерятся в специальный формат данных — **RSC Payload** (React Server Component Payload).
- На базе RSC и клиентских компонентов пререндерится HTML.

Что такое RSC Payload?

- Компактное бинарное представление дерева Server Components.
- Содержит: результат рендера серверных компонентов, «заглушки» и ссылки на JS клиентских компонентов, а также пропсы, переданные из серверных в клиентские.

### На клиенте (первый заход)

- HTML сразу показывает быстрый «неинтерактивный» предварительный просмотр.
- RSC Payload используется для согласования (reconcile) деревьев Server/Client компонентов.
- JS гидратирует клиентские компоненты, делая приложение интерактивным.

Что такое гидратация?

- Процесс «прикрепления» обработчиков событий к уже отрендеренному HTML.

### Последующие навигации

- RSC Payload префетчится и кэшируется для мгновенных переходов.
- Клиентские компоненты рендерятся полностью на клиенте (без серверного HTML), при этом общий layout сохраняется.

---

## Создание Client Components

Добавьте директиву на первой строке файла: `"use client"` — это создаёт границу между серверным и клиентским графами модулей.


Важно: если файл помечен `"use client"`, его импорты и дочерние компоненты попадают в клиентский бандл. Не помечайте «большие» участки UI клиентскими без необходимости — выделяйте только интерактивные компоненты.

---

## Передача данных из Server в Client через пропсы

Серверные компоненты могут передавать данные клиентским через пропсы (данные должны быть сериализуемыми React).

Альтернатива: потоковая передача данных в клиентский компонент через хук `use` в серверном компоненте 

---

## Переплетение Server и Client компонентов

Можно передавать серверные компоненты как `children` в клиентский компонент (паттерн «слоты»).

Server Components будут отрендерены на сервере заранее, а RSC Payload укажет места в дереве, где нужно вставить клиентские компоненты.

---

## Провайдеры контекста

React‑контекст в Server Components не поддерживается. Оберните провайдер в клиентский компонент и используйте его в серверном макете/странице:

Совет: рендерьте провайдеры как можно глубже (оборачиваем только `{children}`, а не весь `<html>`), это помогает Next.js лучше оптимизировать статические части Server Components.

---

## Сторонние компоненты

Если сторонний компонент опирается на клиентские возможности, используйте его внутри клиентского компонента или оберните его в свой `"use client"`‑файл.

---

## Предотвращение «отравления окружения» (environment poisoning)

Модули могут шариться между серверными и клиентскими графами. Можно случайно импортировать «сервер‑только» код на клиент. Например, функция, использующая секреты окружения:

Переменные окружения без префикса `NEXT_PUBLIC_` не попадают в клиентский бандл (на клиенте будут пустыми строками). Код формально импортируем, но он работать не будет и может раскрыть намерения.

Чтобы запретить использование на клиенте — пометьте модуль пакетом `server-only`:

Если такой модуль импортировать в Client Component — будет ошибка на этапе сборки.

Симметрично существует `client-only` — чтобы помечать модули с клиентской логикой (например, обращение к `window`).


Next.js предоставляет собственные типы для `server-only`/`client-only`, в том числе для конфигураций TypeScript с `noUncheckedSideEffectImports`.

