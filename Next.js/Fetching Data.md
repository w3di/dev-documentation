## Fetching Data (Получение данных)

Эта страница объясняет, как получать данные в Server и Client Components, а также как стримить части UI, зависящие от данных.

---

## Общие принципы

- **Server Components** по умолчанию: рендер на сервере, кэширование, стриминг.
- **Client Components** — для интерактивности и браузерных API. Данные для них можно передавать с сервера или получать на клиенте.

---

## Получение данных в Server Components

Используйте один из подходов:

- **fetch API** — асинхронный компонент, `await fetch()` и парсинг ответа.
- **ORM / база данных** — прямой доступ к БД с безопасным хранением секретов (серверный рендер).

Полезно знать:

- Ответы `fetch` по умолчанию не кэшируются, но маршрут пререндерится и его HTML‑вывод будет кэширован Next.js. Для динамического рендера используйте `fetch(..., { cache: 'no-store' })` (см. API `fetch`).
- В разработке можно логировать `fetch`‑запросы (см. Logging API) для наглядности и дебага.

---

### Пример: fetch API (сервер)

Идея: сделать компонент `async`, выполнить `fetch`, распарсить `json` и отрендерить список.

---

### Пример: ORM / база данных (сервер)

Идея: в `async`‑компоненте выполнить запрос к БД (через ORM / клиент), вернуть данные, отрисовать.

---

## Получение данных в Client Components

Два пути:

- **Хук React `use`** для стриминга данных с сервера в клиент. На сервере запускается функция получения данных и возвращается промис, который передаётся как проп клиентскому компоненту. На клиенте `use(promise)` читает результат внутри `<Suspense>`.
- **Библиотеки сообщества**: SWR, React Query и т. п. — собственные семантики кэширования, стриминга и инвалидации.

Полезно знать:

- Оборачивайте клиентский компонент, читающий промис, в `<Suspense>`, чтобы показать фолбэк, пока данные загружаются.

---

### Пример: стриминг с хуком `use`

Идея: в серверном компоненте не `await`‑ить получение данных, а передать промис в клиентский компонент и прочитать его через `use()` внутри `<Suspense>`.

---

### Пример: SWR (клиент)

Идея: объявить `fetcher`, вызвать `useSWR(url, fetcher)`, отрендерить состояния `isLoading / error / data`.

---

## Дедупликация запросов и кэш данных

- **Request memoization**: в пределах одного рендер‑прохода одинаковые `fetch` (GET/HEAD, один URL и опции) объединяются в один запрос автоматически. Можно отключить, передав `AbortSignal` в `fetch`.
- **Data Cache** Next.js: можно принудительно кэшировать данные (например, `cache: 'force-cache'`) и шарить их между текущим рендером и входящими запросами.
- Если используете не `fetch` (ORM/БД), заверните доступ к данным в `React.cache`, чтобы кэшировать и переиспользовать результаты на сервере.

---

## Стриминг (Streaming)

Идея: разбить страницу на части и отправлять HTML порционно по мере готовности данных, чтобы ускорить первый рендер и улучшить UX.

Варианты включения:

- **`loading.tsx`** рядом с `page.tsx` — стримит целую страницу/сегмент. При навигации пользователь моментально видит layout и «loading‑состояние», новый контент подменяется автоматически, как только готов.
- **`<Suspense>`** — более тонкий контроль: можно сразу отрисовать всё вне границы `<Suspense>`, а внутри — постримить зависящие от данных части (например, списки).

Примечание: включение `async/await` в серверном компоненте переводит сегмент в динамический рендер. Стриминг позволяет не блокировать весь маршрут из‑за медленных запросов.

---

## Последовательная и параллельная загрузка

- **Последовательно**: вложенные компоненты по очереди делают запросы — общее время дольше. Смягчайте через `<Suspense>` и продуманные фолбэки.
- **Параллельно**: инициируйте запросы заранее и ждите их вместе. Внутри одного компонента вызывайте функции получения данных без `await`, затем используйте `await Promise.all([...])`.

Подсказка: при `Promise.all` отказ одного запроса провалит всю группу — используйте `Promise.allSettled`, если важно «частично успешное» поведение.

---

## Предзагрузка данных (Preload)

Можно «подогреть» данные до блокирующих операций:

- Создайте утилиту `preload(id)`, которая запускает получение данных «впустую» (через `void getItem(id)`), чтобы запрос начался раньше.
- Затем, когда компонент действительно отрисуется, данные уже будут в кэше/готовы.
- Для переиспользуемости и безопасности используйте `React.cache` и `server-only` в серверных утилитах.

---

## Рекомендации

- **Выбирайте сервер**, когда нужны безопасность, близость к данным, снижение клиентского JS и лучший FCP.
- **Выбирайте клиент**, когда нужна интерактивность, работа с `window`/`localStorage` и др. браузерные API.
- **Стримьте** медленные части через `loading.tsx` или `<Suspense>`.
- **Дедуплицируйте** запросы (request memoization, Data Cache, `React.cache`).
- **Параллелизируйте** независимые запросы и **предзагружайте** критичные.

---

## Полезно знать

- В некоторых версиях (напр., Next.js 15 canary) флаг `cacheComponents` может влиять на поведение кэширования/стриминга компонент.
- Гидратация клиентских компонентов должна завершиться до начала их активности; минимизируйте клиентский бандл и выносите логику на сервер, где возможно.


### Fetching Data — краткий конспект (теория)

- **Цель**: объяснить, где и как получать данные в Next.js (Server/Client Components), как включать стриминг, и как работать с кешированием и дедупликацией запросов.

### Server Components
- **Где получать данные**: напрямую на сервере — через `fetch`.
- **Асинхронность**: серверные компоненты могут быть асинхронными и ожидать результат запроса до возврата UI.
- **Кеш и рендер**:
  - Ответы `fetch` по умолчанию не кешируются, но маршрут пререндерится и его HTML может кэшироваться для производительности.
  - Для динамического рендеринга используйте опции запроса, отключающие кеш (например, режим без кеша) — это переведёт маршрут в рендер по запросу.
- **Диагностика**: в дев‑режиме доступны логи вызовов `fetch` для отладки.

### Client Components
- **Подходы**:
  - Через механизм React для чтения промисов из пропов в пределах границы загрузки — позволяет стримить данные с сервера в клиент.
  - Через библиотеки сообщества (например, SWR, React Query): предоставляют собственные политики кеша, повторных запросов, стриминга и статусов загрузки/ошибок.

### Стриминг данных (Streaming)
- **Назначение**: уменьшить время до первого значимого контента, разбив HTML на части и отправляя их по мере готовности.
- **Важное замечание**: предполагается включённая конфигурация кеширования компонентов (актуально в новых версиях Next.js).
- **Два способа включить стриминг**:
  - Через файл загрузки в сегменте маршрута: стримится весь сегмент/страница, пока данные получаютcя на сервере.
  - Через явные границы React загрузки в нужных местах для тонкого контроля — всё вне границы рендерится сразу, внутри — стримится по готовности.
- **UX‑совет**: проектируйте содержательные состояния загрузки (скелетоны, ключевые фрагменты будущего экрана), а не пустые плейсхолдеры.

### Дедупликация и кеш
- **Мемоизация запросов**: в пределах одного рендера одинаковые `GET/HEAD` (URL + опции) объединяются в один сетевой запрос автоматически; можно отключить с помощью сигнала отмены.
- **Область действия**: мемоизация действует в рамках жизни текущего запроса.
- **Data Cache**: позволяет шарить данные между текущим рендер‑проходом и последующими запросами; можно принудительно кэшировать.
- **Не через fetch**: если используете другой способ доступа к данным, оборачивайте функции доступа в React‑кеш, чтобы разделять результаты и избегать дублей вызовов.

### Последовательные vs параллельные запросы
- **Последовательные**: вложенные компоненты каждый ждут свои данные по очереди — может сильно удлинять время ответа.
- **Параллельные**: инициируйте несколько запросов заранее и ждите их совместно — каждое независимое получение данных стартует как можно раньше.
- **Выбор стратегии**: используйте последовательность только при строгой зависимости (второй запрос зависит от результата первого). В остальных случаях — инициируйте параллельно.

### Предзагрузка данных (Preloading)
- **Идея**: запускать нужные запросы заранее — до момента, когда компонент реально отрендерится.
- **Где полезно**: когда компонент условно рендерится (зависит от проверки), но его данные можно начать загружать раньше; к моменту фактического рендера данные уже в кеше.
- **Утилиты**: выносите функции предзагрузки рядом с функциями получения данных; комбинируйте с React‑кешем и ограничением на исполнение только на сервере.

### Практические рекомендации
- Старайтесь делать независимые запросы параллельно; последовательно — только при зависимостях.
- Для часто используемых данных подключайте кеш уровня приложения (Data Cache) и/или React‑кеш для функций доступа к данным.
- Для клиентских сценариев рассмотрите SWR/React Query: готовые стратегии повторов, инвалидации, фоновой синхронизации.
- Разбивайте страницы на осмысленные границы стриминга, проектируйте понятные состояния загрузки и ошибок.
- Не перегружайте клиент сложной логикой получения данных, если её можно выполнить на сервере (особенно персонализацию и доступ к приватным источникам).

---

### Что ещё важно (дополнил)

#### Динамические API и динамичность маршрута
- Использование рантайм‑API (cookies, headers, connection, draftMode, проп `searchParams`, явное отключение кеша запроса, некэшируемые `fetch`) переводит используемый участок в динамический рендеринг.
- При статическом пререндеринге это может вызвать ошибку сборки, если динамика не изолирована; изолируйте такие участки через границы загрузки.

#### Политики кеширования данных
- **Динамический рендер**: отключение кеша на запросах приводит к выполнению на каждый запрос пользователя.
- **Статический рендер**: при включенном кешировании результат маршрута может быть пререндерен и закеширован для всех пользователей.
- **Ревалидация и теги**: используйте интервал ревалидации и/или теги для инвалидации данных; позволяет обновлять кешируемые ответы без полного отказа от кеша.

#### Data Cache vs мемоизация запроса
- **Мемоизация запроса**: в пределах одного рендера одинаковые `GET/HEAD` (URL + опции) схлопываются в один сетевой вызов; область действия — текущий запрос/рендер.
- **Data Cache**: общий кеш данных поверх рендеров/запросов; позволяет делиться результатами между пользователями/запросами при тех же ключах и политике.
- **Opt‑out мемоизации**: можно отключить схлопывание, передав сигнал отмены в запрос (подсказка инфраструктуре о необходимости отдельного запроса).

#### Параллелизм сегментов и последовательность внутри компонента
- **Маршрутные сегменты** (layouts/pages) по умолчанию запускают свои загрузки **параллельно**.
- Внутри одного компонента два `await` подряд дадут **последовательное** выполнение. Для максимального выигрыша инициируйте независимые запросы раньше и ждите их совместно.
- Если одна загрузка зависит от результата другой, последовательность оправдана.

#### Стриминг: loading.js и границы загрузки
- **loading.js** в сегменте маршрута: стримит весь сегмент, показывая состояние загрузки, пока сервер собирает данные и рендерит.
- **Границы загрузки** (Suspense): дают более **гранулярный** контроль — всё вне границы приходит сразу, внутри границы поступает потоком по готовности.
- Проектируйте **содержательные** загрузочные состояния (скелетоны, ключевые фрагменты будущего экрана), а не пустые плейсхолдеры.

#### Передача промисов и чтение на клиенте
- Можно инициировать загрузку на сервере и передать **промис** в клиентский компонент; в границе загрузки клиент прочитает его и получит стриминг участка.
- Это снижает дублирование логики получения данных на клиенте и сохраняет преимущества серверного доступа к источникам.

#### Библиотеки сообщества для клиента
- **SWR/React Query**: решают кеширование, инвалидацию, повторы, фоновые обновления, статусы. Полезны для клиентских интеракций, где данные живут и меняются после первого рендеринга.
- Имейте в виду их собственные семантики кеша/стриминга и интеграцию с серверным рендерингом.

#### Последовательные и параллельные сценарии — нюансы
- Параллелизация уменьшает время ожидания «узкого места», но усложняет обработку частичных отказов.
- При совместном ожидании набора запросов учитывайте стратегию отказоустойчивости: обрабатывать ли каждый ответ независимо или падать целиком.
- Для чувствительных к SLA компонентов полезно проектировать независимые загрузочные «островки» с собственным состоянием ошибок и фолбэками.

#### Предзагрузка (preloading) утилитами
- Ранний запуск загрузки до блокирующих операций повышает шанс, что данные будут готовы к моменту реального рендера.
- Выделяйте утилиты предзагрузки рядом с функциями получения данных; комбинируйте с серверным‑только исполнением и React‑кешем.

#### Обработка ошибок и UX
- Думайте в терминах **частичных отказов**: один виджет может вернуться с ошибкой, остальные — успешно. Показывайте локальные состояния ошибок, не блокируя всю страницу.
- Заготовьте короткие, понятные сообщения/скелетоны вместо пустых экранов; важно поддерживать ощущение отзывчивости.

#### Практические советы
- Инициируйте **независимые** запросы как можно раньше; серию `await` используйте только при реальной зависимости.
- Кешируйте «дорогие» и часто используемые данные на уровне приложения, применяйте **теги/ревалидацию** для актуализации.
- Для персонализации и приватных источников предпочитайте **серверное** получение данных, а на клиент передавайте уже безопасные результаты.
- Изолируйте динамику и долгие запросы в отдельные **границы загрузки** для лучшего TTFB и стабильности восприятия.
- Следите за тем, чтобы стратегии кеша соответствовали требованиям к консистентности данных (не всё должно быть «no‑store» или «вечно в кеше»).
