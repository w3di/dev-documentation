какие существуют виды рендеринга в next.js?
    -SSG (Static Site Generation)
    -SSR (Server-Side Rendering)
    -CSR (Client-Side Rendering)
    -ISR (Incremental Static Regeneration)
    -PPR (Partial Prerendering)
    
Как происходит полный процесс отображения интерфейса при SSG от начало до конца?
    -Билд (сервер): выполняются серверные компоненты и функции generateStaticParams.
    -Билд (сервер): формируется HTML и RSC payload (данные для React Server Components), сохраняются в .next → деплой на CDN.
    -Запрос пользователя (сервер/CDN): отдаётся готовый HTML + JS-бандлы.
    -Загрузка в браузере (клиент): браузер получает HTML и бандлы.
    -Гидратация (клиент): React связывает HTML с интерактивными клиентскими компонентами; гидратируются только клиентские компоненты (серверные не гидратируются).
    -Все пользователи получают один и тот же статический результат до следующего билда.

Как происходит полный процесс отображения интерфейса при SSR от начало до конца?
    -Запрос пользователя (клиент): пользователь открывает страницу /page.
    -Запрос на сервер (сервер): сервер вызывает серверные компоненты, выполняет fetch с cache: "no-store" или revalidate: 0.
    -Рендеринг (сервер): React рендерит RSC дерево → формирует HTML-поток и RSC Flight payload.
    -Ответ пользователю (сервер → клиент): сервер отправляет HTML и RSC Flight payload клиенту (streaming по мере готовности).
    -Гидратация (клиент): React связывает HTML с интерактивными клиентскими компонентами; гидратируются только клиентские компоненты.
    -Повторяется при каждом запросе (сервер): новые данные пересоздаются на сервере.

Как происходит полный процесс отображения интерфейса при CSR от начало до конца?
    -Запрос пользователя (клиент): браузер запрашивает страницу.
    -Ответ сервера (сервер): сервер/CDN отдает минимальный HTML с корневым контейнером (<div id="root">) или server-rendered shell (в Next.js), и JS-бандл.
    -Загрузка JS (клиент): браузер загружает JS-бандлы.
    -Запрос данных (клиент): React выполняет fetch для динамических данных.
    -Отрисовка DOM (клиент): React строит DOM в браузере.
    -Переходы между страницами (клиент): роутинг выполняется на клиенте без участия сервера; `next/link` может префетчить ресурсы.

Как происходит полный процесс отображения интерфейса при ISR от начало до конца?
    -Билд (сервер): создаются статические HTML-файлы, как в SSG.
    -Запрос пользователя (сервер/CDN): отдаётся кешированная версия HTML.
    -Фоновая пересборка (сервер): если истекло время revalidate или пришёл on-demand revalidation (webhook/API), Next.js асинхронно генерирует новую страницу.
    -Пользователь получает старую версию (сервер/CDN → клиент): до завершения пересборки (stale-while-revalidate).
    -Замена на новую версию (сервер/CDN): после завершения пересборки.
    -Следующие запросы (сервер/CDN): пользователи получают обновленный HTML.
    -Гидратация (клиент): React связывает HTML с интерактивными компонентами.

Как происходит полный процесс отображения интерфейса при PPR от начало до конца?
    -Билд (сервер): предрендеринг статической части страницы (layout, header, footer).
    -Маркировка динамических частей (сервер): динамические компоненты остаются как placeholder.
    -Запрос пользователя (сервер/CDN → клиент): отдается HTML shell.
    -Фоновый рендеринг динамических частей (сервер): сервер рендерит динамические компоненты и отправляет поток HTML и RSC чанков (streaming).
    -Постепенная отрисовка (клиент): браузер вставляет динамические части по мере их получения.
    -Гидратация (клиент): React связывает DOM с интерактивностью клиентских компонентов внутри динамических частей (серверные компоненты не гидратируются).
    
Когда какой тип рендеринга использовать?
    -SSG: статические страницы с редкими изменениями, критичный SEO и быстрый TTFB (лендинги, блог, статичные разделы). Данные одинаковы для всех пользователей.
    -ISR: как SSG, но с периодическими обновлениями без полного билда (каталоги, страницы товара, новости). Подходит при больших объёмах страниц и on-demand публикациях.
    -SSR: персонализация/сессия, часто меняющиеся данные, запрет кэширования, строгие требования к SEO на «свежих» данных (аккаунт, корзина, paywall, гео/локализация).
    -CSR: пост‑логин интерфейсы, админки, дашборды, когда SEO не важен/закрыт, максимум интерактивности на клиенте, офлайн/SPA‑поведение.
    -PPR: страницы с стабильным статическим каркасом и тяжёлыми динамическими виджетами; нужен быстрый TTFB (shell) и постепенная подгрузка динамики через streaming/RSC.
Как реализовать каждый тип рендеринга? (App Router, Next.js 15+)
    -SSG: в `app/` по умолчанию статично; используйте `export const dynamic = 'force-static'` при необходимости; `export const revalidate = false`; `generateStaticParams` для динамических сегментов; `fetch` без `no-store`.
    -ISR: `export const revalidate = <SECONDS>` в странице/сегменте; избегайте `cache: 'no-store'`; on‑demand через `revalidatePath('/path')`/`revalidateTag('tag')` в серверных действий (Server Actions) или маршрутах.
    -SSR: `export const dynamic = 'force-dynamic'` или `fetch(..., { cache: 'no-store' })`/`{ next: { revalidate: 0 } }`; чтение `cookies()/headers()` делает сегмент динамическим; результат стримится RSC/HTML.
    -CSR: компоненты с `'use client'`, фетчи в браузере (`useEffect`/`use`) или `next/dynamic(..., { ssr: false })` для отдельных виджетов; навигация `next/link`/`useRouter`.
    -PPR: статичный shell (layout, header, footer) + динамические секции под `Suspense`; серверные компоненты стримятся как RSC чанки; при необходимости комбинируйте с ISR/SSR на уровне поддеревьев.

в какой среде может работать next.js?
    - Node.js и Edge Runtime (изоляторы на базе V8, напр. Vercel Edge). Также поддерживаются serverless-провайдеры.
    
В чем отличие edge от node js?
Edge: быстрые холодные старты, ограничения API (нет полноценного fs, ограниченные модули Node), короткое время выполнения, ориентирован на стриминг и низкую задержку ближе к пользователю. Node: полная среда Node API, доступ к файловой системе/модулям, более длительные задачи, традиционные серверы/серверлесс функции.

как оптимизировать сервер next.js приложения для ситуаций когда сайтом в день пользуются 10000 юзеров и сервер не выдерживает
- Включить SSG/ISR для кэшируемых страниц, снизив долю SSR.
- Вынести тяжёлые запросы в CDN/edge кэш, использовать `Cache-Control`, `revalidate`.
- Использовать PPR/стриминг для ускорения TTFB и инкрементальной отрисовки.
- Оптимизировать БД: индексы, connection pooling, дедупликация fetch (Next.js Request Memoization), очереди.
- Включить CDN для статических ассетов и изображений (`next/image`).
- Горизонтально масштабировать (автоскейлинг), использовать serverless/edge где уместно.
- Профилировать и убирать блокирующие операции, уменьшить бандлы, внедрить RUM/метрики.