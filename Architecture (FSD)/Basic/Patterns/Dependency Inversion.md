**Dependency Inversion** — это принцип проектирования, при котором высокоуровневые модули (компоненты, отвечающие за основную логику приложения) не зависят от низкоуровневых модулей (деталей реализации, таких как конкретные API-запросы, базы данных или другие инфраструктурные компоненты). Вместо этого, и высокоуровневые, и низкоуровневые модули зависят от общих абстракций (интерфейсов или контрактов).

Принцип Dependency Inversion делает систему гибче и устойчивее к изменениям, так как позволяет изменять реализацию деталей (например, API-запросы) без изменения логики, и упрощает тестирование, поскольку можно подменить реализации заглушками (моками) для проверки отдельных частей кода.

В контексте FSD и React это можно организовать так, чтобы функциональные компоненты и бизнес-логика не зависели напрямую от реализации низкоуровневых деталей (например, API-запросов или других модулей).

### Пример на FSD и React

Допустим, у нас есть e-commerce приложение, где один из компонентов — это корзина покупок (shopping cart). В обычной реализации, компонент корзины мог бы напрямую обращаться к API для добавления или удаления товаров. Однако, если мы захотим поменять API, возможно, придется переписать сам компонент корзины. Dependency Inversion помогает избежать этой жесткой связи.

#### Как это сделать с Dependency Inversion:

1. **Создаём абстракцию для работы с корзиной**. Это может быть интерфейс или контекст, который определяет, какие методы нам нужны для работы с корзиной, например `addItem`, `removeItem`, `getItems`. Эта абстракция находится в слое **Entities** или **Shared**, так как она отделена от конкретного API.
    
2. **Реализуем конкретный сервис для API-запросов**. В слое **API** мы создаём реализацию, которая знает, как конкретно взаимодействовать с сервером. Она реализует интерфейс корзины (например, вызывает `fetch` для добавления или удаления товаров с сервера).
    
3. **Инжектируем зависимость**. В компоненте корзины мы не используем API напрямую, а вместо этого обращаемся к абстракции, что позволяет переключаться между разными реализациями API (например, между реальными серверными запросами и заглушками для тестов) без изменения кода компонента.
    

#### Как это выглядит в FSD-структуре:

- **Entities**: определяет интерфейс или абстракцию для работы с корзиной.
- **API**: реализует конкретные функции для запросов к серверу, используя интерфейс из Entities.
- **Features**: реализует логику добавления товаров в корзину и использует методы из Entities (а не напрямую API).
- **UI (Pages или Widgets)**: отображает корзину и использует логику из Features, не заботясь о том, откуда приходят данные.

### Преимущества

- **Гибкость**: если нужно сменить API, изменения вносятся только в реализацию сервиса, а не в весь код.
- **Тестируемость**: можно легко подменить реальный API заглушкой или моком для тестирования.
- **Меньшая связанность**: компоненты верхнего уровня не зависят от конкретных реализаций API и работают через абстракции.

Этот подход делает архитектуру более гибкой, особенно в проектах с большой кодовой базой.