## Переменные и объявления

1. Что такое переменные в JavaScript, и как они работают?
	- это именованные контейнеры, используемые для хранения данных

2. В чём различия между `var`, `let` и `const` в JavaScript?
	1. `var`: область видимости функциональная
	2. `let` и `const`: область видимости блочная
	3. `var`: можно переобъявлять в одной области видимости
	4. `var`: `hoisting` 
	5. `let` и `const`: `TDZ` 
	6. `var` и `let`: можно объявить без инициализации
	7. `var` и `let`: значения изменяемы (mutable)
	8. `const`: ссылка неизменяема (immutable), но содержимое объектов и массивов может изменяться (mutable)

3. Что такое `Temporal Dead Zone` и Hoisting? На какие сущности распространяется `TDZ` а на какие `hoisting`?
	- Hoisting – это механизм при котором интерпретатор во время фазы компиляции определяет все объявления переменных и функций и регистрирует их в соответствующей области видимости до начала выполнения кода
		1. `var` - происходит инициализация значением `undefined` в начале выполнения кода
		2.  `function declaration` полностью определяется в начале
	- `Temporal Dead Zone` - это период времени в процессе исполнения кода, когда переменная, объявленная через `let` или `const`, уже определена во внутренней структуре области видимости, но ещё не инициализирована
	- `TDZ` распространяется на `const` `let` и Class

## Область видимости и Lexical Environment

4. Что такое область видимости (`scope`) и какие типы области видимости существуют в JavaScript?
	- Область видимости - это контекст, в рамках которого определяются и становятся доступными переменные, функции и другие объекты
	- типы областей видимости
		1. глобальная - доступна во всём коде, переменные видимы в любом месте программы
		2. функциональная - переменные доступны только внутри функции, где они были объявлены
		3. блочная - переменные доступны только внутри блока {}, где они объявлены
		4. модульная - переменные и функции доступны только внутри модуля, если они не экспортированы
		5. лексическая - это механизм, который определяет доступность переменных на основании их расположения в коде во время его написания. Она описывает правила взаимодействия между вложенными областями видимости.
			- Дочерние области видимости могут получать доступ к переменным родительских областей.
			- Родительские области видимости не имеют доступа к переменным дочерних областей

5. Что такое `Lexical Environment` и `Scope Chain`, и как они работают?
	- `Lexical Environment` - это структура которая состоит из 
		- Environment Record - информации о переменные и функции, объявленные в данном контексте или области видимости
		- сcылку на родительский `Lexical Environment`
	- `Scope Chain` - это механизм, с помощью которого интерпретатор выполняет поиск переменных и функций, начиная с текущего `Lexical Environment` и последовательно переходя к его родительским окружениям, вплоть до глобального `Lexical Environment`.

## Типы данных

6. Какие типы данных существуют в JavaScript и чем отличаются примитивные и ссылочные типы данных?
	1. Примитивные хранятся непосредственно, они имутабельные сравниваются по значние и хрянятся в стеке
	2. Ссылочные хранятся по ссылки, они мутабельные сравниваются по ссылке и хранятся в куче, а ссылка на него в стеке

7. Какие типы данных в JavaScript являются примитивными?
	1. `string`
	2. `number`
	3. `bigInt`
	4. `undefined`
	5. `null`
	6. `symbol`
	7. `boolean`

8. Что такое `Symbol` и для чего они используются в JavaScript?
	- уникальность и неизменность примитивный тип данных 
	- уникальные ключи для объектов
	- создание скрытых свойств
	- уникальные идентификаторы

9. Как работает `BigInt` и для чего он нужен?
	- для работы с целыми числами которые выходят за границы обычного `number`
	- несовместим без приведения типов с `number`
	- Для обозначения числа как `BigInt`, необходимо добавить суффикс n

10. В чем разница между `null` и `undefined`?
	- `null` для явного указания пустоты или обнуление
	- `undefined` когда не присвоено значение или у объекта отсутствует свойство

11. Когда и почему можно ожидать значение `undefined`?
	1. Обращение к переменной, объявленной через `var` до её инициализации:
	2. Функции, которые ничего не возвращают
	3. Переменные, объявленные с помощью `let` без инициализации
	4. Обращение к несуществующему свойству объекта
	5. Неинициализированные параметры функции
	6. Элементы массива, которым не присвоено значение
	7. Деструктуризация без соответствующего значения

12. В чём разница между `Number.isNaN`() и `isNaN`() в JavaScript, и какой предпочтительнее использовать?
	- `isNaN`() - пытается преобразовать переданный аргумент в число перед проверкой
	- `Number.isNaN`() безя преобразовагтя проверяет переданный аргумент

13. Что вернёт `typeof` для `null`, и что вернёт `typeof` для функции? Почему?
	- `object` так как исторической особенностью JavaScript 
	- `function`

14. Что такое приведение типов (`type coercion`) и явное преобразование (`type conversion`) в JavaScript? Примеры каждого?
	- Приведение типов(`type coercion`, неявное преобразование) — это автоматическое преобразование **'5' + 2 → '52', '5' - 2 → 3**
	- Преобразование типов (Type Conversion, явное преобразование) — это явное преобразование Number('5') → 5, String(123) → '123'

15. Какие значения  при приведении к булевому типу (`boolean`) возвращают false?
	1. `0`
	2. `0n`
	3. `''`
	4. `undefined`
	5. `null`
	6. `NaN`

## Объекты и структуры данных

16. В чём разница между глубоким (deep) и поверхностным (shallow) копированием объектов в JavaScript?
	- Глубокое копирование копирует все уровни вложенности так что изменения в копии **не затрагивают** оригинальный объект.
	- Поверхностное копирование копирует только верхний уровень объекта, при этом вложенные объекты и массивы копируются по ссылке и ссылки на вложенные структуры сохраняются.

17. Что такое `Map` в JavaScript, чем он отличается от обычного объекта и от Weak`Map`?
	- `Map` это  объект который представляет собой коллекцию пар ключ-значение
	- Отличие от обычного объекта:
		1. ключи могут быть любого типа
		2. порядок вставки ключей сохраняется
		3. оптимизирован для операций поиска вставки и удаления по ключ
	- Отличие `Map` от `WeakMap`
		1. В `WeakMap` ключами могут быть только объекты
		2. В `WeakMap` нет методов для перечисления ключей или значений (keys(), values(), entries())
		3. Ключи в `WeakMap` являются "слабыми ссылками". Если на объект-ключ больше нет ссылок из других мест программы, он автоматически удаляется из Weak`Map` при сборке мусора

18. Что такое `Set` в JavaScript, для каких задач он используется и чем отличается от `WeakSet`?
	- `Set` это  объект который представляет собой коллекцию уникальных значений любого типа.
	- `WeakSet` хранит только объекты
	- У `WeakSet` нет методов для итерации (`forEach`, keys, values и т.д.), так как элементы могут удаляться динамически.
	- `WeakSet` **не предотвращает сборку мусора**. Если объект больше не доступен в коде, он удаляется из `WeakSet` автоматически.

19. Как устроено прототипное наследование в JavaScript и как оно работает?
	- через `__proto__` - ссылка на объект прототипа

## Функции

20. Что такое функции в JavaScript и для чего они используются?
	- функция - это блок кода, который выполняет определённую задачу, и её можно многократно вызывать в разных частях кода.

21. Какие существуют способы объявления функций в JavaScript и чем они отличаются?
	1. `Function Declaration`
	2. `Function Expression`
	3. `Arrow Function`
	4. `IIFE`

22. Что такое анонимные функции, и какие из способов объявления функций поддерживают их?
	- Это функция без имени, которая создается в моменте и используется сразу в нужном контексте, например, для передачи в качестве аргумента, колбэка или внутри методов.
	- поддерживается:
		1. `Function Expression`
		2. `Arrow Function`
		3. `IIFE`

23. Какие способы объявления функций поднимаются механизмом `hoisting` и как именно?
	- все способы объявления функций поддерживают `hoisting`, но для способов отличных от  `Function Declaration` применяется еще `TDZ`

24. В чём отличие функций‑конструкторов от классов в JavaScript?
	1. классы это синтаксический сахар
	2. на классы распространятеся `TDZ` в отлчии от функции-конструкторы который инициилизруются сразу
	3. Class всегда работает в строгом режиме

25. Что такое стрелочные функции в JavaScript и чем они отличаются от обычных функций?
	- Стрелочные функции - это синтаксический сахар для более короткого определения функций. Они имеют ряд особенностей, таких как отсутствие своего `this`, `arguments` и поддерживают `TDZ`

26. Что такое Immediately Invoked `Function Expression` (`IIFE`) и для чего она используется?
	- `IIFE` - это функция, которая определяется и немедленно вызывается. Она используется для создания изолированной области видимости

27. Что такое функции-генераторы в JavaScript?
	- вид функций, позволяющий приостанавливать и возобновлять их выполнение, а также возвращать промежуточные значения в процессе работы

28. Что такое функции обратного вызова (`callback`) в JavaScript и зачем они нужны?
	- это функции, которые передаются в качестве аргумента другой функции и вызываются внутри этой функции после выполнения определённого действия или при наступлении определённого события.

29. Что такое мемоизация функций и в каких случаях она полезна?
	- техника оптимизации, при которой результаты вызова функции запоминаются в зависимости от переданных аргументов.
	- Трудоёмкие вычисления, повторяющиеся вызовы и тд

30. Что означает, что функции в JavaScript — объекты первого класса (first‑class)?
	- это функции, которые можно:
		1. Присваивать переменной.
		2. Передавать в качестве аргумента другой функции.
		3. Возвращать из другой функции.

34. Что такое рекурсия и когда её применять на практике?
	- функция вызывает сама себя

35. Что такое объект `arguments` в JavaScript и в каких способах объявления он недоступен? Почему?
	- это встроенный в функции объект, который содержит массивоподобный список всех аргументов, переданных в функцию
	- не поддерживается в `arrow function`, лучше использовать `rest-параметры` (остаточный оператор)

36. Что такое rest‑параметры и оператор расширения (spread) в JavaScript и как их использовать?
	- `Rest-параметры` позволяют объявить функцию, которая может принимать любое количество аргументов, сгруппированных в один массив, аналог `arguments` 
	- `Spread-оператор` — позволяет раскрыть итерируемый объект в набор отдельных элементов или свойств там, где ожидается перечисление значений

37. Что представляет собой ключевое слово `this` и как определяется его контекст в разных ситуациях?
	- `this` представляет собой ссылку на текущий контекст выполнения, который определяется способом вызова функции
	1. В глобальной области видимости.
		1. строгом режиме равен `undefined`
		2. браузера им является объект `window`
		3. в среде Node.js – объект global
	1. В методе объекта.
		- на контекст объекта
	1. В функции-конструкторе.
		- на контекст объекта созданный этой функцией оператором new
	1. В стрелочных функциях.
		- на контекст родителя

38. Что такое замыкание (`closure`) и как оно работает?
	- замыкание - это механизм, при котором функция запоминает свое лексическое окружение, то есть контекст, в котором она была создана, и сохраняет доступ к этим переменным даже после завершения выполнения внешней функции, из которой она была вызвана.

39. В чем разница между методами `call`(), `apply`() и `bind`() в JavaScript, и когда использовать каждый из них?
	- Методы `call`(), `apply`() и `bind`() в JavaScript используются для управления контекстом вызова функции
	- `call`() - вызывает функцию немедленно, с указанным значением `this` и переданными аргументами по отдельности.
	- `apply`() - вызывает функцию немедленно, с указанным значением `this` и переданными аргументами в виде массива.
	- `bind`() возвращает новую функцию с указанным значением `this` и фиксированными аргументами (если они переданы), в отличии от других методов функция не вызывается сразу и может быть вызвана в дальнейшем уже с изменым контекстом

## Классы

40. Что такое классы в JavaScript и как они объявляются?
	- классы - это синтаксический сахар над прототипным наследованием, введенный в ES6
	- объявляются с помощью ключевого слова `class`
	- классы всегда работают в строгом режиме

41. Как работает конструктор класса в JavaScript?
	- специальный метод `constructor`, который вызывается при создании нового экземпляра класса
	- используется для инициализации свойств объекта
	- может принимать параметры

42. Что такое статические методы и свойства в классах JavaScript?
	- статические методы и свойства принадлежат самому классу, а не его экземплярам
	- объявляются с помощью ключевого слова `static`
	- вызываются через имя класса, а не через экземпляр

43. Как работает наследование классов в JavaScript через `extends` и `super`?
	- `extends` используется для создания дочернего класса, который наследует от родительского
	- `super` используется для вызова конструктора и методов родительского класса
	- `super` должен быть вызван в конструкторе дочернего класса до использования `this`

44. Что такое приватные поля и методы в классах JavaScript и как они объявляются?
	- приватные поля и методы доступны только внутри класса
	- объявляются с помощью префикса `#`
	- не доступны извне класса и его экземпляров

45. Что такое геттеры и сеттеры в классах JavaScript?
	- геттеры (`get`) - методы для получения значения свойства
	- сеттеры (`set`) - методы для установки значения свойства
	- позволяют контролировать доступ к свойствам объекта

46. В чём разница между классами и функциями-конструкторами в JavaScript?
	1. классы - синтаксический сахар над функциями-конструкторами
	2. классы всегда работают в строгом режиме
	3. классы находятся в TDZ до объявления
	4. методы класса не перечисляемы
	5. классы нельзя вызывать без `new`

47. Что такое вычисляемые свойства (computed properties) в классах JavaScript?
	- свойства и методы, имена которых вычисляются во время выполнения
	- объявляются с помощью квадратных скобок `[выражение]`

48. Как работают миксины (mixins) в JavaScript и для чего они используются?
	- паттерн для добавления функциональности классу без наследования
	- позволяют комбинировать функциональность из разных источников
	- реализуются через функции, которые принимают класс и возвращают расширенный класс

49. Что такое абстрактные классы в JavaScript и как их реализовать?
	- классы, которые не могут быть инстанцированы напрямую, только через наследование
	- в JavaScript нет нативной поддержки, но можно реализовать через проверки в конструкторе или через ошибки

## Асинхронность и Event Loop

50. В чём разница между синхронным и асинхронным кодом в JavaScript?
	- Синхронный код
		- Выполняется последовательно, инструкция за инструкцией
		- блокирует выполнение дальнейшего кода до завершения текущей операции
	- Асинхронный код
		- операции выполняются в фоне, позволяя основному потоку продолжать выполнение без блокировки

58. Что такое `Event Loop` в JavaScript и как он работает?
	- `Event Loop` - механизм, обеспечивающий выполнение асинхронного кода в однопоточном окружении
	- как работает:
		1. Выполняется весь синхронный код
		2. Выполняются все задачи из очереди микрозадач
		3. Берется первая задача из очереди макрозадач и выполняется
		4. При необходимости обновляется пользовательский интерфейс
		5. Цикл возвращается к обработке очереди микрозадач
		- При отсутствии задач `Event Loop` продолжает ожидание новых событий

59. Что такое стек вызовов (`Call Stack`) и как он взаимодействует с асинхронным кодом?
	- `Call Stack` - это структура данных, используемая движком JavaScript для отслеживания выполнения функций в программе. Он работает по принципу **LIFO (Last In, First Out)**, то есть последняя вызванная функция обрабатывается первой.

60. Что такое очереди задач: `macrotasks` и `microtasks`, и как они влияют на порядок выполнения кода?
	- Когда асинхронная задача попадает в **`Call Stack`**, она передается во внешнюю систему, которая после завершения добавляет её `callback` в macroTasks Queue или microTasks Queue. Когда `Call Stack` становится пустым, сначала обрабатываются задачи из macroTasks Queue, а затем из microTasks Queue

61. Приведите примеры микрозадач (`microtasks`) и макрозадач (`macrotasks`) в JavaScript?
	- MicroTasks:
		1. .`then()` .`catch()`  .`finally()`
		2. MutationObserver
		3. queueMicrotask()
	- Macrotasks:
		1. `setTimeout` `setInterval`
		2. `DOM` Events
		3. setImmediate
		4. Сетевые запросы

62. Как работают setImmediate() и queueMicrotask() и чем они отличаются?
	- setImmediate(): помещает задачу в очередь макрозадач
	- queueMicrotask(): помещает задачу в очередь микрозадач

63. Что такое промисы (`Promise`) в JavaScript и какие у них есть состояния?
	- `Promise` — это объект в JavaScript, который представляет результат асинхронной операции 
	- у него есть 3 состояния
		1. ожидание (`pending`)
		2. выполнено (`fulfilled`)
		3. отклонено (`rejected`)

64. Как работают `Promise.all()`, `Promise.allSettled()`, `Promise.race()` и `Promise.any()`? Какие есть дополнительные статические методы промисов?
	- `Promise.all()` — ждет выполнения всех промисов, прерывается, если один промис отклонен
	- `Promise.allSettled()` — ждет завершения всех промисов в независимости от их статуса
	- `Promise.race()` — возвращает первый выполненный промис.
	- `Promise.any()` — возвращает первый выполненный успешно промис, игнорируя ошибки
	- `Promise.reject()` - cоздает промис, который немедленно переходит в состояние **`rejected`** с указанной причиной ошибки
	- `Promise.resolve()` - cоздает промис, который немедленно переходит в состояние **`fulfilled`** с указанным значением
	- `Promise.withResolvers()` - синтаксического сахар,  статический метод, который создает новый промис и одновременно возвращает объект, содержащий
		1. сам promise,
		2. функцию resolve для его успешного завершения,
		3. функцию reject для его отклонения.
	- `Promise.try()` - синтаксического сахар, способ безопасно «обернуть» синхронный код, который может выбросить ошибку, в `Promise`, аналог `Promise.resolve()`.`then`(() => {})

65. Как работает метод .`then()` у промисов и что он возвращает?
	- Метод .`then()` для обработки выполнения промиса, возвращает новый промис.
	- Он принимает два аргумента:
		1. onFulfilled — функция, выполняемая при успешном разрешении промиса.
		2. onRejected (опционально, типа `catch`, но как аргумент `then`) — функция для обработки ошибок.

66. Какие механизмы обработки ошибок есть в JavaScript? Как работает `try...catch` и что делает `finally`?
	- механизмы обработки ошибок
		1. аргумент onRejected в .`then()`
		2. try...`catch`
		3. throw
		4. Обработка ошибок с помощью `Promise` и `catch()`
	- `try...catch...finally`
		1. `try()` - Включает код, выполнение которого может вызвать ошибку
		2. `catch()` - Срабатывает только в том случае, если в try блоке возникает ошибка
		3. `finally()` - Выполняется всегда, независимо от того, была ли ошибка или нет

67. Что такое объект `Error` в JavaScript и какие его свойства чаще всего используются (`message`, `name`, `stack`)?
	- Объект `Error` в  предназначен для создания ошибок и их обработки
	- Основные свойства объекта `Error`
		1. `message`  -  текстовое сообщение об ошибке, переданное в конструктор объекта.
		2. `name` - имя ошибки, по умолчанию это `Error`.
		3. `stack`  - информацию о стеке вызовов.

68. Что такое `async`/`await` и как они работают с промисами?
	- синтаксический сахар для работы с промисами
	- `async` Делает функцию асинхронной, что позволяет использовать внутри неё `await` и возвращает всегда promis
	- `await` приостанавливает выполнение асинхронной функции до разрешения промиса и возвращает его результат

69. Как работают таймеры `setTimeout` и `setInterval` и чем они отличаются?
	- `setTimeout` - запускает функцию один раз после указанного времени задержки
		- очистка - `clearTimeout`
	- `setInterval` - запускает функцию периодически с указанным интервалом времени до тех пор, пока таймер не будет остановлен
		- очистка - `clearInterval`

70. Что такое `callback` hell (pyramid of doom) и как с ним бороться?
	- несколько вложенных обратных вызовов создают сложный код с глубокими отступами
	- Решение:
		1. `async`/`await`
		2. promises
		3. модульность

71. Что такое состояние гонки (`race condition`) и как его избегать в JavaScript?
	ситуация, возникающая при параллельном выполнении операций, когда результат зависит от неконтролируемого порядка их завершения

72. Что такое дебаунсинг (`debouncing`) и троттлинг (`throttling`) и когда их применять?
	- это техники оптимизации для обработки событий
	- Debouncing - предотвращает выполнение функции, пока события происходят часто, и позволяет её вызвать только один раз, через заданную задержку после того, как поток событий прекратился.
	- Throttling - позволяет функции выполняться регулярно, но не чаще, чем раз в заданный интервал времени, даже если события происходят беспрерывно.

73. Что такое цепочка промисов (`promise chaining`) и зачем она нужна?
	- техника последовательного выполнения асинхронных операций с использованием цепочки промисов. Каждый .`then` передаёт результат следующему обработчику.

74. Что такое «`deadlock`» (взаимная блокировка) и почему в JavaScript такое встречается редко?
	- ситуация, при которой два или более процесса ждут друг друга, блокируя выполнение всех операций
	- Избежание:
		1. Упорядочивание захватов блокировок.
		2. Использование таймаутов при ожидании блокировок.
		3. Минимизация использования блокировок.

## Массивы

75. Какие методы массивов (`map`, `filter`, `reduce` и др.) используются для работы с данными и чем они полезны?
	- `map` - Применяет функцию к каждому элементу массива и возвращает новый массив с результатами.
	- `forEach` - Применяет функцию для каждого элемента массива, но ничего не возвращает
	- filtred - создает новый массив, содержащий только элементы, которые удовлетворяют заданному условию.
	- `reduce` - преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору
	- `reduce`Right - аналогичен `reduce`, но обход массива выполняется справа налево.
	- `find` - возвращает первый элемент массива, который удовлетворяет заданному условию, или `undefined`, если такого элемента нет.
	- `find`Index - возвращает индекс первого элемента, который удовлетворяет заданному условию, или -1, если такого элемента нет.
	- `indexOf` - возвращает первый индекс указанного элемента в массиве или -1, если элемент не найден.
	- `lastIndexOf` - возвращает последний индекс указанного элемента в массиве или -1, если элемент не найден.
	- `includes` - проверяет, содержит ли массив указанный элемент, возвращает true или false.
	- `some` - возвращает true, если хотя бы один элемент массива удовлетворяет условию.
	- `every` - возвращает true, если все элементы массива удовлетворяют условию.

76. Чем отличается `forEach` от `map` и когда использовать каждый?
	- `forEach` - выполнить какую-либо операцию над элементами массива
	- `map` - возвращает новый массив с преобразованными данными.

77. Что делает метод `reduce` и когда он может заменить другие методы работы с массивами?
	- преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору

20. Чем отличается копирование массива с помощью `slice`, оператора spread и `Array.from`()?
	- `slice` - позволяет копировать часть массива (подмассив) с указанием границ индексов.
	- spread-оператора - поддерживает объединение массивов и добавление новых элементов в процессе копирования.
	- `Array.from`() - работает с массивоподобными объектами (например, `arguments` или `DOM`-коллекциями) и позволяет преобразовывать элементы при копировании.


//
## Современные операторы

34. Что такое optional chaining (`?.`) в JavaScript и для чего он используется?
	- Оператор optional chaining (`?.`) позволяет безопасно обращаться к свойствам объектов и вызывать методы, даже если промежуточное значение равно `null` или `undefined`
	- Если левая часть выражения равна `null` или `undefined`, оператор возвращает `undefined` вместо выброса ошибки
	- Используется для:
		1. Доступа к вложенным свойствам объектов: `obj?.prop?.nested`
		2. Вызова методов: `obj?.method?.()`
		3. Доступа к элементам массива: `arr?.[0]`

35. Что такое nullish coalescing (`??`) в JavaScript и чем он отличается от логического оператора `||`?
	- Оператор nullish coalescing (`??`) возвращает правый операнд только если левый равен `null` или `undefined`
	- Отличие от `||`:
		1. `||` возвращает правый операнд для всех falsy значений (`false`, `0`, `''`, `NaN`, `null`, `undefined`)
		2. `??` возвращает правый операнд только для `null` и `undefined`
	- Пример: `0 || 10` вернёт `10`, а `0 ?? 10` вернёт `0`

36. Что такое логические операторы присваивания в JavaScript и какие они бывают?
	- Логические операторы присваивания объединяют логическую операцию с присваиванием
	- Виды:
		1. `&&=` (логическое И присваивание) - присваивает значение только если левый операнд truthy
		2. `||=` (логическое ИЛИ присваивание) - присваивает значение только если левый операнд falsy
		3. `??=` (nullish coalescing присваивание) - присваивает значение только если левый операнд `null` или `undefined`
	- Пример: `x ??= defaultValue` эквивалентно `x = x ?? defaultValue`

37. Как работает комбинирование optional chaining и nullish coalescing?
	- Операторы можно комбинировать для безопасного доступа к свойствам с значением по умолчанию
	- Пример: `obj?.prop?.nested ?? 'default'` вернёт `'default'` если любое из промежуточных значений равно `null` или `undefined`
	- Полезно для работы с вложенными структурами данных, где некоторые свойства могут отсутствовать

## Оператор delete

38. Что делает оператор `delete` в JavaScript и что он может удалять?
	- Оператор `delete` удаляет свойство из объекта
	- Может удалять:
		1. Свойства объектов
		2. Элементы массивов (оставляя "дырки" - sparse arrays)
	- Не может удалять:
		1. Переменные, объявленные через `var`, `let` или `const`
		2. Функции, объявленные через `function declaration`
		3. Свойства, определённые с флагом `configurable: false`
		4. Встроенные свойства объектов (например, `Math.PI`)

39. Что возвращает оператор `delete` в JavaScript?
	- Оператор `delete` возвращает `true` если свойство было успешно удалено
	- Возвращает `false` если свойство не может быть удалено (например, `configurable: false`)
	- Возвращает `true` даже если свойство не существовало (несуществующие свойства считаются успешно "удалёнными")

40. В чём разница между удалением свойства через `delete` и присваиванием `undefined`?
	- `delete` полностью удаляет свойство из объекта, свойство перестаёт существовать
	- Присваивание `undefined` оставляет свойство в объекте, но со значением `undefined`
	- Разница:
		1. `'prop' in obj` вернёт `false` после `delete`, но `true` после присваивания `undefined`
		2. `Object.keys(obj)` не будет включать удалённое свойство, но включит свойство со значением `undefined`
		3. `delete` освобождает память, присваивание `undefined` - нет

41. Как оператор `delete` работает с массивами в JavaScript?
	- `delete` может удалять элементы массива по индексу
	- Удалённый элемент становится "дыркой" (sparse array) - индекс существует, но значение равно `undefined`
	- Длина массива (`length`) не изменяется после `delete`
	- Для полного удаления элементов лучше использовать методы массивов: `splice()`, `pop()`, `shift()`

## Оператор new

42. Что делает оператор `new` в JavaScript и как он работает?
	- Оператор `new` создаёт новый экземпляр объекта из функции-конструктора или класса
	- Процесс создания объекта с `new`:
		1. Создаётся новый пустой объект
		2. Устанавливается прототип нового объекта на `Constructor.prototype`
		3. Вызывается конструктор с контекстом `this`, указывающим на новый объект
		4. Если конструктор возвращает объект, он используется; иначе возвращается созданный объект

43. В чём разница между вызовом функции с `new` и без `new`?
	- С `new`: создаётся новый объект, `this` указывает на этот объект, возвращается новый экземпляр
	- Без `new`: функция вызывается как обычная, `this` зависит от контекста вызова, возвращается результат функции
	- Если функция-конструктор возвращает примитив, `new` игнорирует возвращаемое значение и возвращает созданный объект
	- Если функция-конструктор возвращает объект, `new` возвращает этот объект вместо созданного

44. Что происходит, если вызвать обычную функцию с оператором `new`?
	- Обычная функция может быть вызвана с `new`, даже если она не предназначена для этого
	- Создаётся новый объект, и функция выполняется с `this`, указывающим на этот объект
	- Если функция ничего не возвращает или возвращает примитив, возвращается созданный объект
	- Это может привести к неожиданному поведению, поэтому функции, не предназначенные для использования с `new`, должны проверять контекст

45. Как проверить, была ли функция вызвана с оператором `new`?
	- Используя `new.target`: если функция вызвана с `new`, `new.target` содержит ссылку на функцию-конструктор; иначе `undefined`
	- Используя `instanceof`: проверка `this instanceof Constructor` работает только если функция вызвана с `new`
	- Используя проверку типа `this`: в строгом режиме `this` будет `undefined` при обычном вызове, объект - при вызове с `new`

46. Что такое `new.target` в JavaScript и для чего он используется?
	- `new.target` - метасвойство, доступное внутри функций и конструкторов
	- Содержит ссылку на функцию-конструктор, если функция вызвана с `new`
	- Равен `undefined`, если функция вызвана без `new`
	- Используется для:
		1. Определения, была ли функция вызвана с `new`
		2. Создания абстрактных классов (проверка, что класс не инстанцируется напрямую)
		3. Реализации паттернов, где поведение зависит от способа вызова

## Циклы с Итераторами

47. Какие типы циклов существуют в JavaScript и чем они отличаются?
	- Циклы с условием:
		1. `for` - цикл с счётчиком, выполняется заданное количество раз
		2. `while` - цикл с условием, выполняется пока условие истинно
		3. `do...while` - цикл с условием, выполняется минимум один раз
	- Циклы по коллекциям:
		1. `for...in` - перебирает перечисляемые свойства объекта (ключи)
		2. `for...of` - перебирает итерируемые объекты (значения)
	- Методы массивов: `forEach()`, `map()`, `filter()` и др.

48. В чём разница между `for...in` и `for...of` в JavaScript?
	- `for...in`:
		1. Перебирает перечисляемые свойства объекта (ключи)
		2. Работает с объектами, массивами, строками
		3. Перебирает ключи (индексы для массивов, имена свойств для объектов)
		4. Может включать унаследованные свойства (если не использовать `hasOwnProperty()`)
	- `for...of`:
		1. Перебирает итерируемые объекты (значения)
		2. Работает только с объектами, имеющими `Symbol.iterator`
		3. Перебирает значения элементов
		4. Не перебирает унаследованные свойства

49. Как работают операторы `break` и `continue` в циклах JavaScript?
	- `break` - прерывает выполнение цикла и выходит из него
	- `continue` - пропускает текущую итерацию и переходит к следующей
	- Работают во всех типах циклов: `for`, `while`, `do...while`, `for...in`, `for...of`
	- В вложенных циклах можно использовать метки для управления внешними циклами

53. Что такое метки (labels) в циклах JavaScript и как их использовать?
	- Метки - способ именования циклов для управления вложенными циклами
	- Синтаксис: `labelName: for (...) { ... }`
	- Используются с `break` и `continue` для управления внешними циклами
	- Пример:
	```javascript
	outer: for (let i = 0; i < 3; i++) {
		for (let j = 0; j < 3; j++) {
			if (i === 1 && j === 1) break outer;
		}
	}
	```

54. В чём разница между `forEach()` и циклами `for...of` или `for`?
	- `forEach()`:
		1. Нельзя прервать через `break` или `continue`
		2. Возвращает `undefined`
		3. Работает только с массивами
		4. Нельзя использовать `return` для выхода из функции-обработчика
	- `for...of` и `for`:
		1. Можно использовать `break` и `continue`
		2. Можно использовать `return` для выхода из функции
		3. Работают с любыми итерируемыми объектами
		4. Более гибкие для сложной логики

## Условные операторы

55. Какие условные операторы существуют в JavaScript и как они работают?
	- `if/else` - базовый условный оператор для выполнения кода в зависимости от условия
	- `switch` - оператор для множественного выбора на основе значения выражения
	- Тернарный оператор (`? :`) - сокращённая форма `if/else` для простых условий
	- Логические операторы как условные (`&&`, `||`) - используются для условного выполнения кода

56. Как работает оператор `switch` в JavaScript и чем он отличается от `if/else`?
	- `switch` сравнивает значение выражения с различными вариантами (`case`) и выполняет соответствующий блок кода
	- Отличия от `if/else`:
		1. `switch` использует строгое сравнение (`===`)
		2. `switch` требует `break` для предотвращения "проваливания" в следующий `case`
		3. `switch` более читабелен для множественных проверок одного значения
		4. `switch` может использовать `default` для обработки всех остальных случаев
	- Без `break` выполнение продолжается в следующий `case` (fall-through)

57. Что такое тернарный оператор в JavaScript и когда его использовать?
	- Тернарный оператор (`? :`) - сокращённая форма условного выражения
	- Синтаксис: `условие ? значениеЕслиИстина : значениеЕслиЛожь`
	- Используется для:
		1. Простых условных присваиваний
		2. Условных возвратов значений
		3. Встраивания в выражения
	- Не рекомендуется для сложных условий или вложенных тернарных операторов (снижает читаемость)

58. Как работают логические операторы `&&` и `||` как условные операторы?
	- Логические операторы могут использоваться для условного выполнения кода
	- `&&` (логическое И):
		1. Если левый операнд truthy, возвращается правый операнд
		2. Если левый операнд falsy, возвращается левый операнд (выполнение останавливается)
		3. Пример: `condition && doSomething()` - выполнится только если `condition` truthy
	- `||` (логическое ИЛИ):
		1. Если левый операнд truthy, возвращается левый операнд (выполнение останавливается)
		2. Если левый операнд falsy, возвращается правый операнд
		3. Пример: `value || defaultValue` - вернёт `defaultValue` если `value` falsy

## Операторы присваивания

59. Какие операторы присваивания существуют в JavaScript?
	- Базовые операторы присваивания:
		1. `=` - простое присваивание
		2. `+=` - сложение с присваиванием
		3. `-=` - вычитание с присваиванием
		4. `*=` - умножение с присваиванием
		5. `/=` - деление с присваиванием
		6. `%=` - остаток от деления с присваиванием
		7. `**=` - возведение в степень с присваиванием
	- Битовые операторы присваивания:
		1. `<<=` - сдвиг влево с присваиванием
		2. `>>=` - сдвиг вправо с присваиванием
		3. `>>>=` - беззнаковый сдвиг вправо с присваиванием
		4. `&=` - побитовое И с присваиванием
		5. `|=` - побитовое ИЛИ с присваиванием
		6. `^=` - побитовое исключающее ИЛИ с присваиванием

60. Как работают операторы присваивания в JavaScript?
	- Операторы присваивания выполняют операцию и присваивают результат переменной
	- Пример: `x += 5` эквивалентно `x = x + 5`
	- Операторы присваивания возвращают присвоенное значение
	- Можно использовать для цепочки присваиваний: `a = b = c = 5`

61. В чём разница между операторами присваивания и обычными операторами?
	- Операторы присваивания объединяют операцию и присваивание в одну инструкцию
	- Более краткая запись: `x += 5` вместо `x = x + 5`
	- Могут быть более эффективными (хотя современные движки оптимизируют оба варианта)
	- Улучшают читаемость кода для простых операций

## Операторы сравнения и проверки

62. Какие операторы сравнения существуют в JavaScript?
	- Операторы равенства:
		1. `==` (нестрогое равенство) - выполняет приведение типов перед сравнением
		2. `===` (строгое равенство) - сравнивает без приведения типов
		3. `!=` (нестрогое неравенство)
		4. `!==` (строгое неравенство)
	- Операторы сравнения:
		1. `>` (больше)
		2. `<` (меньше)
		3. `>=` (больше или равно)
		4. `<=` (меньше или равно)

63. В чём разница между `==` и `===` в JavaScript и какой предпочтительнее использовать?
	- `==` (нестрогое равенство):
		1. Выполняет приведение типов перед сравнением
		2. Может приводить к неожиданным результатам: `'5' == 5` вернёт `true`
		3. Следует правилам абстрактного сравнения (Abstract Equality Comparison)
	- `===` (строгое равенство):
		1. Сравнивает значения без приведения типов
		2. Более предсказуемое поведение: `'5' === 5` вернёт `false`
		3. Следует правилам строгого сравнения (Strict Equality Comparison)
	- Рекомендация: всегда использовать `===` и `!==` для избежания неожиданного поведения

64. Что такое `Object.is()` в JavaScript и чем он отличается от `===`?
	- `Object.is()` - метод для сравнения двух значений на строгое равенство
	- Отличия от `===`:
		1. `Object.is(NaN, NaN)` возвращает `true`, а `NaN === NaN` возвращает `false`
		2. `Object.is(+0, -0)` возвращает `false`, а `+0 === -0` возвращает `true`
	- Во всех остальных случаях поведение идентично `===`
	- Используется когда нужна более строгая проверка равенства, особенно для `NaN` и знаковых нулей

65. Как работает оператор `in` в JavaScript и для чего он используется?
	- Оператор `in` проверяет наличие свойства в объекте или индекса в массиве
	- Синтаксис: `'property' in object` или `index in array`
	- Возвращает `true` если свойство/индекс существует, иначе `false`
	- Проверяет как собственные, так и унаследованные свойства
	- Примеры:
		1. `'name' in obj` - проверка свойства объекта
		2. `0 in arr` - проверка индекса массива
		3. `'toString' in obj` - вернёт `true` (унаследованное свойство)

66. Как работает оператор `instanceof` в JavaScript и для чего он используется?
	- Оператор `instanceof` проверяет, является ли объект экземпляром определённого конструктора или класса
	- Синтаксис: `object instanceof Constructor`
	- Проверяет всю цепочку прототипов объекта
	- Возвращает `true` если объект был создан через указанный конструктор или наследуется от него
	- Примеры:
		1. `[] instanceof Array` вернёт `true`
		2. `obj instanceof Object` вернёт `true` для любого объекта
		3. `new Date() instanceof Date` вернёт `true`

## Оператор расширения (spread)

69. Что такое оператор расширения (spread) в JavaScript и для чего он используется?
	- Оператор расширения (`...`) позволяет раскрывать итерируемые объекты (массивы, строки) и объекты в набор отдельных элементов или свойств
	- Используется для:
		1. Копирования массивов и объектов
		2. Объединения массивов и объектов
		3. Передачи элементов массива как отдельных аргументов функции
		4. Создания новых массивов и объектов с добавлением элементов

71. Как работает оператор spread с объектами в JavaScript?
	- Spread для объектов раскрывает свойства объекта в отдельные пары ключ-значение

72. В чём разница между spread и rest операторами в JavaScript?
	- Spread (`...`) - раскрывает итерируемый объект или объект в отдельные элементы/свойства
	- Rest (`...`) - собирает оставшиеся элементы/свойства в массив или объект
	- Spread используется в правой части присваивания, rest - в левой части
	- Примеры:
		1. Spread: `const arr = [...items]` - раскрывает `items`
		2. Rest: `const [first, ...rest] = arr` - собирает оставшиеся элементы в `rest`

73. Какие ограничения и особенности есть у оператора spread?
	- Spread работает только с итерируемыми объектами для массивов (массивы, строки, Set, Map и т.д.)
	- Spread для объектов работает только с перечисляемыми собственными свойствами
	- Spread создаёт поверхностную копию (shallow copy), вложенные объекты копируются по ссылке
	- Spread не может использоваться в объектах без поддержки ES2018
	- Spread не работает с `null` и `undefined` напрямую (нужно оборачивать)

## Деструктуризация

74. Что такое деструктуризация в JavaScript и для чего она используется?
	- Деструктуризация - это синтаксис, позволяющий извлекать значения из массивов или свойств из объектов и присваивать их переменным
	- Используется для:
		1. Упрощения доступа к данным массивов и объектов
		2. Извлечения нескольких значений одновременно
		3. Параметров функций
		4. Обмена значениями переменных

75. Как работает деструктуризация массивов и объектов в JavaScript?
	- Деструктуризация массивов извлекает элементы по позиции (индексу)
	- Деструктуризация объектов извлекает свойства по имен

77. Как использовать значения по умолчанию в деструктуризации?
	- Значения по умолчанию используются, если извлекаемое значение равно `undefined`
	- Для массивов: `const [first = 'default', second = 0] = array`
	- Для объектов: `const {name = 'Unknown', age = 0} = object`
	- Значения по умолчанию вычисляются только если значение отсутствует или равно `undefined`

78. Как работает вложенная деструктуризация в JavaScript?
	- Вложенная деструктуризация позволяет извлекать значения из вложенных структур
	- Для массивов: `const [[first, second], third] = nestedArray`
	- Для объектов: `const {user: {name, age}} = object`
	- Можно комбинировать массивы и объекты: `const {items: [first, second]} = object`

## Прототипы

82. Что такое прототип в JavaScript и как он работает?
	- Прототип - это объект, от которого другие объекты наследуют свойства и методы
	- Каждый объект в JavaScript имеет скрытое свойство `[[Prototype]]`, которое ссылается на его прототип
	- При обращении к свойству или методу объекта, JavaScript сначала ищет его в самом объекте, а если не находит - ищет в прототипе, затем в прототипе прототипа и так далее (цепочка прототипов)
	- Прототипное наследование позволяет объектам наследовать функциональность от других объектов

83. В чём разница между `__proto__` и `prototype` в JavaScript?
	- `prototype` - это свойство функций-конструкторов и классов, которое используется как прототип для объектов, созданных через `new`
	- `__proto__` - это свойство объектов, которое указывает на их прототип (доступ к `[[Prototype]]`)
	- `prototype` существует только у функций, `__proto__` существует у всех объектов
	- `prototype` функции становится `__proto__` объектов, созданных через эту функцию с `new`
	- `__proto__` - устаревший способ доступа, рекомендуется использовать `Object.getPrototypeOf()` и `Object.setPrototypeOf()`

84. Что такое цепочка прототипов (prototype chain) в JavaScript?
	- Цепочка прототипов - это механизм поиска свойств и методов объекта
	- При обращении к свойству JavaScript:
		1. Сначала ищет свойство в самом объекте
		2. Если не находит, ищет в прототипе объекта (`__proto__`)
		3. Если не находит, ищет в прототипе прототипа
		4. Продолжает поиск до тех пор, пока не достигнет `Object.prototype` (конец цепочки)
		5. Если свойство не найдено, возвращает `undefined`
	- Цепочка прототипов позволяет объектам наследовать свойства и методы от других объектов

85. Как работает `Object.prototype` в JavaScript?
	- `Object.prototype` - это корневой прототип для всех объектов в JavaScript
	- Все объекты в конечном итоге наследуют от `Object.prototype`
	- `Object.prototype` содержит базовые методы:
		1. `toString()` - преобразует объект в строку
		2. `valueOf()` - возвращает примитивное значение объекта
		3. `hasOwnProperty()` - проверяет наличие собственного свойства
		4. `isPrototypeOf()` - проверяет, является ли объект прототипом другого
	- `Object.prototype.__proto__` равен `null` (конец цепочки прототипов)

86. Как использовать `Object.create()` для прототипного наследования?
	- `Object.create(proto)` создаёт новый объект с указанным прототипом
	- Позволяет создавать объекты без использования функций-конструкторов
	- Пример: `const child = Object.create(parent)` - создаёт объект `child` с прототипом `parent`
	- Можно передать второй параметр с дескрипторами свойств для создания собственных свойств
	- Более явный и контролируемый способ создания объектов с прототипами

87. Как работают `Object.getPrototypeOf()` и `Object.setPrototypeOf()`?
	- `Object.getPrototypeOf(obj)` - возвращает прототип указанного объекта (современная альтернатива `obj.__proto__`)
	- `Object.setPrototypeOf(obj, proto)` - устанавливает прототип объекта (современная альтернатива `obj.__proto__ = proto`)
	- Рекомендуется использовать эти методы вместо `__proto__`
	- `Object.setPrototypeOf()` может быть медленным, так как изменяет внутреннюю структуру объекта
	- Лучше устанавливать прототип при создании объекта через `Object.create()`

88. Как проверить, является ли свойство собственным или унаследованным?
	- `Object.hasOwnProperty(prop)` - проверяет, является ли свойство собственным (не унаследованным)
	- `Object.hasOwn(obj, prop)` - современная альтернатива `hasOwnProperty()` (ES2022)
	- `prop in obj` - проверяет наличие свойства в объекте или его прототипах
	- `Object.keys()`, `Object.values()`, `Object.entries()` - возвращают только собственные свойства
	- `for...in` перебирает все перечисляемые свойства, включая унаследованные

## Глобальные объекты-конструкторы

89. Что такое глобальные объекты-конструкторы в JavaScript и какие они бывают?
	- Глобальные объекты-конструкторы - это функции-конструкторы, доступные в глобальной области видимости
	- Основные конструкторы:
		1. `Object` - для создания объектов
		2. `Array` - для создания массивов
		3. `Function` - для создания функций
		4. `String` - для создания строк
		5. `Number` - для создания чисел
		6. `Boolean` - для создания булевых значений
		7. `Date` - для работы с датами
		8. `RegExp` - для работы с регулярными выражениями
		9. `Error` - для создания ошибок

90. В чём разница между использованием конструкторов и литералов для создания объектов?
	- Литералы - более краткий и предпочтительный способ создания объектов
	- Конструкторы:
		1. Более многословны: `new Object()` vs `{}`
		2. Могут иметь неожиданное поведение: `new Object(1)` создаёт объект-обёртку, а не число
		3. Медленнее в некоторых случаях
	- Литералы:
		1. Более читабельны: `[]` vs `new Array()`
		2. Более предсказуемы: `[1, 2, 3]` всегда создаёт массив с этими элементами
		3. Рекомендуются в современном JavaScript
	- Исключения: `Date` и `RegExp` обычно создаются через конструкторы

91. Как работает конструктор `Object` в JavaScript?
	- `Object()` - функция-конструктор для создания объектов
	- Вызов `new Object()` создаёт пустой объект, эквивалентный `{}`
	- Можно передать значение: `new Object(value)` создаёт объект-обёртку для примитива
	- `Object()` без `new` также работает и создаёт объект
	- Рекомендуется использовать литерал `{}` вместо `new Object()`

92. Как работает конструктор `Array` в JavaScript?
	- `Array()` - функция-конструктор для создания массивов
	- `new Array(length)` - создаёт массив указанной длины с пустыми элементами
	- `new Array(item1, item2, ...)` - создаёт массив с указанными элементами
	- `Array()` без `new` также работает
	- Особенность: `new Array(3)` создаёт массив длиной 3 с пустыми слотами, а не массив с элементом `3`
	- Рекомендуется использовать литерал `[]` вместо `new Array()`

93. Как работает конструктор `Function` в JavaScript?
	- `Function()` - функция-конструктор для создания функций динамически
	- Синтаксис: `new Function(arg1, arg2, ..., body)` - создаёт функцию с указанными параметрами и телом
	- Созданные функции имеют глобальную область видимости (не создают замыканий)
	- Используется редко, в основном для динамической генерации кода
	- Не рекомендуется использовать из-за проблем с безопасностью и производительностью
	- Лучше использовать `function`, `() => {}` или `eval()` (тоже не рекомендуется)

94. Как работают конструкторы примитивных типов (`String`, `Number`, `Boolean`)?
	- `String()`, `Number()`, `Boolean()` - конструкторы для создания объектов-обёрток примитивов
	- При использовании с `new` создают объекты-обёртки: `new String('text')` создаёт объект, а не строку
	- При использовании без `new` выполняют преобразование типов: `String(123)` возвращает строку `'123'`
	- Объекты-обёртки имеют методы (например, `toUpperCase()`), но ведут себя иначе при сравнении
	- Рекомендуется использовать примитивные значения напрямую, а не через конструкторы
	- JavaScript автоматически оборачивает примитивы в объекты при вызове методов

95. Когда использовать конструкторы, а когда литералы в JavaScript?
	- Использовать литералы для:
		1. Объектов: `{}` вместо `new Object()`
		2. Массивов: `[]` вместо `new Array()`
		3. Строк, чисел, булевых значений: примитивные значения вместо объектов-обёрток
	- Использовать конструкторы для:
		1. `Date` - обычно создаётся через `new Date()`
		2. `RegExp` - можно через `new RegExp()` или литерал `/pattern/`
		3. Кастомных объектов - через `new MyClass()` или `new MyFunction()`
	- Литералы предпочтительнее: они короче, быстрее и более предсказуемы

## Строгий режим (Strict Mode)

96. Что такое строгий режим (`'use strict'`) в JavaScript и для чего он используется?
	- Строгий режим - это способ включения более строгой версии JavaScript, которая помогает выявлять ошибки и предотвращает использование устаревших или небезопасных конструкций
	- Включается директивой `'use strict'` в начале файла или функции
	- Используется для:
		1. Предотвращения случайных ошибок
		2. Улучшения производительности (некоторые оптимизации возможны только в строгом режиме)
		3. Запрета использования устаревших или проблемных конструкций
		4. Упрощения отладки

97. Какие основные отличия строгого режима от обычного режима в JavaScript?
	- В строгом режиме:
		1. Нельзя использовать необъявленные переменные (выбросит `ReferenceError`)
		2. Нельзя удалять неудаляемые свойства (выбросит ошибку)
		3. `this` в функциях равен `undefined` вместо глобального объекта
		4. Нельзя использовать дублирующиеся имена параметров функции
		5. Нельзя использовать восьмеричные литералы (`0123`)
		6. Запрещены некоторые зарезервированные слова как имена переменных
		7. `eval()` не создаёт переменные в окружающей области видимости

98. Как включить строгий режим в JavaScript?
	- Для всего файла: добавить `'use strict'` в самом начале файла (до любых других инструкций)
	- Для функции: добавить `'use strict'` в начале тела функции
	- Классы и модули ES6 всегда работают в строгом режиме автоматически
	- Строгий режим применяется только к коду, который находится после директивы

## Модули (ES6 Modules)

99. Что такое ES6 модули в JavaScript и для чего они используются?
	- ES6 модули - это система организации кода, позволяющая разбивать программу на отдельные файлы (модули)
	- Каждый модуль имеет свою область видимости и может экспортировать и импортировать функциональность
	- Используются для:
		1. Организации кода в логические блоки
		2. Изоляции областей видимости
		3. Переиспользования кода
		4. Управления зависимостями

100. Как работает `export` и `import` в ES6 модулях?
	- `export` - используется для экспорта переменных, функций, классов из модуля
		- Named export: `export const name = 'value'` или `export function func() {}`
		- Default export: `export default function() {}`
	- `import` - используется для импорта функциональности из других модулей
		- Named import: `import { name, func } from './module.js'`
		- Default import: `import defaultFunc from './module.js'`
		- Можно комбинировать: `import defaultFunc, { name } from './module.js'`

101. В чём разница между named export и default export в ES6 модулях?
	- Named export:
		1. Может быть несколько в одном модуле
		2. Импортируется с фигурными скобками: `import { name } from './module.js'`
		3. Имя при импорте должно совпадать с именем при экспорте
		4. Можно переименовать: `import { name as newName } from './module.js'`
	- Default export:
		1. Может быть только один в модуле
		2. Импортируется без фигурных скобок: `import defaultFunc from './module.js'`
		3. Можно дать любое имя при импорте
		4. Используется для главной функциональности модуля

102. Как работает динамический импорт (`import()`) в JavaScript?
	- `import()` - функция для динамической загрузки модулей во время выполнения
	- Возвращает промис, который разрешается объектом модуля
	- Синтаксис: `const module = await import('./module.js')`
	- Используется для:
		1. Условной загрузки модулей
		2. Ленивой загрузки (lazy loading)
		3. Загрузки модулей по требованию
		4. Оптимизации производительности

103. В чём разница между CommonJS и ES6 модулями?
	- CommonJS (Node.js):
		1. Использует `require()` и `module.exports`
		2. Синхронная загрузка модулей
		3. Работает в Node.js по умолчанию
		4. Динамический импорт
	- ES6 модули:
		1. Использует `import` и `export`
		2. Статический анализ зависимостей (на этапе компиляции)
		3. Работает в браузерах и современных версиях Node.js
		4. Поддерживает как статический, так и динамический импорт
		5. Всегда работают в строгом режиме

## JSON

104. Что такое JSON в JavaScript и для чего он используется?
	- JSON (JavaScript Object Notation) - это текстовый формат для обмена данными
	- Основан на синтаксисе JavaScript, но является независимым форматом
	- Используется для:
		1. Передачи данных между клиентом и сервером
		2. Хранения конфигурационных данных
		3. Сериализации и десериализации объектов
		4. Обмена данными между различными системами

105. Как работают `JSON.parse()` и `JSON.stringify()` в JavaScript?
	- `JSON.parse(str)` - преобразует JSON-строку в JavaScript объект
		- Принимает JSON-строку и возвращает объект, массив или примитивное значение
		- Выбрасывает `SyntaxError` если строка не является валидным JSON
	- `JSON.stringify(obj)` - преобразует JavaScript объект в JSON-строку
		- Принимает объект и возвращает JSON-строку
		- Игнорирует функции, `undefined`, `Symbol` и свойства с `undefined` значениями

106. Какие ограничения есть у JSON в JavaScript?
	- JSON поддерживает только определённые типы данных:
		1. Объекты и массивы
		2. Строки (в двойных кавычках)
		3. Числа
		4. Булевы значения (`true`, `false`)
		5. `null`
	- Не поддерживает:
		1. `undefined` (игнорируется или преобразуется в `null`)
		2. Функции (игнорируются)
		3. `Symbol` (игнорируются)
		4. `Date` (преобразуется в строку)
		5. Циклические ссылки (выбросит ошибку)

107. Как использовать параметры `replacer` и `reviver` в JSON методах?
	- `replacer` в `JSON.stringify()`:
		1. Функция или массив для фильтрации или преобразования свойств
		2. Функция вызывается для каждого свойства: `(key, value) => value`
		3. Массив указывает, какие свойства включить
	- `reviver` в `JSON.parse()`:
		1. Функция для преобразования значений при парсинге
		2. Вызывается для каждого свойства: `(key, value) => value`
		3. Позволяет восстановить специальные типы (например, `Date`)

## Иммутабельность и мутабельность

114. Что такое иммутабельность и мутабельность в JavaScript?
	- Иммутабельность (immutability) - свойство данных, которые нельзя изменить после создания
	- Мутабельность (mutability) - свойство данных, которые можно изменять после создания
	- Примитивные типы (string, number, boolean, null, undefined, symbol, bigint) - иммутабельны
	- Ссылочные типы (объекты, массивы, функции) - мутабельны

116. Как сделать объект иммутабельным в JavaScript?
	- `Object.freeze(obj)` - замораживает объект, делая его иммутабельным
		1. Запрещает добавление, удаление и изменение свойств
		2. Поверхностное замораживание - вложенные объекты остаются мутабельными
	- `Object.seal(obj)` - запечатывает объект
		1. Запрещает добавление и удаление свойств
		2. Позволяет изменять существующие свойства
	- `Object.preventExtensions(obj)` - запрещает добавление новых свойств
	- Для глубокого замораживания нужно рекурсивно применять `Object.freeze()`
