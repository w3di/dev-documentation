1. Что такое переменные в JavaScript, и как они работают?
	- это именованные контейнеры, используемые для хранения данных

2. В чём различия между `var`, `let` и `const` в JavaScript?
	1. `var`: область видимости функциональная
	2. `let` и `const`: область видимости блочная
	3. `var`: можно переобъявлять в одной области видимости
	4. `var`: `hoisting` 
	5. `let` и `const`: `TDZ` 
	6. `var` и `let`: можно объявить без инициализации
	7. `var` и `let`: значения изменяемы (mutable)
	8. `const`: ссылка неизменяема (immutable), но содержимое объектов и массивов может изменяться (mutable)

3. Что такое `Temporal Dead Zone` и Hoisting? На какие сущности распространяется `TDZ` а на какие `hoisting`?
	- Hoisting – это механизм при котором интерпретатор во время фазы компиляции определяет все объявления переменных и функций и регистрирует их в соответствующей области видимости до начала выполнения кода
		1. `var` - происходит инициализация значением `undefined` в начале выполнения кода
		2.  `function declaration` полностью определяется в начале
	- `Temporal Dead Zone` - это период времени в процессе исполнения кода, когда переменная, объявленная через `let` или `const`, уже определена во внутренней структуре области видимости, но ещё не инициализирована
	- `TDZ` распространяется на `const` `let` и Class

4. Что такое область видимости (`scope`) и какие типы области видимости существуют в JavaScript?
	- Область видимости - это контекст, в рамках которого определяются и становятся доступными переменные, функции и другие объекты
	- типы областей видимости
		1. глобальная - доступна во всём коде, переменные видимы в любом месте программы
		2. функциональная - переменные доступны только внутри функции, где они были объявлены
		3. блочная - переменные доступны только внутри блока {}, где они объявлены
		4. модульная - переменные и функции доступны только внутри модуля, если они не экспортированы
		5. лексическая - это механизм, который определяет доступность переменных на основании их расположения в коде во время его написания. Она описывает правила взаимодействия между вложенными областями видимости.
			- Дочерние области видимости могут получать доступ к переменным родительских областей.
			- Родительские области видимости не имеют доступа к переменным дочерних областей

5. Что такое `Lexical Environment` и `Scope Chain`, и как они работают?
	- `Lexical Environment` - это структура которая состоит из 
		- Environment Record - информации о переменные и функции, объявленные в данном контексте или области видимости
		- сcылку на родительский `Lexical Environment`
	- `Scope Chain` - это механизм, с помощью которого интерпретатор выполняет поиск переменных и функций, начиная с текущего `Lexical Environment` и последовательно переходя к его родительским окружениям, вплоть до глобального `Lexical Environment`.

6. Какие типы данных существуют в JavaScript и чем отличаются примитивные и ссылочные типы данных?
	1. Примитивные хранятся непосредственно, они имутабельные сравниваются по значние и хрянятся в стеке
	2. Ссылочные хранятся по ссылки, они мутабельные сравниваются по ссылке и хранятся в куче, а ссылка на него в стеке

7. Какие типы данных в JavaScript являются примитивными?
	1. `string`
	2. `number`
	3. `bigInt`
	4. `undefined`
	5. `null`
	6. `symbol`
	7. `boolean`

8. Что такое `Symbol` и для чего они используются в JavaScript?
	- уникальность и неизменность примитивный тип данных 
	- уникальные ключи для объектов
	- создание скрытых свойств
	- уникальные идентификаторы

9. Как работает `BigInt` и для чего он нужен?
	- для работы с целыми числами которые выходят за границы обычного `number`
	- несовместим без приведения типов с `number`
	- Для обозначения числа как `BigInt`, необходимо добавить суффикс n

10. В чем разница между `null` и `undefined`?
	- `null` для явного указания пустоты или обнуление
	- `undefined` когда не присвоено значение или у объекта отсутствует свойство
11. Когда и почему можно ожидать значение `undefined`?
	1. Обращение к переменной, объявленной через `var` до её инициализации:
	2. Функции, которые ничего не возвращают
	3. Переменные, объявленные с помощью `let` без инициализации
	4. Обращение к несуществующему свойству объекта
	5. Неинициализированные параметры функции
	6. Элементы массива, которым не присвоено значение
	7. Деструктуризация без соответствующего значения

12. В чём разница между `Number.isNaN`() и `isNaN`() в JavaScript, и какой предпочтительнее использовать?
	- `isNaN`() - пытается преобразовать переданный аргумент в число перед проверкой
	- `Number.isNaN`() безя преобразовагтя проверяет переданный аргумент

13. Что вернёт `typeof` для `null`, и что вернёт `typeof` для функции? Почему?
	- `object` так как исторической особенностью JavaScript 
	- `function`

14. Что такое приведение типов (`type coercion`) и явное преобразование (`type conversion`) в JavaScript? Примеры каждого?
	- Приведение типов(`type coercion`, неявное преобразование) — это автоматическое преобразование **'5' + 2 → '52', '5' - 2 → 3**
	- Преобразование типов (Type Conversion, явное преобразование) — это явное преобразование Number('5') → 5, String(123) → '123'

15. Какие значения  при приведении к булевому типу (`boolean`) возвращают false?
	1. `0`
	2. `0n`
	3. `''`
	4. `undefined`
	5. `null`
	6. `NaN`

16. В чём разница между глубоким (deep) и поверхностным (shallow) копированием объектов в JavaScript?
	- Глубокое копирование копирует все уровни вложенности так что изменения в копии **не затрагивают** оригинальный объект.
	- Поверхностное копирование копирует только верхний уровень объекта, при этом вложенные объекты и массивы копируются по ссылке и ссылки на вложенные структуры сохраняются.

17. Что такое `Map` в JavaScript, чем он отличается от обычного объекта и от Weak`Map`?
	- `Map` это  объект который представляет собой коллекцию пар ключ-значение
	- Отличие от обычного объекта:
		1. ключи могут быть любого типа
		2. порядок вставки ключей сохраняется
		3. оптимизирован для операций поиска вставки и удаления по ключ
	- Отличие `Map` от `WeakMap`
		1. В `WeakMap` ключами могут быть только объекты
		2. В `WeakMap` нет методов для перечисления ключей или значений (keys(), values(), entries())
		3. Ключи в `WeakMap` являются "слабыми ссылками". Если на объект-ключ больше нет ссылок из других мест программы, он автоматически удаляется из Weak`Map` при сборке мусора

18. Что такое `Set` в JavaScript, для каких задач он используется и чем отличается от `WeakSet`?
	- `Set` это  объект который представляет собой коллекцию уникальных значений любого типа.
	- `WeakSet` хранит только объекты
	- У `WeakSet` нет методов для итерации (`forEach`, keys, values и т.д.), так как элементы могут удаляться динамически.
	- `WeakSet` **не предотвращает сборку мусора**. Если объект больше не доступен в коде, он удаляется из `WeakSet` автоматически.

19. Как устроено прототипное наследование в JavaScript и как оно работает?
	- через `__proto__` - ссылка на объект прототипа

20. Что такое функции в JavaScript и для чего они используются?
	- функция - это блок кода, который выполняет определённую задачу, и её можно многократно вызывать в разных частях кода.
21. Какие существуют способы объявления функций в JavaScript и чем они отличаются?
	1. `Function Declaration`
	2. `Function Expression`
	3. `Arrow Function`
	4. `IIFE`

22. Что такое анонимные функции, и какие из способов объявления функций поддерживают их?
	- Это функция без имени, которая создается в моменте и используется сразу в нужном контексте, например, для передачи в качестве аргумента, колбэка или внутри методов.
	- поддерживается:
		1. `Function Expression`
		2. `Arrow Function`
		3. `IIFE`

23. Какие способы объявления функций поднимаются механизмом `hoisting` и как именно?
	- все способы объявления функций поддерживают `hoisting`, но для способов отличных от  `Function Declaration` применяется еще `TDZ`

24. В чём отличие функций‑конструкторов от классов в JavaScript?
	1. классы это синтаксический сахар
	2. на классы распространятеся `TDZ` в отлчии от функции-конструкторы который инициилизруются сразу
	3. Class всегда работает в строгом режиме

25. Что такое стрелочные функции в JavaScript и чем они отличаются от обычных функций?
	- Стрелочные функции - это синтаксический сахар для более короткого определения функций. Они имеют ряд особенностей, таких как отсутствие своего `this`, `arguments` и поддерживают `TDZ`

26. Что такое Immediately Invoked `Function Expression` (`IIFE`) и для чего она используется?
	- `IIFE` - это функция, которая определяется и немедленно вызывается. Она используется для создания изолированной области видимости

27. Что такое функции-генераторы в JavaScript?
	- вид функций, позволяющий приостанавливать и возобновлять их выполнение, а также возвращать промежуточные значения в процессе работы

28. Что такое функции обратного вызова (`callback`) в JavaScript и зачем они нужны?
	- это функции, которые передаются в качестве аргумента другой функции и вызываются внутри этой функции после выполнения определённого действия или при наступлении определённого события.

29. Что такое мемоизация функций и в каких случаях она полезна?
	- техника оптимизации, при которой результаты вызова функции запоминаются в зависимости от переданных аргументов.
	- Трудоёмкие вычисления, повторяющиеся вызовы и тд

30. Что означает, что функции в JavaScript — объекты первого класса (first‑class)?
	- это функции, которые можно:
		1. Присваивать переменной.
		2. Передавать в качестве аргумента другой функции.
		3. Возвращать из другой функции.
31. Что такое рекурсия и когда её применять на практике?
	- функция вызывает сама себя

32. Что такое объект `arguments` в JavaScript и в каких способах объявления он недоступен? Почему?
	- это встроенный в функции объект, который содержит массивоподобный список всех аргументов, переданных в функцию
	- не поддерживается в `arrow function`, лучше использовать `rest-параметры` (остаточный оператор)

33. Что такое rest‑параметры и оператор расширения (spread) в JavaScript и как их использовать?
	- `Rest-параметры` позволяют объявить функцию, которая может принимать любое количество аргументов, сгруппированных в один массив, аналог `arguments` 
	- `Spread-оператор` — позволяет раскрыть итерируемый объект в набор отдельных элементов или свойств там, где ожидается перечисление значений

34. Что представляет собой ключевое слово `this` и как определяется его контекст в разных ситуациях?
	- `this` представляет собой ссылку на текущий контекст выполнения, который определяется способом вызова функции
	1. В глобальной области видимости.
		1. строгом режиме равен `undefined`
		2. браузера им является объект `window`
		3. в среде Node.js – объект global
	1. В методе объекта.
		- на контекст объекта
	1. В функции-конструкторе.
		- на контекст объекта созданный этой функцией оператором new
	1. В стрелочных функциях.
		- на контекст родителя

35. Что такое замыкание (`closure`) и как оно работает?
	- замыкание - это механизм, при котором функция запоминает свое лексическое окружение, то есть контекст, в котором она была создана, и сохраняет доступ к этим переменным даже после завершения выполнения внешней функции, из которой она была вызвана.

36. В чем разница между методами `call`(), `apply`() и `bind`() в JavaScript, и когда использовать каждый из них?
	- Методы `call`(), `apply`() и `bind`() в JavaScript используются для управления контекстом вызова функции
	- `call`() - вызывает функцию немедленно, с указанным значением `this` и переданными аргументами по отдельности.
	- `apply`() - вызывает функцию немедленно, с указанным значением `this` и переданными аргументами в виде массива.
	- `bind`() возвращает новую функцию с указанным значением `this` и фиксированными аргументами (если они переданы), в отличии от других методов функция не вызывается сразу и может быть вызвана в дальнейшем уже с изменым контекстом

37. В чём разница между синхронным и асинхронным кодом в JavaScript?
	- Синхронный код
		- Выполняется последовательно, инструкция за инструкцией
		- блокирует выполнение дальнейшего кода до завершения текущей операции
	- Асинхронный код
		- операции выполняются в фоне, позволяя основному потоку продолжать выполнение без блокировки

38. Что такое `Event Loop` в JavaScript и как он работает?
	- `Event Loop` - механизм, обеспечивающий выполнение асинхронного кода в однопоточном окружении
	- как работает:
		1. Выполняется весь синхронный код
		2. Выполняются все задачи из очереди микрозадач
		3. Берется первая задача из очереди макрозадач и выполняется
		4. При необходимости обновляется пользовательский интерфейс
		5. Цикл возвращается к обработке очереди микрозадач
		- При отсутствии задач `Event Loop` продолжает ожидание новых событий

39. Что такое стек вызовов (`Call Stack`) и как он взаимодействует с асинхронным кодом?
	- `Call Stack` - это структура данных, используемая движком JavaScript для отслеживания выполнения функций в программе. Он работает по принципу **LIFO (Last In, First Out)**, то есть последняя вызванная функция обрабатывается первой.

40. Что такое очереди задач: `macrotasks` и `microtasks`, и как они влияют на порядок выполнения кода?
	- Когда асинхронная задача попадает в **`Call Stack`**, она передается во внешнюю систему, которая после завершения добавляет её `callback` в macroTasks Queue или microTasks Queue. Когда `Call Stack` становится пустым, сначала обрабатываются задачи из macroTasks Queue, а затем из microTasks Queue
41. Приведите примеры микрозадач (`microtasks`) и макрозадач (`macrotasks`) в JavaScript?
	- MicroTasks:
		1. .`then()` .`catch()`  .`finally()`
		2. MutationObserver
		3. queueMicrotask()
	- Macrotasks:
		1. `setTimeout` `setInterval`
		2. `DOM` Events
		3. setImmediate
		4. Сетевые запросы

42. Как работают setImmediate() и queueMicrotask() и чем они отличаются?
	- setImmediate(): помещает задачу в очередь макрозадач
	- queueMicrotask(): помещает задачу в очередь микрозадач

43. Что такое промисы (`Promise`) в JavaScript и какие у них есть состояния?
	- `Promise` — это объект в JavaScript, который представляет результат асинхронной операции 
	- у него есть 3 состояния
		1. ожидание (`pending`)
		2. выполнено (`fulfilled`)
		3. отклонено (`rejected`)

44. Как работают `Promise.all()`, `Promise.allSettled()`, `Promise.race()` и `Promise.any()`? Какие есть дополнительные статические методы промисов?
	- `Promise.all()` — ждет выполнения всех промисов, прерывается, если один промис отклонен
	- `Promise.allSettled()` — ждет завершения всех промисов в независимости от их статуса
	- `Promise.race()` — возвращает первый выполненный промис.
	- `Promise.any()` — возвращает первый выполненный успешно промис, игнорируя ошибки
	- `Promise.reject()` - cоздает промис, который немедленно переходит в состояние **`rejected`** с указанной причиной ошибки
	- `Promise.resolve()` - cоздает промис, который немедленно переходит в состояние **`fulfilled`** с указанным значением
	- `Promise.withResolvers()` - синтаксического сахар,  статический метод, который создает новый промис и одновременно возвращает объект, содержащий
		1. сам promise,
		2. функцию resolve для его успешного завершения,
		3. функцию reject для его отклонения.
	- `Promise.try()` - синтаксического сахар, способ безопасно «обернуть» синхронный код, который может выбросить ошибку, в `Promise`, аналог `Promise.resolve()`.`then`(() => {})

45. Как работает метод .`then()` у промисов и что он возвращает?
	- Метод .`then()` для обработки выполнения промиса, возвращает новый промис.
	- Он принимает два аргумента:
		1. onFulfilled — функция, выполняемая при успешном разрешении промиса.
		2. onRejected (опционально, типа `catch`, но как аргумент `then`) — функция для обработки ошибок.

46. Какие механизмы обработки ошибок есть в JavaScript? Как работает `try...catch` и что делает `finally`?
	- механизмы обработки ошибок
		1. аргумент onRejected в .`then()`
		2. try...`catch`
		3. throw
		4. Обработка ошибок с помощью `Promise` и `catch()`
	- `try...catch...finally`
		1. `try()` - Включает код, выполнение которого может вызвать ошибку
		2. `catch()` - Срабатывает только в том случае, если в try блоке возникает ошибка
		3. `finally()` - Выполняется всегда, независимо от того, была ли ошибка или нет

47. Что такое объект `Error` в JavaScript и какие его свойства чаще всего используются (`message`, `name`, `stack`)?
	- Объект `Error` в  предназначен для создания ошибок и их обработки
	- Основные свойства объекта `Error`
		1. `message`  -  текстовое сообщение об ошибке, переданное в конструктор объекта.
		2. `name` - имя ошибки, по умолчанию это `Error`.
		3. `stack`  - информацию о стеке вызовов.

48. Что такое `async`/`await` и как они работают с промисами?
	- синтаксический сахар для работы с промисами
	- `async` Делает функцию асинхронной, что позволяет использовать внутри неё `await` и возвращает всегда promis
	- `await` приостанавливает выполнение асинхронной функции до разрешения промиса и возвращает его результат

49. Как работают таймеры `setTimeout` и `setInterval` и чем они отличаются?
	- `setTimeout` - запускает функцию один раз после указанного времени задержки
		- очистка - `clearTimeout`
	- `setInterval` - запускает функцию периодически с указанным интервалом времени до тех пор, пока таймер не будет остановлен
		- очистка - `clearInterval`

50. Что такое `callback` hell (pyramid of doom) и как с ним бороться?
	- несколько вложенных обратных вызовов создают сложный код с глубокими отступами
	- Решение:
		1. `async`/`await`
		2. promises
		3. модульность
51. Что такое состояние гонки (`race condition`) и как его избегать в JavaScript?
	ситуация, возникающая при параллельном выполнении операций, когда результат зависит от неконтролируемого порядка их завершения
52. Что такое дебаунсинг (`debouncing`) и троттлинг (`throttling`) и когда их применять?
	- это техники оптимизации для обработки событий
	- Debouncing - предотвращает выполнение функции, пока события происходят часто, и позволяет её вызвать только один раз, через заданную задержку после того, как поток событий прекратился.
	- Throttling - позволяет функции выполняться регулярно, но не чаще, чем раз в заданный интервал времени, даже если события происходят беспрерывно.
53. Что такое цепочка промисов (`promise chaining`) и зачем она нужна?
	- техника последовательного выполнения асинхронных операций с использованием цепочки промисов. Каждый .`then` передаёт результат следующему обработчику.
54. Что такое «`deadlock`» (взаимная блокировка) и почему в JavaScript такое встречается редко?
	- ситуация, при которой два или более процесса ждут друг друга, блокируя выполнение всех операций
	- Избежание:
		1. Упорядочивание захватов блокировок.
		2. Использование таймаутов при ожидании блокировок.
		3. Минимизация использования блокировок.
55. Какие методы массивов (`map`, `filter`, `reduce` и др.) используются для работы с данными и чем они полезны?
	- `map` - Применяет функцию к каждому элементу массива и возвращает новый массив с результатами.
	- `forEach` - Применяет функцию для каждого элемента массива, но ничего не возвращает
	- filtred - создает новый массив, содержащий только элементы, которые удовлетворяют заданному условию.
	- `reduce` - преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору
	- `reduce`Right - аналогичен `reduce`, но обход массива выполняется справа налево.
	- `find` - возвращает первый элемент массива, который удовлетворяет заданному условию, или `undefined`, если такого элемента нет.
	- `find`Index - возвращает индекс первого элемента, который удовлетворяет заданному условию, или -1, если такого элемента нет.
	- `indexOf` - возвращает первый индекс указанного элемента в массиве или -1, если элемент не найден.
	- `lastIndexOf` - возвращает последний индекс указанного элемента в массиве или -1, если элемент не найден.
	- `includes` - проверяет, содержит ли массив указанный элемент, возвращает true или false.
	- `some` - возвращает true, если хотя бы один элемент массива удовлетворяет условию.
	- `every` - возвращает true, если все элементы массива удовлетворяют условию.
56. Чем отличается `forEach` от `map` и когда использовать каждый?
	- `forEach` - выполнить какую-либо операцию над элементами массива
	- `map` - возвращает новый массив с преобразованными данными.
57. Что делает метод `reduce` и когда он может заменить другие методы работы с массивами?
	- преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору
58. Чем отличается копирование массива с помощью `slice`, оператора spread и `Array.from`()?
	- `slice` - позволяет копировать часть массива (подмассив) с указанием границ индексов.
	- spread-оператора - поддерживает объединение массивов и добавление новых элементов в процессе копирования.
	- `Array.from`() - работает с массивоподобными объектами (например, `arguments` или `DOM`-коллекциями) и позволяет преобразовывать элементы при копировании.
59. Что такое `DOM` и как он представляет структуру HTML‑документа?
	- `Document Object Model` - это представление HTML-документа в виде структуры дерева. Каждый элемент HTML (тег) становится узлом дерева. `DOM` позволяет взаимодействовать с HTML-документом, изменять его структуру, содержимое и стили при помощи JavaScript
60. Сколько существует типов узлов `DOM` и какие это типы?
	- 12 типов узлов 
		1. `Element Node`
		2. `Text Node`
		3. `Comment Node`
		4. ....
61. Какие фазы распространения события в `DOM` существуют и что происходит на каждой?
	1. Фаза захвата (`Capturing phase`) - Событие распространяется сверху вниз по дереву `DOM`, начиная с корневого элемента (`window`) и проходя через всех предков целевого элемента.
	2. Фаза цели (`Target phase`) - Событие достигает целевого элемента, на котором оно произошло. Обработчики, привязанные к целевому элементу, выполняются.
	3. Фаза всплытия (`Bubbling phase`) - Событие поднимается обратно вверх по дереву `DOM` от целевого элемента к его предкам.
62. Что такое `CSSOM` и чем он отличается от `DOM`?
	- `CSS Object Model` - это объектная модель CSS, которая представляет стили CSS в виде структуры дерева. `CSSOM` создается браузером при разборе CSS-стилей (как встроенных, так и внешних). Она позволяет JavaScript взаимодействовать с CSS — например, получать или изменять стили элементов на странице.
63. Как связаны `DOM` и `CSSOM` и как вместе используются браузером?
	- `DOM` и `CSSOM` объединяются для создания render-three которое уже используется  для отрисовки страницы
64. Как оптимизировать работу `DOM` и `CSSOM` для повышения производительности?
	- `DOM` 
		1. минимизация количества узлов и элементов
		2. применять изменения в дереве разом для всего а не по одному
		3. использования lazy loading
	- `CSSOM` 
		1. удаление ненужных стилей
		2. уменьшения css файлов
		3. минимизицаия сложности селекторов
65. Что такое `reflow`, `repaint` и `compositing` в браузере и чем они отличаются? Примеры?
	- Reflow, Repaint, Compositing - процессы, связанные с рендерингом веб-страницы, которые происходят при изменениях в `DOM` и `CSSOM`.
	- Reflow -  процесс, при котором браузер пересчитывает размеры и расположение элементов на странице
	- Repaint - процесс, при котором браузер обновляет визуальное представление элементов без изменения их геометрии
	- Compositing - процесс, при котором браузер объединяет слои, сформированные после рендеринга, в окончательную визуализацию страницы, чтобы отобразить её на экране.
66. Что такое Shadow `DOM` и для чего он используется?
	- технология, которая позволяет создавать инкапсулированные `DOM`-деревья в веб-компонентах.
67. Какие проблемы решает Shadow `DOM` (инкапсуляция стилей, изоляция, переиспользование)?
	1. Конфликты стилей
	2. модульность?
	3. изоляция
68. Что такое `BOM` (`Browser Object Model`) и какие возможности он предоставляет?
	- `Browser Object Model` -  интерфейс, предоставляемый браузером для взаимодействия с окном браузера и его функциями
69. Какие основные компоненты `BOM` существуют и для чего они?
	- компоненты
		1. `window`
		2. `document`
		3. `navigator`
		4. `location`
		5. `history`
70. Что такое `render tree` и как он строится на основе `DOM` и `CSSOM`?
	1. Браузер комбинирует `DOM` и `CSSOM`, чтобы построить Render Tree. 
	2. Render Tree включает только видимые элементы и их стили: 
	3. Элементы с display: none исключаются из Render Tree.
	4. Элементы с visibility: hidden остаются в Render Tree, так как занимают место, но не видимы.
	5. Если `DOM` или `CSSOM` изменяются (например, через JavaScript), Render Tree пересчитывается.
71. Как браузер рендерит документ: этапы от получения байтов до отображения?
	1. Получает данные (байты) от сервера.
	2. Разбирает и преобразует в токены (<, ИмяТега, Атрибут, ЗначениеАтрибута, >).
	3. Превращает токены в узлы.
	4. Превращает узлы в дерево `DOM`.
	5. Создаёт дерево `CSSOM` из правил CSS.
	6. Деревья `CSSOM` и `DOM` объединяются в дерево рендеринга (RenderTree).
	7. Вычисляет, какие элементы видимы и их вычисленные стили:
		1. Начиная с корня дерева `DOM`
		2. Невидимые элементы, такие как (meta, script, link) и display: none, исключаются из дерева рендеринга
		3. Для каждого видимого узла находит соответствующие правила `CSSOM` и применяет их
	8. Reflow: вычисляет макет каждого видимого элемента (положение и размер)
	9. Repaint: рендерит пиксели на экране
	10. Compositing:
		1. После Repaint браузер объединяет различные слои (например, слои с эффектами, анимацией, позиционированными элементами) в итоговый кадр
		2. Логика композитинга может включать отрисовку слоёв в правильном порядке, обработку прозрачности, тени и других визуальных эффектов
		3. Завершается отправкой кадра на `GPU` для отображения