1. Что такое переменные в JavaScript, и как они работают?
	1. это именованные контейнеры, используемые для хранения данных
2. Какие различия между var, let и const?
	- var: область видимости функциональная
	- let и const: область видимости блочная
	- var: можно переобъявлять в одной области видимости
	- var:hoisiting 
	- let и const: TDZ 
	- var и let: можно объявить без инициализации
	- var и let: значения изменяемы (mutable)
	- const: ссылка неизменяема (immutable), но содержимое объектов и массивов может изменяться (mutable)
3. Что такое Temporal Dead Zone и Hoisting? На какие сущности распространяется TDZ а на какие hoisting?
	1. Hoisting – это механизм при котором интерпретатор во время фазы компиляции определяет все объявления переменных и функций и регистрирует их в соответствующей области видимости до начала выполнения кода
		1. var - происходит инициализация значением undefined в начале выполнения кода
		2. function declaration полностью определяется в начале
	2. Temporal Dead Zone - это период времени в процессе исполнения кода, когда переменная, объявленная через let или const, уже определена во внутренней структуре области видимости, но ещё не инициализирована
	3. TDZ распространяется на const let и Class
4. Что такое область видимости (scope) и какие типы области видимости существуют в JavaScript?
	4. Область видимости - это контекст, в рамках которого определяются и становятся доступными переменные, функции и другие объекты
	5. типы областей видимости
		1. глобальная - доступна во всём коде, переменные видимы в любом месте программы
		2. функциональная - переменные доступны только внутри функции, где они были объявлены
		3. блочная - переменные доступны только внутри блока {}, где они объявлены
		4. модульная - переменные и функции доступны только внутри модуля, если они не экспортированы
		5. лексическая - это механизм, который определяет доступность переменных на основании их расположения в коде во время его написания. Она описывает правила взаимодействия между вложенными областями видимости.
			1. Дочерние области видимости могут получать доступ к переменным родительских областей.
			2. Родительские области видимости не имеют доступа к переменным дочерних областей
5. Что такое Lexical Environment и Scope Chain, и как они работают?
	1. Lexical Environment - это структура которая состоит из 
		1. Environment Record - информации о переменные и функции, объявленные в данном контексте или области видимости
		2. сcылку на родительский Lexical Environment
	2. Scope Chain - это механизм, с помощью которого интерпретатор выполняет поиск переменных и функций, начиная с текущего Lexical Environment и последовательно переходя к его родительским окружениям, вплоть до глобального Lexical Environment.
6. Какие типы данных существуют в JavaScript и чем отличаются примитивные и ссылочные типы данных?
	1. Примитивные хранятся непосредственно, они имутабельные сравниваются по значние и хрянятся в стеке
	2. ссылочные хранятся по ссылки, они мутабельные сравниваются по ссылке и хранятся в куче, а ссылка на него в стеке
7. Какие типы данных в JavaScript являются примитивными?
	1. string
	2. number
	3. bigInt
	4. undefined
	5. null
	6. symbol
	7. boolean
8. Что такое Symbol и для чего они используются в JavaScript?
	8. уникальность и неизменность примитивный тип данных 
	9. уникальные ключи для объектов
	10. создание скрытых свойств
	11. уникальные идентификаторы
9. Как работает BigInt и для чего он нужен?
	1. для работы с целыми числами которые выходят за границы обычного number
	2. несовместим без приведения типов с number
	3. Для обозначения числа как BigInt, необходимо добавить суффикс n
10. В чем разница между null и undefined?
	4. null для явного указания пустоты или обнуление
	5. undefined когда не присвоено значение или у объекта отсутствует свойство
11. Когда и почему можно ожидать значение undefined?
	1. Обращение к переменной, объявленной через var до её инициализации:
	2. Функции, которые ничего не возвращают
	3. Переменные, объявленные с помощью let без инициализации
	4. Обращение к несуществующему свойству объекта
	5. Неинициализированные параметры функции
	6. Элементы массива, которым не присвоено значение
	7. Деструктуризация без соответствующего значения
12. В чем различие между Number.isNaN() и isNaN(), и какой из них предпочтительнее использовать?
	8. isNaN() - пытается преобразовать переданный аргумент в число перед проверкой
	9. Number.isNaN() безя преобразовагтя проверяет переданный аргумент
13. Что выведет console.log(typeof null) и почему? Что выведет function example() {} console.log(typeof example)
	1. object тк исторической особенностью JavaScript 
	2. function
14. Что такое приведение типов (type coercion) и преобразование типов (type conversion)? Приведите примеры каждого.
	1. Приведение типов(type coercion, неявное преобразование) — это автоматическое преобразование **'5' + 2 → '52', '5' - 2 → 3**
	2. Преобразование типов (Type Conversion, явное преобразование) — это явное преобразование Number('5') → 5, String(123) → '123'
15. Какие значения  при приведении к булевому типу (boolean) возвращают false?
	1. 0
	2. 0n
	3. ''
	4. undefined
	5. null
	6. NaN
16. В чем разница между глубоким (deep) и поверхностным (shallow) копированием объектов?
	6. Глубокое копирование копирует все уровни вложенности так что изменения в копии **не затрагивают** оригинальный объект.
	7. Поверхностное копирование копирует только верхний уровень объекта, при этом вложенные объекты и массивы копируются по ссылке и ссылки на вложенные структуры сохраняются.
17. Что такое объект Map и как он отличается от обычного объекта? Чем отличается от WeakMap?
	1. Map это  объект который представляет собой коллекцию пар ключ-значение
	2. Отличие от обычного объекта:
		1. ключи могут быть любого типа
		2. порядок вставки ключей сохраняется
		3. оптимизирован для операций поиска вставки и удаления по ключ
	3. Отличие Map от WeakMap
		1. В WeakMap ключами могут быть только объекты
		2. В WeakMap нет методов для перечисления ключей или значений (keys(), values(), entries())
		3. Ключи в WeakMap являются "слабыми ссылками". Если на объект-ключ больше нет ссылок из других мест программы, он автоматически удаляется из WeakMap при сборке мусора
18. Что такое объект Set и для каких задач он используется? Чем отличается от WeakSet?
	4. Set это  объект который представляет собой коллекцию уникальных значений любого типа.
	5. WeakSet хранит только объекты
	6. У WeakSet нет методов для итерации (forEach, keys, values и т.д.), так как элементы могут удаляться динамически.
	7. WeakSet **не предотвращает сборку мусора**. Если объект больше не доступен в коде, он удаляется из WeakSet автоматически.
19. Как реализуется прототипное наследование в js?
	1. через __proto__ - ссылка на объект прототипа
20. Что такое функции и для чего они используются?
	2. функция - это блок кода, который выполняет определённую задачу, и её можно многократно вызывать в разных частях кода.
21. Какие существуют способы объявления функций в JavaScript?
	1. Function Declaration
	2. Function Expression
	3. Arrow Function
	4. IIFE
22. Что такое анонимные функции, и какие из способов объявления функций поддерживают их?
	1. Это функция без имени, которая создается в моменте и используется сразу в нужном контексте, например, для передачи в качестве аргумента, колбэка или внутри методов.
	2. поддерживается:
		1. Function Expression
		2. Arrow Function
		3. IIFE
23. Какие способы объявления функций поддерживают hoisting?
	1. все способы объявления функций поддерживают hoisting, но для способов отличных от  Function Declaration применяется еще TDZ
24. Чем функции-конструкторы отличаются от классов?
	2. классы это синтаксический сахар
	3. на классы распространятеся TDZ в отлчии от функции-конструкторы который инициилизруются сразу
	4. Class всегда работает в строгом режиме
25. Что такое стрелочные функции, и в чем их особенности по сравнению с обычными функциями?
	1. Стрелочные функции - это синтаксический сахар для более короткого определения функций. Они имеют ряд особенностей, таких как отсутствие своего this, arguments и поддерживают TDZ
26. Что такое Immediately Invoked Function Expression (IIFE) и для чего она используется?
	2. IIFE - это функция, которая определяется и немедленно вызывается. Она используется для создания изолированной области видимости
27. Что такое функции-генераторы в JavaScript?
	1. вид функций, позволяющий приостанавливать и возобновлять их выполнение, а также возвращать промежуточные значения в процессе работы
28. Что такое функции обратного вызова (callback functions)?
	2. это функции, которые передаются в качестве аргумента другой функции и вызываются внутри этой функции после выполнения определённого действия или при наступлении определённого события.
29. Что такое мемоизация функций и в каких случаях она полезна?
	1. техника оптимизации, при которой результаты вызова функции запоминаются в зависимости от переданных аргументов.
	2. Трудоёмкие вычисления, повторяющиеся вызовы и тд
30. Что такое функции первого класса (first-class functions)?
	1. это функции, которые можно:
		1. Присваивать переменной.
		2. Передавать в качестве аргумента другой функции.
		3. Возвращать из другой функции.
31. Что такое рекурсия и когда она применяется?
	1. функция вызывает сама себя
32. Что такое объект arguments в функциях JavaScript, и в каких способах объявления он не поддерживается? Почему?
	2. это встроенный в функции объект, который содержит массивоподобный список всех аргументов, переданных в функцию
	3. не поддерживается в arrow function, лучше использовать rest-параметры (остаточный оператор)
33. Что такое rest-параметры и spread-оператор в JavaScript, и как они используются?
	1.  Rest-параметры позволяют объявить функцию, которая может принимать любое количество аргументов, сгруппированных в один массив, аналог arguments 
	2. Spread-оператор — позволяет раскрыть итерируемый объект в набор отдельных элементов или свойств там, где ожидается перечисление значений
34. Что представляет собой ключевое слово this и как его контекст определяется в различных ситуациях?
	1. this представляет собой ссылку на текущий контекст выполнения, который определяется способом вызова функции
    - В глобальной области видимости.
	    - строгом режиме равен undefined
	    - браузера им является объект window
	    - в среде Node.js – объект global
    - В методе объекта.
	    - на контекст объекта
    - В функции-конструкторе.
	    - на контекст объекта созданный этой функцией оператором new
    - В стрелочных функциях.
	    - на контекст родителя
35. Что такое замыкание (closure) и как оно работает?
	1. замыкание - это механизм, при котором функция запоминает свое лексическое окружение, то есть контекст, в котором она была создана, и сохраняет доступ к этим переменным даже после завершения выполнения внешней функции, из которой она была вызвана.
36. В чем разница между методами call(), apply() и bind() в JavaScript, и когда использовать каждый из них?
	2. Методы call(), apply() и bind() в JavaScript используются для управления контекстом вызова функции
	3. call() - вызывает функцию немедленно, с указанным значением this и переданными аргументами по отдельности.
	4.  apply() - вызывает функцию немедленно, с указанным значением this и переданными аргументами в виде массива.
	5. bind() возвращает новую функцию с указанным значением this и фиксированными аргументами (если они переданы), в отличии от других методов функция не вызывается сразу и может быть вызвана в дальнейшем уже с изменым контекстом
37. В чем разница между синхронным и асинхронным кодом?
	1. Синхронный код
		1. Выполняется последовательно, инструкция за инструкцией
		2. блокирует выполнение дальнейшего кода до завершения текущей операции
	2. Асинхронный код
		1. операции выполняются в фоне, позволяя основному потоку продолжать выполнение без блокировки
38. Что такое Event Loop и как он работает?
	1.  Event Loop - механизм, обеспечивающий выполнение асинхронного кода в однопоточном окружении
	2. как работает:
		1. Выполняется весь синхронный код
		2. Выполняются все задачи из очереди микрозадач
		3. Берется первая задача из очереди макрозадач и выполняется
		4. При необходимости обновляется пользовательский интерфейс
		5. Цикл возвращается к обработке очереди микрозадач
		6. При отсутствии задач Event Loop продолжает ожидание новых событий
39. Что такое стек вызовов Call Stack и как он работает с асинхронным кодом?
	1. Call Stack - это структура данных, используемая движком JavaScript для отслеживания выполнения функций в программе. Он работает по принципу **LIFO (Last In, First Out)**, то есть последняя вызванная функция обрабатывается первой.
40. Что такое Task Queues, MacroTasks queue, MicroTasks Queues, и как они влияют на порядок выполнения асинхронного кода?
	2. Когда асинхронная задача попадает в **Call Stack**, она передается во внешнюю систему, которая после завершения добавляет её callback в macroTasks Queue или microTasks Queue. Когда Call Stack становится пустым, сначала обрабатываются задачи из macroTasks Queue, а затем из microTasks Queue
41. Приведите примеры Microtasks и Macrotasks
	1. MicroTasks:
		1. .then() .catch()  .finally()
		2. MutationObserver
		3. queueMicrotask()
	2. Macrotasks:
		4. setTimeout setInterval
		5. DOM Events
		6. setImmediate
		7. Сетевые запросы
42. Как работают  setImmediate() и queueMicrotask() и чем они отличаются?
	1. setImmediate(): помещает задачу в очередь макрозадач
	2. queueMicrotask(): помещает задачу в очередь микрозадач
43. Что такое Promises? какие у него есть состояния?
	1. Promise — это объект в JavaScript, который представляет результат асинхронной операции 
	2. у него есть 3 состояния
		1. ожидание (pending)
		2. выполнено (fulfilled)
		3. отклонено (rejected)
44. Как работает Promise.all(), Promise.allSettled(), Promise.race() и Promise.any()? есть ли еще какие-то методы?
	1. Promise.all() — ждет выполнения всех промисов, прерывается, если один промис отклонен
	2. Promise.allSettled() — ждет завершения всех промисов в независимости от их статуса
	3. Promise.race() — возвращает первый выполненный промис.
	4. Promise.any() — возвращает первый выполненный успешно промис, игнорируя ошибки
	5. Promise.reject() - cоздает промис, который немедленно переходит в состояние **rejected** с указанной причиной ошибки
	6. Promise.resolve() - cоздает промис, который немедленно переходит в состояние **fulfilled** с указанным значением
	7. Promise.withResolvers() - синтаксического сахар,  статический метод, который создает новый промис и одновременно возвращает объект, содержащий
		1. сам promise,
		2. функцию resolve для его успешного завершения,
		3. функцию reject для его отклонения.
	8. Promise.try() - синтаксического сахар, способ безопасно «обернуть» синхронный код, который может выбросить ошибку, в Promise, аналог Promise.resolve().then(() => {})
45. Как работает метод then с промисами в JavaScript?
	1. Метод .then() для обработки выполнения промиса, возвращает новый промис.
	2. Он принимает два аргумента:
		1. onFulfilled — функция, выполняемая при успешном разрешении промиса.
		2. onRejected (опционально, типа catch, но как аргумент then) — функция для обработки ошибок.
46. Какие механизмы обработки ошибок вы знаете? Как работает механизм обработки ошибок try...catch, и что такое finally?
	1. механизмы обработки ошибок
		1. аргумент onRejected в .then()
		2. try...catch
		3. throw
		4. Обработка ошибок с помощью Promise и catch()
	2. try...catch...finally
		1. try() - Включает код, выполнение которого может вызвать ошибку
		2. catch() - Срабатывает только в том случае, если в try блоке возникает ошибка
		3. finally() - Выполняется всегда, независимо от того, была ли ошибка или нет
47. Что такое объект Error и какие его свойства часто используются (message, name, stack)?
	1. Объект Error в  предназначен для создания ошибок и их обработки
	2. Основные свойства объекта Error
			1. message  -  текстовое сообщение об ошибке, переданное в конструктор объекта.
			2. name - имя ошибки, по умолчанию это Error.
			3. stack  - информацию о стеке вызовов.
48. Что такое async/await?
	1. синтаксический сахар для работы с промисами
	2. async Делает функцию асинхронной, что позволяет использовать внутри неё await и возвращает всегда promis
	3. await приостанавливает выполнение асинхронной функции до разрешения промиса и возвращает его результат
49. Как работают таймеры setTimeout, setInterval и чем они отличаются?
	1. setTimeout - запускает функцию один раз после указанного времени задержки
		1. очистка - clearTimeout
	2. setInterval - запускает функцию периодически с указанным интервалом времени до тех пор, пока таймер не будет остановлен
		2. очистка - clearInterval
50. Что такое Callback Hell (pyramid of doom) и как с ним бороться?
	1.  несколько вложенных обратных вызовов создают сложный код с глубокими отступами
	2. Решение:
		   1. async/await
		   2. promises
		   3. модульность
51. Что такое race condition и как его избежать?
	1. ситуация, возникающая при параллельном выполнении операций, когда результат зависит от неконтролируемого порядка их завершения
52. Что такое Debouncing и Throttling?
	2. это техники оптимизации для обработки событий
	3. Debouncing - предотвращает выполнение функции, пока события происходят часто, и позволяет её вызвать только один раз, через заданную задержку после того, как поток событий прекратился.
	4. Throttling - позволяет функции выполняться регулярно, но не чаще, чем раз в заданный интервал времени, даже если события происходят беспрерывно.
53. Что такое Promise chaining?
	1. техника последовательного выполнения асинхронных операций с использованием цепочки промисов. Каждый .then передаёт результат следующему обработчику.
54. Что такое Deadlock?
	2. ситуация, при которой два или более процесса ждут друг друга, блокируя выполнение всех операций
	3. Избежание:
		1. Упорядочивание захватов блокировок.
		2. Использование таймаутов при ожидании блокировок.
		3. Минимизация использования блокировок.
55. Какие методы массивов (например, map, filter, reduce) используются для работы с данными?
	1. map - Применяет функцию к каждому элементу массива и возвращает новый массив с результатами.
	2. forEach - Применяет функцию для каждого элемента массива, но ничего не возвращает
	3. filtred - создает новый массив, содержащий только элементы, которые удовлетворяют заданному условию.
	4. reduce - преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору
	5. reduceRight - аналогичен reduce, но обход массива выполняется справа налево.
	6. find - возвращает первый элемент массива, который удовлетворяет заданному условию, или undefined, если такого элемента нет.
	7. findIndex - возвращает индекс первого элемента, который удовлетворяет заданному условию, или -1, если такого элемента нет.
	8. indexOf - возвращает первый индекс указанного элемента в массиве или -1, если элемент не найден.
	9. lastIndexOf - возвращает последний индекс указанного элемента в массиве или -1, если элемент не найден.
	10. includes - проверяет, содержит ли массив указанный элемент, возвращает true или false.
	11. some - возвращает true, если хотя бы один элемент массива удовлетворяет условию.
	12. every - возвращает true, если все элементы массива удовлетворяют условию.
56. Чем forEach отличается от map?
	1. forEach - выполнить какую-либо операцию над элементами массива
	2. map - возвращает новый массив с преобразованными данными.
57. Что делает метод reduce, и как с его помощью можно заменить другие методы работы с массивами?
	1. преобразует массив в одно значение, применяя функцию последовательно к каждому элементу и аккумулятору
58. Чем отличается копирование массива с помощью slice, spread-оператора и Array.from()?
	2. slice - позволяет копировать часть массива (подмассив) с указанием границ индексов.
	3. spread-оператора - поддерживает объединение массивов и добавление новых элементов в процессе копирования.
	4. Array.from() - работает с массивоподобными объектами (например, arguments или DOM-коллекциями) и позволяет преобразовывать элементы при копировании.
59. Что такое DOM? Опишите, как DOM представляет структуру HTML-документа.
	1. Document Object Model - это представление HTML-документа в виде структуры дерева. Каждый элемент HTML (тег) становится узлом дерева. DOM позволяет взаимодействовать с HTML-документом, изменять его структуру, содержимое и стили при помощи JavaScript
60. Сколько существует типов узлов DOM?
	2. 12 типов узлов 
		1. Element Node
		2. Text Node
		3. Comment Node
		4. ....
61. Какие есть фазы распространения события? расскажите про каждое
	1. Фаза захвата (Capturing phase) - Событие распространяется сверху вниз по дереву DOM, начиная с корневого элемента (window) и проходя через всех предков целевого элемента.
	2. Фаза цели (Target phase) - Событие достигает целевого элемента, на котором оно произошло. Обработчики, привязанные к целевому элементу, выполняются.
	3. Фаза всплытия (Bubbling phase) - Событие поднимается обратно вверх по дереву DOM от целевого элемента к его предкам.
62. Что такое CSSOM?
	4. CSS Object Model - это объектная модель CSS, которая представляет стили CSS в виде структуры дерева. CSSOM создается браузером при разборе CSS-стилей (как встроенных, так и внешних). Она позволяет JavaScript взаимодействовать с CSS — например, получать или изменять стили элементов на странице.
63. Связь между DOM и CSSOM
	1. DOM и CSSOM объединяются для создания render-three которое уже используется  для отрисовки страницы
64. Как можно оптимизировать DOM и CSSOM?
	2. DOM 
		1. минимизация количества узлов и элементов
		2. применять изменения в дереве разом для всего а не по одному
		3. использования lazy loading
	3. CSSOM 
		4. удаление ненужных стилей
		5. уменьшения css файлов
		6. минимизицаия сложности селекторов
65. Что такое Reflow, Repaint и Compositing и в чем их разница? Приведите примеры, когда происходит каждый из этих процессов.
	1. Reflow, Repaint, Compositing - процессы, связанные с рендерингом веб-страницы, которые происходят при изменениях в DOM и CSSOM.
	2. Reflow -  процесс, при котором браузер пересчитывает размеры и расположение элементов на странице
	3. Repaint - процесс, при котором браузер обновляет визуальное представление элементов без изменения их геометрии
	4. Compositing - процесс, при котором браузер объединяет слои, сформированные после рендеринга, в окончательную визуализацию страницы, чтобы отобразить её на экране.
66. Что такое Shadow DOM?
	1. технология, которая позволяет создавать инкапсулированные DOM-деревья в веб-компонентах.
67. Какие проблемы решает Shadow DOM?
	1. Конфликты стилей
	2. модульность?
	3. изоляция
68. Что такое BOM?
	4. Browser Object Model -  интерфейс, предоставляемый браузером для взаимодействия с окном браузера и его функциями
69. Какие существуют основные компоненты BOM?
	1. компоненты
		1. window
		2. document
		3. navigator
		4. location
		5. history
70. Что такое Render Tree и как он строится?
	2. Браузер комбинирует DOM и CSSOM, чтобы построить Render Tree. 
	3. Render Tree включает только видимые элементы и их стили: 
	4. Элементы с display: none исключаются из Render Tree.
	5. Элементы с visibility: hidden остаются в Render Tree, так как занимают место, но не видимы.
	6. Если DOM или CSSOM изменяются (например, через JavaScript), Render Tree пересчитывается.
71. Как браузер рендерит документ?
	1. Получает данные (байты) от сервера.
	2. Разбирает и преобразует в токены (<, ИмяТега, Атрибут, ЗначениеАтрибута, >).
	3. Превращает токены в узлы.
	4. Превращает узлы в дерево DOM.
	5. Создаёт дерево CSSOM из правил CSS.
	6. Деревья CSSOM и DOM объединяются в дерево рендеринга (RenderTree).
	7. Вычисляет, какие элементы видимы и их вычисленные стили.
	    - Начиная с корня дерева DOM.
	    - Невидимые элементы, такие как (meta, script, link) и display: none, исключаются из дерева рендеринга.
	    - Для каждого видимого узла находит соответствующие правила CSSOM и применяет их.
	8. Reflow: вычисляет макет каждого видимого элемента (положение и размер).
	9. Repaint: рендерит пиксели на экране.
	10. Compositing: 
		1. После Repaint браузер объединяет различные слои (например, слои с эффектами, анимацией, позиционированными элементами) в итоговый кадр.
	    - Логика композитинга может включать отрисовку слоёв в правильном порядке, обработку прозрачности, тени и других визуальных эффектов.
	    - Завершается отправкой кадра на GPU для отображения.