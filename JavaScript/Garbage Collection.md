## Сборка мусора

1. Что такое сборка мусора (Garbage Collection) в JavaScript и как она работает?
	- автоматический процесс управления памятью, при котором движок JavaScript освобождает память, занятую объектами, которые больше не используются в программе
	- движок отслеживает ссылки на объекты и удаляет те, на которые больше нет ссылок

2. Какие алгоритмы сборки мусора используются в современных движках JavaScript?
	1. Mark-and-Sweep (метка и очистка) - основной алгоритм
	2. Generational Garbage Collection - разделение объектов по поколениям
	3. Incremental Garbage Collection - инкрементальная сборка
	4. Concurrent Garbage Collection - параллельная сборка

3. Как работает алгоритм Mark-and-Sweep в JavaScript?
	1. Mark (метка) - движок проходит по всем объектам, начиная с корневых (глобальные переменные, активные функции), и помечает все достижимые объекты
	2. Sweep (очистка) - удаляет все непомеченные объекты, освобождая память

4. Что такое слабые ссылки (weak references) и чем они отличаются от обычных ссылок?
	- слабые ссылки не препятствуют сборке мусора
	- если объект доступен только через слабые ссылки, он может быть удален сборщиком мусора
	- обычные ссылки удерживают объект в памяти до тех пор, пока на него есть хотя бы одна ссылка

5. Что такое корневые объекты (root objects) в контексте сборки мусора?
	- объекты, которые считаются всегда достижимыми и служат точкой входа для алгоритма Mark-and-Sweep
	- включают:
		1. Глобальный объект (`window` в браузере, `global` в Node.js)
		2. Активные функции и их локальные переменные
		3. Ссылки в стеке вызовов (Call Stack)
		4. Глобальные переменные
		5. Встроенные объекты и их прототипы

6. Как работает алгоритм Reference Counting и почему он не используется в JavaScript?
	- алгоритм, который отслеживает количество ссылок на каждый объект
	- когда счетчик ссылок достигает нуля, объект удаляется
	- не используется в JavaScript из-за проблемы циклических ссылок
	- циклические ссылки могут привести к утечкам памяти, так как счетчик никогда не достигнет нуля

7. Что такое циклические ссылки и как сборщик мусора с ними справляется?
	- ситуация, когда объекты ссылаются друг на друга, образуя цикл
	- алгоритм Reference Counting не может их обработать
	- Mark-and-Sweep решает эту проблему, так как проверяет достижимость от корневых объектов, а не количество ссылок
	- если ни один объект в цикле не достижим от корня, весь цикл удаляется

8. Как работает Generational Garbage Collection?
	- разделение объектов на поколения (young и old)
	- молодые объекты проверяются чаще, так как большинство объектов умирают быстро
	- старые объекты проверяются реже, так как они обычно живут дольше
	- оптимизирует производительность сборки мусора
	- основан на гипотезе, что большинство объектов живут недолго

9. Что такое Young Generation и Old Generation в контексте сборки мусора?
	- Young Generation (новое поколение) - область памяти для недавно созданных объектов
	- Old Generation (старое поколение) - область памяти для объектов, переживших несколько циклов сборки
	- объекты перемещаются из Young в Old после определенного количества циклов сборки
	- обычно объекты перемещаются после 1-2 циклов Scavenge

10. Как работает алгоритм Scavenge в Young Generation?
	- быстрый алгоритм копирования для Young Generation
	- разделяет память на две равные части (from-space и to-space)
	- при сборке мусора живые объекты копируются из from-space в to-space
	- после копирования роли пространств меняются местами
	- очень быстрый, так как работает только с небольшой частью памяти

11. Что такое Major GC и Minor GC в контексте сборки мусора?
	- Minor GC (Scavenge) - быстрая сборка мусора в Young Generation
	- Major GC - полная сборка мусора, включающая Old Generation
	- Major GC выполняется реже, но занимает больше времени
	- Major GC использует алгоритм Mark-and-Sweep или Mark-Compact

12. Как работает Incremental Garbage Collection?
	- разбивает процесс сборки мусора на небольшие части
	- выполняется между выполнением JavaScript кода
	- уменьшает задержки (latency) при выполнении программы
	- позволяет приложению оставаться отзывчивым во время сборки мусора
	- требует дополнительных механизмов отслеживания изменений (Write Barrier)

13. Что такое Concurrent Garbage Collection?
	- сборка мусора, выполняемая параллельно с выполнением JavaScript кода
	- выполняется в отдельном потоке
	- требует дополнительной синхронизации для безопасности
	- уменьшает паузы выполнения программы
	- более сложный в реализации, чем инкрементальная сборка

14. Что такое stop-the-world паузы в контексте сборки мусора?
	- моменты, когда выполнение JavaScript кода полностью останавливается для сборки мусора
	- могут вызывать задержки в работе приложения
	- современные движки минимизируют такие паузы через инкрементальную и параллельную сборку
	- в старых алгоритмах были неизбежны, в современных встречаются реже

15. Как работает алгоритм Mark-Compact?
	- вариант Mark-and-Sweep, который дополнительно уплотняет память
	- после удаления мертвых объектов, живые объекты перемещаются в начало области памяти
	- устраняет фрагментацию памяти
	- требует больше времени, но улучшает использование памяти
	- используется для Old Generation в некоторых случаях

16. Что такое триколорная маркировка (tri-color marking) в сборке мусора?
	- система маркировки объектов тремя цветами:
		1. Белый - не посещенный объект (кандидат на удаление)
		2. Серый - посещенный, но его ссылки еще не проверены
		3. Черный - посещенный и все его ссылки проверены
	- позволяет безопасно выполнять инкрементальную сборку мусора
	- гарантирует, что черные объекты не ссылаются на белые объекты

17. Как работает Write Barrier в контексте инкрементальной сборки мусора?
	- механизм отслеживания изменений ссылок во время выполнения программы
	- когда ссылка изменяется, объект помечается как серый
	- необходим для корректной работы инкрементальной сборки мусора
	- гарантирует, что не будут удалены объекты, на которые есть ссылки
	- добавляет небольшие накладные расходы на каждое присваивание

18. Что такое консервативное сканирование стека (Conservative Stack Scanning)?
	- подход к сборке мусора, при котором движок не требует точной информации о расположении указателей на стеке
	- компилятор может хранить указатели в регистрах, не управляя HandleScope
	- избегает затрат на компиляцию и пространство для stack maps
	- предотвращает два класса ошибок: удержание handle после lifetime handlescope и удержание raw pointer вместо handle
	- ограничение: объекты, на которые могут указывать консервативные корни, не могут быть перемещены

19. Что такое внутренние указатели (interior pointers) и как они влияют на сборку мусора?
	- указатели, которые указывают не на начало объекта, а на его внутреннюю часть
	- консервативное сканирование стека может обнаружить внутренние указатели
	- требует, чтобы куча могла разрешать внутренние указатели до начала объекта
	- ограничивает возможность перемещения объектов
	- влияет на структуру кучи и алгоритмы сборки мусора

20. Что такое параллельная сборка мусора (parallel GC)?
	- выполнение фаз сборки мусора на нескольких потоках одновременно
	- все фазы, которые могут быть параллельными, теперь полностью параллельны:
		1. Semi-space evacuation
		2. Mark-space marking и compaction
		3. Sweeping
	- увеличивает пропускную способность сборки мусора
	- требует синхронизации между потоками

21. Что такое конкурентная сборка мусора (concurrent GC)?
	- выполнение фаз сборки мусора параллельно с выполнением JavaScript кода
	- конкурентными являются: marking и sweeping
	- major sweep task может выполняться конкурентно с evacuating minor GC
	- требует сложной синхронизации и может быть источником багов
	- уменьшает паузы выполнения программы

22. Что такое lazy sweeping в контексте сборки мусора?
	- отложенная очистка памяти после маркировки
	- память освобождается постепенно, а не сразу
	- позволяет быстрее вернуться к выполнению кода
	- память помечается как свободная, но может быть использована позже
	- оптимизирует производительность сборки мусора

23. Как работает incremental marking?
	- процесс постепенной маркировки объектов во время выполнения программы
	- разбивает фазу Mark на небольшие части
	- выполняется между выполнением JavaScript кода
	- требует Write Barrier для отслеживания изменений
	- уменьшает задержки при сборке мусора

24. Как работает concurrent marking?
	- маркировка объектов выполняется в отдельном потоке
	- параллельно с выполнением JavaScript кода
	- требует синхронизации для безопасности
	- может работать быстрее, чем incremental marking
	- более сложный в реализации

25. Что такое write barrier overhead и как его минимизировать?
	- накладные расходы на отслеживание изменений ссылок
	- необходим для инкрементальной и параллельной сборки мусора
	- добавляет небольшую задержку на каждое присваивание
	- современные движки оптимизируют write barrier
	- может влиять на производительность в критичных местах

26. Как работает сборка мусора для больших объектов (large objects)?
	- большие объекты (обычно >1MB) размещаются в отдельной области памяти
	- обрабатываются отдельным алгоритмом сборки мусора
	- не копируются при Scavenge, а сразу перемещаются в Old Generation
	- оптимизировано для работы с большими объемами данных
	- ArrayBuffer и TypedArray часто являются большими объектами

27. Что такое память на стеке (stack) и в куче (heap) в контексте JavaScript?
	- стек - область памяти для примитивных значений и ссылок на объекты
	- куча - область памяти для объектов и массивов
	- примитивные значения хранятся в стеке
	- объекты хранятся в куче, в стеке хранится только ссылка на них
	- стек управляется автоматически при вызове и возврате функций
	- куча управляется сборщиком мусора

28. Как работает сборка мусора для строк в JavaScript?
	- строки в JavaScript иммутабельны
	- при конкатенации создаются новые строки
	- движки оптимизируют работу со строками через string interning
	- одинаковые строковые литералы могут ссылаться на один объект в памяти
	- строки хранятся в куче, но оптимизируются движком

29. Что такое string interning и как это влияет на сборку мусора?
	- техника оптимизации, при которой одинаковые строки хранятся в одном месте
	- уменьшает использование памяти
	- строки, используемые в коде, обычно не удаляются сборщиком мусора
	- применяется для строковых литералов и некоторых других строк
	- может влиять на производительность при большом количестве уникальных строк

30. Как работает сборка мусора для массивов в JavaScript?
	- массивы - это объекты, хранящиеся в куче
	- при удалении массива его элементы также становятся кандидатами на удаление
	- если на элементы массива есть другие ссылки, они не удаляются
	- большие разреженные массивы могут занимать много памяти
	- движки оптимизируют массивы для улучшения производительности

31. Что такое внешняя память (external memory)?
	- память, выделенная вне основной кучи движка
	- используется для больших объектов, таких как ArrayBuffers
	- не управляется сборщиком мусора напрямую
	- требует явного освобождения или использования FinalizationRegistry
	- учитывается при расчете лимитов памяти

32. Как ArrayBuffer и TypedArray влияют на сборку мусора?
	- ArrayBuffer хранит данные во внешней памяти
	- при удалении ArrayBuffer память освобождается автоматически
	- TypedArray - это представление данных ArrayBuffer
	- если на ArrayBuffer есть ссылки через TypedArray, он не удаляется
	- важно явно обнулять ссылки на ArrayBuffer после использования

33. Как работает сборка мусора в Node.js и чем она отличается от браузерной?
	- в Node.js и браузерах используются схожие алгоритмы сборки мусора
	- в Node.js можно использовать `--expose-gc` для принудительной сборки
	- в Node.js больше контроля над параметрами сборки мусора через флаги
	- в Node.js можно настроить лимиты памяти более гибко
	- в браузерах сборка мусора полностью автоматическая

34. Как профилировать использование памяти и сборку мусора в JavaScript?
	- Chrome DevTools Memory Profiler
	- Node.js `--inspect` с Chrome DevTools
	- `performance.memory` API в браузерах
	- инструменты для отслеживания утечек памяти
	- heap snapshots для анализа использования памяти
	- Performance Monitor в DevTools

35. Что такое heap snapshot и как его использовать для отладки утечек памяти?
	- снимок состояния кучи памяти в определенный момент времени
	- позволяет увидеть все объекты в памяти и их ссылки
	- можно сравнивать несколько снимков для поиска утечек
	- доступен через Chrome DevTools и Node.js inspector
	- показывает размер объектов и цепочки ссылок

36. Как работает сборка мусора для промисов и асинхронных операций?
	- промисы хранятся в памяти до разрешения или отклонения
	- обработчики `.then()` и `.catch()` создают ссылки на промисы
	- если промис не разрешен и на него есть ссылки, он не удаляется
	- важно очищать ссылки на промисы, которые больше не нужны
	- AbortController может помочь прервать асинхронные операции

37. Как работает сборка мусора для классов и прототипов?
	- классы и их прототипы хранятся в памяти
	- экземпляры классов - это обычные объекты
	- при удалении экземпляра его методы и свойства становятся кандидатами на удаление
	- прототипы классов обычно не удаляются, так как на них есть ссылки
	- статические методы и свойства принадлежат классу, а не экземплярам

38. Что такое оптимизация сборки мусора через object pooling?
	- техника переиспользования объектов вместо их создания и удаления
	- уменьшает нагрузку на сборщик мусора
	- объекты берутся из пула, используются и возвращаются обратно
	- полезно для часто создаваемых и удаляемых объектов
	- требует ручного управления жизненным циклом объектов

39. Как работает сборка мусора для модулей ES6?
	- модули загружаются один раз и остаются в памяти
	- экспортированные объекты не удаляются, пока модуль загружен
	- важно не хранить большие объекты в модульном scope
	- динамические импорты позволяют выгружать модули
	- модули могут быть выгружены, если на них нет ссылок

40. Что такое memory pressure и как сборщик мусора на него реагирует?
	- ситуация, когда доступной памяти становится мало
	- сборщик мусора может работать более агрессивно
	- может увеличить частоту Major GC
	- может уменьшить пороги для перемещения объектов в Old Generation
	- может вызвать более частые циклы сборки мусора

41. Как работает сборка мусора для Web Workers?
	- каждый Web Worker имеет свою изолированную кучу памяти
	- сборка мусора работает независимо в каждом Worker
	- объекты, переданные между Worker и основным потоком, копируются
	- SharedArrayBuffer позволяет разделять память между Worker'ами
	- каждый Worker имеет свои корневые объекты

42. Как работает сборка мусора для замыканий (closures)?
	- замыкания хранят ссылки на внешние переменные
	- если замыкание активно, все его внешние переменные не удаляются
	- важно не хранить большие объекты в замыканиях без необходимости
	- замыкания могут создавать циклические ссылки
	- сборщик мусора обрабатывает замыкания как обычные объекты

43. Как работает сборка мусора для итераторов и генераторов?
	- итераторы и генераторы - это объекты, хранящиеся в куче
	- при удалении итератора его состояние может быть удалено
	- генераторы хранят состояние выполнения функции
	- важно явно закрывать итераторы через `return()` или `throw()`
	- незакрытые генераторы могут удерживать память

44. Что такое memory leak detection и какие инструменты для этого существуют?
	- процесс обнаружения утечек памяти в приложении
	- Chrome DevTools Memory Profiler
	- Node.js `--inspect` с heap snapshots
	- инструменты для сравнения снимков памяти
	- автоматическое обнаружение растущих объектов
	- Performance Monitor для отслеживания использования памяти

45. Как работает сборка мусора для Proxy объектов?
	- Proxy объекты - это обычные объекты с дополнительным слоем
	- хранятся в куче как обычные объекты
	- target и handler удерживаются в памяти, пока Proxy активен
	- важно не создавать циклические ссылки через Proxy
	- сборщик мусора обрабатывает их стандартным образом

46. Что такое memory fragmentation и как сборщик мусора с ней борется?
	- фрагментация памяти - наличие небольших свободных участков между занятыми
	- Mark-Compact алгоритм уплотняет память, устраняя фрагментацию
	- Scavenge копирует объекты, что также устраняет фрагментацию
	- фрагментация может снизить эффективность использования памяти
	- современные алгоритмы минимизируют фрагментацию

47. Как работает сборка мусора для Symbol значений?
	- Symbol значения уникальны и иммутабельны
	- глобальные Symbol (Symbol.for) хранятся в реестре
	- Symbol из реестра не удаляются сборщиком мусора
	- локальные Symbol обрабатываются как обычные примитивы
	- Symbol как ключи объектов обрабатываются стандартно

48. Что такое WeakRef в JavaScript и чем он отличается от обычных ссылок?
	- слабая ссылка на объект, которая не препятствует сборке мусора
	- позволяет получить доступ к объекту, если он еще не удален
	- метод `.deref()` возвращает объект или `undefined`, если объект был удален
	- используется вместе с FinalizationRegistry для управления ресурсами
	- в отличие от обычных ссылок, не удерживает объект в памяти

49. Как работает FinalizationRegistry в JavaScript и для чего он используется?
	- API для регистрации колбэков, вызываемых при удалении объектов сборщиком мусора
	- позволяет выполнить очистку ресурсов при удалении объекта
	- не гарантирует точное время вызова колбэка
	- следует использовать осторожно, так как может привести к утечкам памяти
	- полезен для освобождения внешних ресурсов (файлы, сетевые соединения)

50. Как можно принудительно запустить сборку мусора в JavaScript?
	- в большинстве случаев нельзя принудительно запустить сборку мусора
	- в Node.js можно использовать `global.gc()` с флагом `--expose-gc`
	- в браузерах нет прямого API для этого
	- обычно сборка мусора запускается автоматически при необходимости
	- принудительная сборка может быть полезна для тестирования и профилирования

51. Что такое утечки памяти через замыкания и как их избежать?
	- замыкания сохраняют ссылки на внешние переменные
	- если замыкание хранит ссылку на большой объект, он не будет удален
	- решение: явно обнулять ссылки на ненужные объекты в замыканиях
	- использовать WeakMap для хранения данных, которые не должны препятствовать сборке мусора
	- избегать хранения больших объектов в замыканиях, если они не нужны

52. Как обработчики событий могут вызывать утечки памяти?
	- обработчики событий создают ссылки на DOM элементы
	- если обработчик не удален, элемент не может быть удален сборщиком мусора
	- решение: всегда удалять обработчики событий при удалении элементов
	- использовать `removeEventListener` или современные API типа `AbortController`
	- особенно важно для динамически создаваемых элементов

53. Как таймеры могут вызывать утечки памяти?
	- `setTimeout` и `setInterval` создают ссылки на функции и их замыкания
	- если таймер не очищен, объекты в замыканиях не могут быть удалены
	- решение: всегда очищать таймеры через `clearTimeout` и `clearInterval`
	- особенно важно при работе с компонентами, которые могут быть удалены
	- в React и других фреймворках очистка таймеров в `useEffect` cleanup

54. Что такое утечки памяти через глобальные переменные?
	- глобальные переменные всегда считаются достижимыми
	- объекты, хранящиеся в глобальных переменных, никогда не удаляются
	- решение: минимизировать использование глобальных переменных
	- использовать модули и локальные области видимости
	- особенно опасно хранить большие объекты в глобальных переменных

55. Что такое утечки памяти через WeakMap и WeakSet?
	- технически WeakMap и WeakSet не должны вызывать утечки
	- но если объект-ключ хранится где-то еще, он не удаляется
	- важно убедиться, что объекты-ключи не имеют других сильных ссылок
	- WeakMap и WeakSet сами по себе не препятствуют сборке мусора
	- проблема возникает, если объект-ключ удерживается другой ссылкой

56. Опишите полный алгоритм работы сборщика мусора в JavaScript, используя все современные концепции?
	- современные сборщики мусора используют комбинацию нескольких алгоритмов и техник оптимизации
	- полный алгоритм включает следующие этапы и концепции:
	
	1. Структура памяти:
		- память разделена на стек (stack) и кучу (heap)
		- примитивные значения хранятся в стеке
		- объекты хранятся в куче, в стеке хранятся только ссылки на них
		- куча разделена на Young Generation и Old Generation
		- большие объекты (>1MB) размещаются в отдельной области памяти
		- внешняя память используется для ArrayBuffer и TypedArray
	
	2. Generational Garbage Collection:
		- объекты разделены на поколения (young и old)
		- молодые объекты проверяются чаще (Minor GC)
		- старые объекты проверяются реже (Major GC)
		- основано на гипотезе, что большинство объектов живут недолго
	
	3. Minor GC (Scavenge) для Young Generation:
		- быстрый алгоритм копирования
		- память разделена на from-space и to-space
		- живые объекты копируются из from-space в to-space
		- после копирования роли пространств меняются
		- объекты, пережившие 1-2 цикла, перемещаются в Old Generation
		- большие объекты сразу перемещаются в Old Generation
	
	4. Major GC для Old Generation:
		- использует алгоритм Mark-and-Sweep или Mark-Compact
		- Mark-Compact дополнительно уплотняет память, устраняя фрагментацию
		- выполняется реже, но занимает больше времени
	
	5. Mark-and-Sweep алгоритм:
		- фаза Mark (метка):
			- начинается с корневых объектов (root objects):
				1. Глобальный объект (window/global)
				2. Активные функции и их локальные переменные
				3. Ссылки в стеке вызовов (Call Stack)
				4. Глобальные переменные
				5. Встроенные объекты и их прототипы
			- используется консервативное сканирование стека (Conservative Stack Scanning)
			- движок не требует точной информации о расположении указателей на стеке
			- компилятор может хранить указатели в регистрах
			- может обнаружить внутренние указатели (interior pointers)
			- объекты, на которые могут указывать консервативные корни, не могут быть перемещены
			- все достижимые объекты помечаются как живые
			- решает проблему циклических ссылок, проверяя достижимость от корня
		- фаза Sweep (очистка):
			- удаляются все непомеченные объекты
			- может выполняться как lazy sweeping (отложенная очистка)
			- память помечается как свободная постепенно
	
	6. Триколорная маркировка (tri-color marking):
		- система маркировки объектов тремя цветами:
			1. Белый - не посещенный объект (кандидат на удаление)
			2. Серый - посещенный, но его ссылки еще не проверены
			3. Черный - посещенный и все его ссылки проверены
		- гарантирует, что черные объекты не ссылаются на белые объекты
		- позволяет безопасно выполнять инкрементальную сборку мусора
	
	7. Write Barrier:
		- механизм отслеживания изменений ссылок во время выполнения программы
		- когда ссылка изменяется, объект помечается как серый
		- необходим для корректной работы инкрементальной сборки мусора
		- добавляет накладные расходы на каждое присваивание
		- современные движки оптимизируют write barrier
	
	8. Incremental Garbage Collection:
		- разбивает процесс сборки мусора на небольшие части
		- выполняется между выполнением JavaScript кода
		- уменьшает задержки (latency) при выполнении программы
		- позволяет приложению оставаться отзывчивым
		- использует incremental marking (постепенная маркировка)
		- требует Write Barrier для отслеживания изменений
	
	9. Concurrent Garbage Collection:
		- выполнение фаз сборки мусора параллельно с выполнением JavaScript кода
		- конкурентными являются: marking и sweeping
		- маркировка выполняется в отдельном потоке (concurrent marking)
		- major sweep task может выполняться конкурентно с evacuating minor GC
		- требует сложной синхронизации для безопасности
		- уменьшает паузы выполнения программы
	
	10. Параллельная сборка мусора (parallel GC):
		- выполнение фаз сборки мусора на нескольких потоках одновременно
		- параллельными являются:
			1. Semi-space evacuation
			2. Mark-space marking и compaction
			3. Sweeping
		- увеличивает пропускную способность сборки мусора
		- требует синхронизации между потоками
	
	11. Обработка специальных типов объектов:
		- строки: оптимизируются через string interning, одинаковые строки хранятся в одном месте
		- массивы: обрабатываются как обычные объекты, элементы удаляются при удалении массива
		- промисы: хранятся до разрешения, обработчики создают ссылки
		- классы и прототипы: прототипы обычно не удаляются, экземпляры обрабатываются стандартно
		- модули ES6: остаются в памяти, пока модуль загружен
		- замыкания: хранят ссылки на внешние переменные, обрабатываются как обычные объекты
		- итераторы и генераторы: важно явно закрывать для освобождения памяти
		- Proxy: target и handler удерживаются в памяти, пока Proxy активен
		- Symbol: глобальные Symbol не удаляются, локальные обрабатываются стандартно
	
	12. Слабые ссылки:
		- WeakMap и WeakSet используют слабые ссылки
		- не препятствуют сборке мусора
		- объекты, доступные только через слабые ссылки, могут быть удалены
		- WeakRef позволяет получить доступ к объекту, если он еще не удален
		- FinalizationRegistry регистрирует колбэки при удалении объектов
	
	13. Оптимизации:
		- object pooling: переиспользование объектов для уменьшения нагрузки на GC
		- memory pressure: при нехватке памяти GC работает более агрессивно
		- минимизация stop-the-world пауз через инкрементальную и параллельную сборку
		- борьба с фрагментацией памяти через Mark-Compact и Scavenge
	
	14. Web Workers:
		- каждый Worker имеет свою изолированную кучу памяти
		- сборка мусора работает независимо в каждом Worker
		- объекты между Worker и основным потоком копируются
		- SharedArrayBuffer позволяет разделять память
	
	15. Профилирование и отладка:
		- heap snapshots для анализа использования памяти
		- инструменты для обнаружения утечек памяти
		- сравнение снимков памяти для поиска растущих объектов
		- Performance Monitor для отслеживания использования памяти



