- **Arrow Functions vs. Regular Functions**:
    - **Arrow Functions**: Легковесные функции, сохраняющие контекст `this` из окружающей области. Синтаксис: `(param) => expression`.
    - **Regular Functions**: Функции, создаваемые с помощью `function` или `function*` (генераторные функции). `this` внутри таких функций зависит от способа вызова.

- **Named vs. Anonymous Functions**:
    - **Named Functions**: Функции, имеющие имя (например, `function myFunction() {}`), что упрощает отладку и рекурсию.
    - **Anonymous Functions**: Функции без имени (например, `function() {}`), часто используются как коллбэки или аргументы.

- **Function Scope and Hoisting**:
    - **Function Scope**: Переменные, объявленные внутри функции, доступны только внутри этой функции.
    - **Hoisting**: Функции и переменные объявляются в начале их области видимости, что позволяет использовать их до их определения в коде.

- **Recursive Functions**:
    - Функции, которые вызывают сами себя для решения задачи путем разбиения на более простые подзадачи. Требуют условия завершения, чтобы избежать бесконечной рекурсии.

- **Asynchronous Functions**:
    - Функции, выполняющиеся асинхронно, не блокируя основной поток выполнения. Используют `async` и `await` для упрощения работы с промисами и асинхронными операциями.

- **Callback Functions**:
    - Функции, переданные как аргументы в другие функции для выполнения после завершения какой-либо операции. Часто используются для обработки событий или асинхронных операций.

- **Function Overloading**:
    - В JavaScript не поддерживается напрямую, но можно имитировать перегрузку функций, проверяя количество и типы аргументов внутри функции.

- **Function Composition**:
    - Процесс объединения нескольких функций в одну, где выход одной функции становится входом другой. Полезен для создания сложных функций из простых.

- **Rest and Spread Operators**:
    - **Rest Operator (`...rest`)**: Сбор дополнительных аргументов функции в массив.
    - **Spread Operator (`...spread`)**: Распределение элементов массива или объекта в новые массивы или объекты.

- **Partial Application**:
    - Техника создания новой функции с заранее заданными аргументами из исходной функции. Пример: `function add(a, b) { return a + b; }` → `const addFive = add.bind(null, 5);`.

- **Implicit vs. Explicit Returns**:
    - **Implicit Return**: В стрелочных функциях, если тело функции состоит из одного выражения, оно возвращается автоматически (например, `(a, b) => a + b`).
    - **Explicit Return**: Явный оператор `return` используется для возвращения значения (например, `function multiply(a, b) { return a * b; }`).

- **Higher-Order Array Methods**:
    - Методы массивов, принимающие функции как аргументы или возвращающие функции, такие как `map`, `filter`, `reduce`, `forEach`.

- **Lazy Evaluation**:
    - Подход, при котором выражение вычисляется только при необходимости. Это может улучшить производительность и снизить потребление ресурсов, используя такие техники, как ленивые итераторы и генераторы.

	-Monads
	
- чейнинг функций
- Memoization
- Recursion