1. Что такое Sass и чем синтаксис SCSS отличается от него?
	1. **Sass** — CSS-препроцессор, который добавляет переменные, вложенность, миксины, функции, условия, циклы, модули и другие возможности, недоступные в обычном CSS.
	2. **SCSS** — один из синтаксисов Sass с синтаксисом, совместимым с CSS (`{}` и `;`).
2. Чем Sass/SCSS отличается от обычного CSS?
	1. Sass Добавляет такие возможности как:
		1. Переменные ($var) с !default и !global.
		2. Вложенность селекторов и &.
		3. Миксины (@mixin, @include) с аргументами и @content.
		4. Наследование (@extend, %placeholder).
		5. Функции (@function) и встроенные (darken, lighten, mix, adjust-color, и др.).
		6. Списки и карты (list, map) с функциями (nth, length, map-get, map-merge).
		7. Модули и импорт (@use, @forward, устаревший @import).
		8. Вычисления и арифметика (числа, единицы, цвета, строки).
		9. Управляющие конструкции (@if, @else, @for, @each, @while).
3. Какие преимущества использования SCSS?
	1. **Модульность и переиспользуемость**: переменные, миксины и функции уменьшают дублирование кода
	2. **Вложенность**: структура кода отражает DOM
	3. Поддержка архитектуры и масштабируемость: модули, карты, циклы, условия позволяют строить крупные проекты с 7-1 структурой
4. Как в экосистеме Sass компилировать SCSS в CSS и какими инструментами?
	1. Dart Sass (`sass`): `npx sass input.scss output.css`.
	3. В сборщиках (Vite/Webpack) под капотом — Dart Sass.
5. Как в SCSS объявляются и используются переменные?
	1. Переменные объявляются через `$`:
	2. `$primary-color: #3498db;`
	3. `$base-padding: 16px;`
6. Можно ли в SCSS использовать переменные в селекторах и имёнах классов?
	1. Да, через интерполяцию: `$state: "active"; .button-#{$state} {...};`
7. Как в SCSS работают глобальные и локальные переменные?
	1. **Локальные** — объявленные внутри миксина, функции или блока `{}`: видны только внутри этого блока.
	2. **Глобальные в модуле** — объявленные в файле‑модуле (вне функций/миксинов): доступны внутри этого же модуля напрямую и из других файлов — через namespace модуля (`module.$var`) после `@use`.
	3. Переопределять значения из другого файла можно только при подключении: `@use 'module' with ($var: value)` и только если переменная в модуле помечена `!default`.
8. Что в SCSS происходит при переопределении переменной?
	1. Если переменная объявлена с `!default`, она примет новое значение только если оно ещё не задано.
	2. Без `!default` переменные модулей нельзя переопределить через `with` при использовании `@use`; их значение остаётся фиксированным
	3. **Локальная переменная**: не влияет на модуль, модульная переменная остаётся прежней.
	4. Переменные SCSS можно повторно присваивать в том же скоупе.
9. Что делают `!default` и `!global` в SCSS при работе с переменными?
	1. **`!default`** — задаёт значение переменной, только если оно ещё не определено; позволяет переопределить её извне через `@use ... with`.
	2. `!global` — расширяет область присваивания до всего текущего модуля (файла). 
10. Как в SCSS работает вложенность правил?
	1. **Вложенность правил в SCSS** позволяет писать селекторы внутри других селекторов, отражая структуру DOM. Внутренние селекторы компилируются в полные CSS-селекторы, комбинируя родительский путь с потомком.
11. Что делает `&` в SCSS и как его использовать?
	1. **`&`** представляет **родительский селектор** на текущем уровне вложенности.
	2. можно использовать например для создания псевдоклассов и комбинирования с другими селекторами
12. Почему чрезмерная вложенность в SCSS считается антипаттерном?
	1. Увеличивает специфичность селекторов
	2. Глубокие и сложные селекторы увеличивают количество сравнений при рендере и repaint
13. Что такое `@mixin` и `@include` в SCSS?
	1. `@mixin` — это способ объявить набор стилей, который можно многократно переиспользовать.
	2. `@include` вставляет этот набор стилей в нужный селектор.
14. Как в SCSS передавать аргументы в миксины (включая значения по умолчанию)?
	1. Аргументы объявляются при создании миксина с возможностью значений по умолчанию. При вставке миксина через `@include` значения аргументов передаются в круглых скобках, позиционно или по имени.
15. Когда в SCSS использовать `@mixin`, а когда `@extend`?
	1. `@mixin`, когда нужен повторно используемый набор стилей с возможностью передачи аргументов, медиа-запросами или сложной вложенностью.  
	2. `@extend`, когда нужно наследовать стили существующего селектора без дублирования правил, но оно работает только с простыми свойствами и селекторами.
16. Как `@mixin` влияет на размер итогового CSS в SCSS?
	1. `@mixin` влияет на размер итогового CSS тем, что при каждом использовании миксина его содержимое **копируется** в итоговый CSS
17. Как в SCSS работает `@extend`?
	1. `@extend` позволяет одному селектору **наследовать стили другого селектора или placeholder**. В итоговом CSS это приводит к объединению селекторов, что уменьшает размер файла, но может порождать длинные и хрупкие цепочки; чаще предпочтительны `%placeholder` или миксины.
18. Что такое placeholder‑селекторы (`%placeholder`) в SCSS и зачем они нужны?
	1. Placeholder-селекторы (`%placeholder`) в SCSS — это специальные селекторы, которые **не генерируют CSS напрямую**, а используются только для наследования через `@extend`. Они нужны, чтобы **избегать дублирования кода** и **не засорять итоговый CSS лишними классами**.
19. Как в SCSS создать placeholder‑селектор?
	1. Placeholder-селектор создаётся через знак `%` перед именем. Он **не генерирует CSS напрямую**, а служит только для наследования через `@extend`.
20. Что такое функции в SCSS и для чего они нужны?
	1. Функции в SCSS — это блоки кода, которые принимают аргументы, выполняют вычисления или трансформации и возвращают значение. Они нужны для **повторного использования логики**, работы с цветами, числами, строками, картами и списками, чтобы не дублировать код.
21. Как объявлять функции через `@function` в SCSS?
	1. Функции объявляются через `@function`, принимают аргументы и используют `@return` для возврата значения:
22. Какие встроенные функции существуют в SCSS?
	Рекомендуется модульный импорт: `@use 'sass:color'`, `@use 'sass:math'`, `@use 'sass:string'`, `@use 'sass:list'`, `@use 'sass:map'`, `@use 'sass:meta'`. Многие старые функции имеют модульные аналоги (например, `adjust-color` → `color.adjust`, `rgba()` → `color.change`).
	**Цветовые функции**
	- `lighten($color, $amount)` – делает цвет светлее на указанный процент.
	- `darken($color, $amount)` – делает цвет темнее на указанный процент.
	- `adjust-hue($color, $degrees)` – изменяет оттенок цвета на указанный угол.
	- `saturate($color, $amount)` – увеличивает насыщенность цвета на указанный процент.
	- `desaturate($color, $amount)` – уменьшает насыщенность цвета на указанный процент.
	- `mix($color1, $color2, $weight: 50%)` – смешивает два цвета, вес задаёт долю первого цвета.
	- `rgba($color, $alpha)` – возвращает цвет с указанной прозрачностью.
	- `opacify($color, $amount)` / `fade-in($color, $amount)` – делает цвет менее прозрачным.
	- `transparentize($color, $amount)` / `fade-out($color, $amount)` – делает цвет более прозрачным.

	**Числовые функции (в т.ч. через `sass:math`)**
	- `percentage($value)` – преобразует число в процент.
	- `round($value)` – округляет число до ближайшего целого.
	- `ceil($value)` – округляет число вверх.
	- `floor($value)` – округляет число вниз.
	- `abs($value)` – возвращает модуль числа.
	- `min($numbers…)` – возвращает минимальное значение из списка чисел.
	- `max($numbers…)` – возвращает максимальное значение из списка чисел.

	**Строковые функции**
	- `unquote($string)` – убирает кавычки из строки.
	- `quote($string)` – добавляет кавычки к строке.
	- `str-insert($string, $insert, $index)` – вставляет подстроку в указанное место.
	- `str-length($string)` – возвращает длину строки.
	- `str-slice($string, $start-at, $end-at: null)` – возвращает подстроку.
	- `to-upper-case($string)` – переводит строку в верхний регистр.
	- `to-lower-case($string)` – переводит строку в нижний регистр.
	
	**Функции для списков**
	- `nth($list, $n)` – возвращает n-й элемент списка.
	- `length($list)` – возвращает количество элементов списка.
	- `join($list1, $list2, $separator: auto)` – объединяет два списка.
	- `append($list, $val, $separator: auto)` – добавляет элемент в список.
	- `index($list, $value)` – возвращает позицию элемента в списке (или null).
	
	**Функции для карт**
	- `map-get($map, $key)` – возвращает значение по ключу.
	- `map-keys($map)` – возвращает список всех ключей.
	- `map-values($map)` – возвращает список всех значений.
	- `map-merge($map1, $map2)` – объединяет две карты.
	- `map-remove($map, $keys…)` – удаляет ключи из карты.
	- `map-has-key($map, $key)` – проверяет, есть ли ключ в карте (true/false).
	
	**Логические и типовые функции**
	- `type-of($value)` – возвращает тип значения (`number`, `string`, `color`, `list`, `map`, `bool`, `null`).
	- `unit($number)` – возвращает единицу измерения числа (`px`, `em`, `%` и т.п.).
	- `unitless($number)` – проверяет, есть ли у числа единица измерения (true/false).
	- `if($condition, $if-true, $if-false)` – тернарный оператор.
	- `not($value)` – логическое отрицание.
	- `call($function-name, $args…)` – вызывает функцию по имени с аргументами.
	- `feature-exists($feature)` – проверяет поддержку фичи Sass.
	- `function-exists($name)` – проверяет, существует ли функция с таким именем.
23. Что такое списки (`list`) и карты (`map`) в SCSS?
	1. Списки (`list`) в SCSS — это упорядоченные наборы значений, разделённые пробелами или запятыми. Они позволяют хранить несколько значений в одной переменной и получать доступ к элементам через функции `nth()`, `length()`, `join()`, `append()` и т.д.
	2. Карты (`map`) — это ассоциативные массивы, где каждому ключу соответствует значение. С их помощью удобно хранить пары «ключ–значение» и получать данные через `map-get()`, объединять через `map-merge()` и проверять наличие ключа через `map-has-key()`.
24. Как в SCSS выполнять арифметику и операции с единицами измерения?
	1. Поддерживаются `+`, `-`, `*`. Деление «слешем» `/` устарело: используйте `@use 'sass:math'` и `math.div($a, $b)` (кроме случаев, когда `/` — часть CSS‑значения или внутри `calc()`). Совместимые единицы складываются/умножаются, несовместимые — ошибка. `unit($number)` возвращает единицу, `unitless($number)` проверяет её отсутствие.

25. Что такое `@use`, `@forward`, `@import` в Sass?
	1. `@use` — современный способ подключать Sass-модули. Он импортирует файл как модуль с собственным namespace, предотвращая конфликты переменных и миксино
	2. `@forward` используется для проброса содержимого одного модуля через другой, создавая публичный интерфейс.
	3. `@import` — устаревший способ подключения файлов Sass. Он объединял все файлы в один и не имел namespace, что могло приводить к конфликтам переменных. Вместо него следует использовать `@use` и `@forward`.
26. Почему `@import` в Sass устарел и чем его заменить?
	1. `@import` устарел из‑за глобального скоупа и конфликтов. Вместо него используйте `@use` и `@forward`. Для миграции со старого синтаксиса доступен Sass Migrator.
27. Как в Sass использовать namespace при `@use`?
	1. Namespace создаётся автоматически по имени файла или задаётся через `as` (например, `@use 'colors' as theme`). Подстановка в глобальный скоуп через `as *` возможна, но нежелательна.
28. Как в SCSS работают `@if`, `@else`, `@for`, `@each`, `@while`?
	1. `@if` / `@else` — условные ветвления на основе выражений (переменные, функции, сравнения). Поддерживают вложенность и несколько `@else if`.
	2. `@for` — цикл по числовому диапазону. Два варианта: `from A through B` (включительно) и `from A to B` (верхняя граница исключается).
	3. `@each` — перебор коллекций. Работает со списками и картами; для карт используют пару переменных (`$key, $value`). Поддерживает множественное присваивание значений списка в несколько переменных.
	4. `@while` — цикл «пока условие истинно». Использовать осторожно, чтобы избежать бесконечных циклов; предпочтительны `@for`/`@each`, когда это возможно.
	5. Рекомендации: диапазоны — `@for`, списки/карты — `@each`, ветвления — `@if/@else`. Сложную логику выносить в функции/миксины.
29. Как в SCSS использовать `@content` внутри миксинов?
	1. `@content` позволяет вставлять блок кода, который передается при вызове миксина через `@include`. Это удобно для оборачивания стилей или создания обобщенных шаблонов.
30. Что такое 7‑1 архитектура SCSS?
	1. Соглашение сообщества: 7 папок для разных типов стилей и один главный файл `main.scss`. Частичные файлы оформляют как partials с префиксом `_` и подключают через `@use`.
31. Из каких папок состоит архитектура 7‑1 в SCSS?
	1. **abstracts/** — переменные, миксины, функции, плейсхолдеры.
	2. **base/** — reset, типографика, общие элементы.
	3. **components/** — мелкие UI-компоненты.
	4. **layout/** — макет страницы: header, footer, сетка.    
	5. **pages/** — стили конкретных страниц.
	6. **themes/** — темы оформления.
	7. **vendors/** — сторонние библиотеки.
	8.  **main.scss** — основной файл, собирающий все модули.
32. Как в SCSS избегать дублирования и избыточной специфичности?
	1. Чтобы избегать дублирования и избыточной специфичности, используют миксины, функции, переменные, карты и плейсхолдеры (`%placeholder`) вместо повторяющихся правил, минимизируют вложенность селекторов и применяют модульную архитектуру с `@use`/`@forward`
33. Как уменьшить размер итогового CSS при использовании SCSS?
	1. Размер итогового CSS уменьшают через переиспользование миксинов и плейсхолдеров, объединение повторяющихся правил через `@extend`, оптимизацию вложенности и удаление неиспользуемых стилей
34. Какие виды комментариев есть в SCSS?
	1. `//` — строчный комментарий, не попадает в итоговый CSS.
	2. `/* ... */` — блочный комментарий, попадает в CSS (в `compressed` удаляется, если не важно).
35. Для чего используется `@at-root` в SCSS?
	1. Выводит правила на корневой уровень (или к указанному уровню), игнорируя текущую вложенность.
	2. Полезно для генерации модификаторов/медиа без лишней специфичности.
36. Что делают `@error`, `@warn`, `@debug`?
	1. `@error` — бросает ошибку и останавливает компиляцию (используйте для валидации аргументов).
	2. `@warn` — пишет предупреждение, компиляция продолжается.
	3. `@debug` — выводит отладочную информацию (значения переменных, выражений).
37. Как расширенно использовать `@forward` (show/hide/as)?
	1. `@forward 'module' show $var, mixin-name;` — экспортировать только перечисленное API.
	2. `@forward 'module' hide mixin-name;` — скрыть часть API.
	3. `@forward 'module' as theme-*;` — переименовать экспорт (префикс/шаблон имён).
38. Какие операторы поддерживает SCSS?
	1. Равенства/отношения: `==`, `!=`, `<`, `<=`, `>`, `>=` (с учетом типов/единиц).
	2. Числовые: `+`, `-`, `*`; деление `/` устарело — используйте `math.div()`.
	3. Строковые: конкатенация через интерполяцию или `#{}`.
	4. Логические: `and`, `or`, `not`.
