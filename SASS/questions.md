1. Что такое Sass и чем синтаксис SCSS отличается от него?
	- Sass - CSS-препроцессор, который добавляет переменные, вложенность, миксины, функции, условия, циклы, модули и другие возможности, недоступные в обычном CSS.
	- SCSS - один из синтаксисов Sass с синтаксисом, совместимым с CSS (`{}` и `;`).
2. Чем Sass/SCSS отличается от обычного CSS?
	- Sass Добавляет такие возможности как:
		1. Переменные ($var) с !default и !global.
		2. Вложенность селекторов и &.
		3. Миксины (@mixin, @include) с аргументами и @content.
		4. Наследование (@extend, %placeholder).
		5. Функции (@function) и встроенные (darken, lighten, mix, adjust-color, и др.).
		6. Списки и карты (list, map) с функциями (nth, length, map-get, map-merge).
		7. Модули и импорт (@use, @forward, устаревший @import).
		8. Вычисления и арифметика (числа, единицы, цвета, строки).
		9. Управляющие конструкции (@if, @else, @for, @each, @while).
3. Какие преимущества использования SCSS?
	1. Модульность и переиспользуемость: переменные, миксины и функции уменьшают дублирование кода
	2. Вложенность: структура кода отражает DOM
	3. Поддержка архитектуры и масштабируемость: модули, карты, циклы, условия позволяют строить крупные проекты с 7-1 структурой
4. Как в экосистеме Sass компилировать SCSS в CSS и какими инструментами?
	- Dart Sass (`sass`): `npx sass input.scss output.css`.
	- В сборщиках (Vite/Webpack) под капотом - Dart Sass.
5. Как в SCSS объявляются и используются переменные?
	- Переменные объявляются через `$`:
	```sass
	$primary-color: #3498db;
	$base-padding: 16px;
	```
6. Можно ли в SCSS использовать переменные в селекторах и имёнах классов?
	- Да, через интерполяцию
	 ```scss
	 $state: "active";
	.button-#{$state} {...};
	 ```
7. Как в SCSS работают глобальные и локальные переменные?
	- Локальные - объявленные внутри миксина, функции или блока `{}`: видны только внутри этого блока.
	- Глобальные в модуле - объявленные в файле‑модуле (вне функций/миксинов): доступны внутри этого же модуля напрямую и из других файлов (через namespace модуля (`module.$var`) после `@use`).
	- Переопределять значения из другого файла можно только при подключении: `@use 'module' with ($var: value)` и только если переменная в модуле помечена `!default`.
8. Что в SCSS происходит при переопределении переменной?
	1. Если переменная объявлена с `!default`, она примет новое значение только если оно ещё не задано.
	2. Без `!default` переменные модулей нельзя переопределить через `with` при использовании `@use`; их значение остаётся фиксированным.
	3. Локальная переменная: не влияет на модуль, модульная переменная остаётся прежней.
	4. Переменные SCSS можно повторно присваивать в том же скоупе.
9. Что делают `!default` и `!global` в SCSS при работе с переменными?
	- `!default` - задаёт значение переменной, только если оно ещё не определено; позволяет переопределить её извне через `@use ... with`.
	- `!global` - расширяет область присваивания до всего текущего модуля (файла). 
10. Как в SCSS работает вложенность правил?
	- Вложенность правил в SCSS позволяет писать селекторы внутри других селекторов, отражая структуру DOM. Внутренние селекторы компилируются в полные CSS-селекторы, комбинируя родительский путь с потомком.
11. Что делает `&` в SCSS и как его использовать?
	1. `&` представляет родительский селектор на текущем уровне вложенности.
	2. можно использовать например для создания псевдоклассов и комбинирования с другими селекторами
12. Почему чрезмерная вложенность в SCSS считается антипаттерном?
	1. Увеличивает специфичность селекторов
	2. Глубокие и сложные селекторы увеличивают количество сравнений при рендере и repaint
13. Что такое `@mixin` и `@include` в SCSS?
	1. `@mixin` - это способ объявить набор стилей, который можно многократно переиспользовать.
	2. `@include` вставляет этот набор стилей в нужный селектор.
14. Как в SCSS передавать аргументы в миксины (включая значения по умолчанию)?
	- Аргументы объявляются при создании миксина с возможностью значений по умолчанию. При вставке миксина через `@include` значения аргументов передаются в круглых скобках, позиционно или по имени.
	
	```scss
	@mixin button($bg-color: blue, $text-color: white, $padding: 10px) {
	  background-color: $bg-color;
	  color: $text-color;
	  padding: $padding;
	}

	.btn-primary {
	  @include button(red, white, 15px); // позиционно
	  @include button($text-color: black, $bg-color: gray); // по имени
	  @include button; // все значения по умолчанию
	}
	```
15. Когда в SCSS использовать `@mixin`, а когда `@extend`?
	1. `@mixin`, когда нужен повторно используемый набор стилей с возможностью передачи аргументов, медиа-запросами или сложной вложенностью. При каждом использовании содержимое миксина копируется в итоговый CSS.
	2. `@extend`, когда нужно наследовать стили существующего селектора без дублирования правил, но оно работает только с простыми свойствами и селекторами. Стили наследуются, а не копируются.
16. Как `@mixin` влияет на размер итогового CSS в SCSS?
	- `@mixin` влияет на размер итогового CSS тем, что при каждом использовании миксина его содержимое копируется в итоговый CSS в отличии от `@extend` где идет наследование.
17. Как в SCSS работает `@extend`?
	- `@extend` позволяет одному селектору наследовать стили другого селектора или placeholder. В итоговом CSS это приводит к объединению селекторов, что уменьшает размер файла, но может порождать длинные и хрупкие цепочки.
	```scss
	%toolbelt {...}
	.error{...}
	.btn-primary {
	  @extend %toolbelt; 
	  @extend %error; 
	}
	```
18. Что такое placeholder‑селекторы (`%placeholder`) в SCSS и зачем они нужны?
	- Placeholder-селекторы (`%placeholder`) в SCSS - это специальные селекторы, которые не генерируют CSS напрямую, а используются только для наследования через `@extend`. Они нужны, чтобы избегать дублирования кода и не засорять итоговый CSS лишними классами.
	```scss
	%toolbelt {...}
	.btn-primary {
	  @extend %toolbelt; 
	}
	```
19. Как в SCSS создать placeholder‑селектор?
	- Placeholder-селектор создаётся через знак `%` перед именем. Он не генерирует CSS напрямую, а служит только для наследования через `@extend`.
	```scss
	%toolbelt {...}
	.btn-primary {
	  @extend %toolbelt; 
	}
	```
20. Что такое функции в SCSS и для чего они нужны?
	- Функции в SCSS - это блоки кода, которые принимают аргументы, выполняют вычисления или трансформации и возвращают значение. Они нужны для повторного использования логики, работы с цветами, числами, строками, картами и списками, чтобы не дублировать код.
	
	```scss
	@function rem($px) {
	  @return $px / 16px * 1rem;
	}
	
	.text {
	  font-size: rem(24px);
	}
	```
21. Как объявлять функции через `@function` в SCSS?
	- Функции объявляются через `@function`, принимают аргументы и используют `@return` для возврата значения:
	
	```scss
	@function calculate-width($base, $multiplier: 2) {
	  @return $base * $multiplier;
	}
	
	.container {
	  width: calculate-width(100px, 3);
	}
	```
22. Какие встроенные функции существуют в SCSS?
	- Рекомендуется модульный импорт: `@use 'sass:color'`, `@use 'sass:math'`, `@use 'sass:string'`, `@use 'sass:list'`, `@use 'sass:map'`, `@use 'sass:meta'`. Многие старые функции имеют модульные аналоги (например, `adjust-color` → `color.adjust`, `rgba()` → `color.change`).
	1. Цветовые функции
		- `lighten($color, $amount)` – делает цвет светлее на указанный процент.
		- `darken($color, $amount)` – делает цвет темнее на указанный процент.
		- `adjust-hue($color, $degrees)` – изменяет оттенок цвета на указанный угол.
		- `saturate($color, $amount)` – увеличивает насыщенность цвета на указанный процент.
		- `desaturate($color, $amount)` – уменьшает насыщенность цвета на указанный процент.
		- `mix($color1, $color2, $weight: 50%)` – смешивает два цвета, вес задаёт долю первого цвета.
		- `rgba($color, $alpha)` – возвращает цвет с указанной прозрачностью.
		- `opacify($color, $amount)` / `fade-in($color, $amount)` – делает цвет менее прозрачным.
		- `transparentize($color, $amount)` / `fade-out($color, $amount)` – делает цвет более прозрачным.

	2. Числовые функции (в т.ч. через `sass:math`)
		- `percentage($value)` – преобразует число в процент.
		- `round($value)` – округляет число до ближайшего целого.
		- `ceil($value)` – округляет число вверх.
		- `floor($value)` – округляет число вниз.
		- `abs($value)` – возвращает модуль числа.
		- `min($numbers…)` – возвращает минимальное значение из списка чисел.
		- `max($numbers…)` – возвращает максимальное значение из списка чисел.

	3. Строковые функции
		- `unquote($string)` – убирает кавычки из строки.
		- `quote($string)` – добавляет кавычки к строке.
		- `str-insert($string, $insert, $index)` – вставляет подстроку в указанное место.
		- `str-length($string)` – возвращает длину строки.
		- `str-slice($string, $start-at, $end-at: null)` – возвращает подстроку.
		- `to-upper-case($string)` – переводит строку в верхний регистр.
		- `to-lower-case($string)` – переводит строку в нижний регистр.
	
	4. Функции для списков
		- `nth($list, $n)` – возвращает n-й элемент списка.
		- `length($list)` – возвращает количество элементов списка.
		- `join($list1, $list2, $separator: auto)` – объединяет два списка.
		- `append($list, $val, $separator: auto)` – добавляет элемент в список.
		- `index($list, $value)` – возвращает позицию элемента в списке (или null).
	
	5. Функции для карт
		- `map-get($map, $key)` – возвращает значение по ключу.
		- `map-keys($map)` – возвращает список всех ключей.
		- `map-values($map)` – возвращает список всех значений.
		- `map-merge($map1, $map2)` – объединяет две карты.
		- `map-remove($map, $keys…)` – удаляет ключи из карты.
		- `map-has-key($map, $key)` – проверяет, есть ли ключ в карте (true/false).
	
	6. Логические и типовые функции
		- `type-of($value)` – возвращает тип значения (`number`, `string`, `color`, `list`, `map`, `bool`, `null`).
		- `unit($number)` – возвращает единицу измерения числа (`px`, `em`, `%` и т.п.).
		- `unitless($number)` – проверяет, есть ли у числа единица измерения (true/false).
		- `if($condition, $if-true, $if-false)` – тернарный оператор.
		- `not($value)` – логическое отрицание.
		- `call($function-name, $args…)` – вызывает функцию по имени с аргументами.
		- `feature-exists($feature)` – проверяет поддержку фичи Sass.
		- `function-exists($name)` – проверяет, существует ли функция с таким именем.
23. Что такое списки (`list`) и карты (`map`) в SCSS?
	 - Списки (`list`) в SCSS - это упорядоченные наборы значений, разделённые пробелами или запятыми. Они позволяют хранить несколько значений в одной переменной и получать доступ к элементам через функции `nth()`, `length()`, `join()`, `append()` и т.д.
	- Карты (`map`) - это ассоциативные массивы, где каждому ключу соответствует значение. С их помощью удобно хранить пары «ключ–значение» и получать данные через `map-get()`, объединять через `map-merge()` и проверять наличие ключа через `map-has-key()`.
	
	```scss
	$colors: red, green, blue;
	$first-color: nth($colors, 1); // red
	
	$theme: (
	  primary: #007bff,
	  secondary: #6c757d
	);
	$primary-color: map-get($theme, primary); // #007bff
	```
24. Как в SCSS выполнять арифметику и операции с единицами измерения?
	- Поддерживаются `+`, `-`, `*`, `%` (модуло). Деление «слешем» `/` deprecated и будет удалено в будущих версиях: рекомендуется использовать `@use 'sass:math'` и `math.div($a, $b)` (кроме случаев, когда `/` - часть CSS‑значения или внутри `calc()`).

25. Что такое `@use`, `@forward`, `@import` в Sass?
	- `@use` - современный способ подключать Sass-модули. Он импортирует файл как модуль с собственным namespace, предотвращая конфликты переменных и миксино
	- `@forward` используется для проброса содержимого одного модуля через другой, создавая публичный интерфейс.
	- `@import` - устаревший способ подключения файлов Sass. Он объединял все файлы в один и не имел namespace, что могло приводить к конфликтам переменных. Вместо него следует использовать `@use` и `@forward`.
	
	```scss
	// _colors.scss
	$primary: #007bff;
	@mixin button-style { color: $primary; }
	
	// _index.scss
	@forward 'colors';
	
	// main.scss
	@use 'index' as theme;
	.btn { @include theme.button-style; }
	```
26. Почему `@import` в Sass устарел и чем его заменить?
	- `@import` устарел из‑за глобального скоупа и конфликтов. Вместо него используйте `@use` и `@forward`. Для миграции со старого синтаксиса доступен Sass Migrator.
27. Как в Sass использовать namespace при `@use`?
	- Namespace создаётся автоматически по имени файла или задаётся через `as` (например, `@use 'colors' as theme`). Подстановка в глобальный скоуп через `as *` возможна, но нежелательна.
28. Как в SCSS работают `@if`, `@else`, `@for`, `@each`, `@while`?
	-  `@if` / `@else` - условные ветвления на основе выражений (переменные, функции, сравнения). Поддерживают вложенность и несколько `@else if`.
	-  `@for` - цикл по числовому диапазону. Два варианта: `from A through B` (включительно) и `from A to B` (верхняя граница исключается).
	-  `@each` - перебор коллекций. Работает со списками и картами; для карт используют пару переменных (`$key, $value`). Поддерживает множественное присваивание значений списка в несколько переменных.
	-  `@while` - цикл «пока условие истинно». Использовать осторожно, чтобы избежать бесконечных циклов; предпочтительны `@for`/`@each`, когда это возможно.
	- Рекомендации: диапазоны - `@for`, списки/карты - `@each`, ветвления - `@if/@else`. Сложную логику выносить в функции/миксины.
	
	```scss
	// @if/@else
	$theme: dark;
	@if $theme == dark {
	  background: black;
	} @else {
	  background: white;
	}
	
	// @for
	@for $i from 1 through 3 {
	  .item-#{$i} { width: 100px * $i; }
	}
	
	// @each
	$colors: red, green, blue;
	@each $color in $colors {
	  .#{$color} { color: $color; }
	}
	```
29. Как в SCSS использовать `@content` внутри миксинов?
	- `@content` позволяет вставлять блок кода, который передается при вызове миксина через `@include`. Это удобно для оборачивания стилей или создания обобщенных шаблонов.
	
	```scss
	@mixin media($breakpoint) {
	  @media (min-width: $breakpoint) {
	    @content;
	  }
	}
	
	.container {
	  @include media(768px) {
	    padding: 20px;
	  }
	}
	```
30. Что такое 7‑1 архитектура SCSS?
	- Соглашение сообщества: 7 папок для разных типов стилей и один главный файл `main.scss`. Частичные файлы оформляют как partials с префиксом `_` и подключают через `@use`.
	
	```
	scss/
	├── abstracts/
	├── base/
	├── components/
	├── layout/
	├── pages/
	├── themes/
	├── vendors/
	└── main.scss
	```
31. Из каких папок состоит архитектура 7‑1 в SCSS?
	1. abstracts/ - переменные, миксины, функции, плейсхолдеры.
	2. base/ - reset, типографика, общие элементы.
	3. components/ - мелкие UI-компоненты.
	4. layout/ - макет страницы: header, footer, сетка.    
	5. pages/ - стили конкретных страниц.
	6. themes/ - темы оформления.
	7. vendors/ - сторонние библиотеки.
	8. main.scss - основной файл, собирающий все модули.
	
32. Как в SCSS избегать дублирования и избыточной специфичности?
	1. Чтобы избегать дублирования и избыточной специфичности, используют миксины, функции, переменные, карты и плейсхолдеры (`%placeholder`) вместо повторяющихся правил, минимизируют вложенность селекторов и применяют модульную архитектуру с `@use`/`@forward`
	

33. Как уменьшить размер итогового CSS при использовании SCSS?
	1. Размер итогового CSS уменьшают через переиспользование миксинов и плейсхолдеров, объединение повторяющихся правил через `@extend`, оптимизацию вложенности и удаление неиспользуемых стилей

34. Какие виды комментариев есть в SCSS?
	1. `//` - строчный комментарий, не попадает в итоговый CSS.
	2. `/* ... */` - блочный комментарий, попадает в CSS (в `compressed` удаляется, если не важно).
	
	```scss
	// Этот комментарий не попадет в CSS
	$color: blue; /* Этот попадет в CSS */
	
	/*! Важный комментарий - не удаляется даже в compressed */
	```
35. Для чего используется `@at-root` в SCSS?
	1. Выводит правила на корневой уровень (или к указанному уровню), игнорируя текущую вложенность.
	2. Полезно для генерации модификаторов/медиа без лишней специфичности.
	
	```scss
	.parent {
	  color: red;
	  
	  @at-root .child {
	    color: blue; // Будет .child, а не .parent .child
	  }
	}
	```
36. Что делают `@error`, `@warn`, `@debug`?
	1. `@error` - бросает ошибку и останавливает компиляцию (используйте для валидации аргументов).
	2. `@warn` - пишет предупреждение, компиляция продолжается.
	3. `@debug` - выводит отладочную информацию (значения переменных, выражений).
	
	```scss
	@function divide($a, $b) {
	  @if $b == 0 {
	    @error "Division by zero is not allowed";
	  }
	  @warn "Using deprecated division function";
	  @debug "Dividing #{$a} by #{$b}";
	  @return $a / $b;
	}
	```
37. Как расширенно использовать `@forward` (show/hide/as)?
	1. `@forward 'module' show $var, mixin-name;` - экспортировать только перечисленное API.
	2. `@forward 'module' hide mixin-name;` - скрыть часть API.
	3. `@forward 'module' as theme-*;` - переименовать экспорт (префикс/шаблон имён).
	
	```scss
	// _index.scss
	@forward 'colors' show $primary, $secondary;
	@forward 'mixins' hide internal-mixin;
	@forward 'utils' as theme;
	```
38. Какие операторы поддерживает SCSS?
	1. Равенства/отношения: `==`, `!=`, `<`, `<=`, `>`, `>=` (с учетом типов/единиц).
	2. Числовые: `+`, `-`, `*`; деление `/` устарело - используйте `math.div()`.
	3. Строковые: конкатенация через интерполяцию или `#{}`.
	4. Логические: `and`, `or`, `not`.
	
	```scss
	$width: 100px;
	$height: 50px;
	
	@if $width > $height and $width == 100px {
	  .box { 
	    width: $width + 10px;
	    content: "Width is #{$width}";
	  }
	}
	```
