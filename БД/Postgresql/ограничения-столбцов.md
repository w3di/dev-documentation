## Ограничения столбцов (Constraints) в SQL

Ограничения (Constraints) — это правила, применяемые к данным в таблице для поддержания их точности и надёжности. Они играют важную роль в обеспечении целостности данных и соответствия бизнес-правилам.

Когда вы создаёте таблицу или изменяете её структуру, вы можете определить различные ограничения, которые предотвращают добавление, изменение или удаление данных, нарушающих установленные правила.

Это помогает избежать нежелательных ситуаций:
- Наличие нескольких пользователей с одинаковыми идентификаторами
- Ссылки на несуществующие записи в других таблицах
- Отсутствие обязательных данных
- Ввод некорректных значений (например, отрицательного возраста или будущей даты рождения)

## Основные типы ограничений в SQL

- `PRIMARY KEY` — уникальный идентификатор записи в таблице
- `FOREIGN KEY` — обеспечивает ссылочную целостность между таблицами
- `UNIQUE` — гарантирует уникальность значений в столбце или группе столбцов
- `NOT NULL` — запрещает NULL-значения в столбце
- `CHECK` — проверяет соответствие данных заданному условию
- `DEFAULT` — устанавливает значение по умолчанию для столбца

## PRIMARY KEY (Первичный ключ)

Первичный ключ — это столбец или комбинация столбцов, которые однозначно идентифицируют каждую строку в таблице.

Особенности:
- Не может содержать NULL-значения
- Должен быть уникальным
- Таблица может иметь только один первичный ключ

Синтаксис:

```sql
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);
```

Альтернативный синтаксис с именованным ограничением:

```sql
CREATE TABLE Users (
    id SERIAL,
    username VARCHAR(50),
    email VARCHAR(100),
    CONSTRAINT pk_users PRIMARY KEY (id)
);
```

При нарушении ограничения:

```
ERROR: duplicate key value violates unique constraint "users_pkey"
DETAIL: Key (id)=(1) already exists.
```

## FOREIGN KEY (Внешний ключ)

Внешний ключ — это столбец или группа столбцов в одной таблице, которые ссылаются на первичный ключ другой таблицы.

Он обеспечивает ссылочную целостность данных, гарантируя, что значения в столбце внешнего ключа соответствуют значениям из столбца первичного ключа связанной таблицы.

Синтаксис:

```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    FOREIGN KEY (user_id) REFERENCES Users(id)
);
```

Благодаря ограничению `FOREIGN KEY`:
- Нельзя добавить заказ для несуществующего пользователя
- Нельзя удалить пользователя, у которого есть заказы (если не указаны специальные опции)

### Действия при изменении связанных данных

```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    FOREIGN KEY (user_id) REFERENCES Users(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);
```

Опции для `ON DELETE` и `ON UPDATE`:

`CASCADE`:
- Автоматически удаляет или обновляет связанные записи

`SET NULL`:
- Устанавливает NULL для внешнего ключа

`SET DEFAULT`:
- Устанавливает значение по умолчанию

`RESTRICT`:
- Запрещает удаление или обновление (используется по умолчанию)

`NO ACTION`:
- Аналогично `RESTRICT` в большинстве СУБД

## UNIQUE (Уникальность)

Ограничение `UNIQUE` гарантирует, что все значения в столбце или группе столбцов уникальны.

В отличие от `PRIMARY KEY`:
- Допускает NULL-значения (обычно только одно NULL-значение)
- Может быть несколько UNIQUE ограничений в одной таблице

Синтаксис:

```sql
CREATE TABLE Users (
    id INT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100) UNIQUE
);
```

Это предотвратит создание нескольких пользователей с одинаковым именем пользователя или адресом электронной почты.

## NOT NULL (Запрет пустых значений)

Ограничение `NOT NULL` гарантирует, что столбец не может содержать NULL-значения.

Это полезно для обязательных полей, без которых запись не имеет смысла.

Синтаксис:

```sql
CREATE TABLE Users (
    id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    bio TEXT
);
```

В этом примере поля `username` и `email` обязательны, а `bio` может быть пустым.

## CHECK (Проверка условия)

Ограничение `CHECK` позволяет определить условие, которому должны соответствовать значения в столбце.

Это помогает обеспечить бизнес-правила и предотвратить ввод некорректных данных.

Простой пример:

```sql
CREATE TABLE Products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) CHECK (price > 0),
    quantity INT CHECK (quantity >= 0)
);
```

Более сложный пример с именованным ограничением:

```sql
CREATE TABLE Employees (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    birth_date DATE NOT NULL,
    hire_date DATE NOT NULL,
    CONSTRAINT chk_dates CHECK (hire_date > birth_date)
);
```

PostgreSQL поддерживает сложные CHECK ограничения с регулярными выражениями:

```sql
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(100) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    age INT CHECK (age >= 0 AND age <= 150)
);
```

## DEFAULT (Значение по умолчанию)

Ограничение `DEFAULT` устанавливает значение, которое будет использовано, если при добавлении новой записи не указано значение для этого столбца.

Синтаксис:

```sql
CREATE TABLE Orders (
    order_id SERIAL PRIMARY KEY,
    user_id INT,
    order_date DATE DEFAULT CURRENT_DATE,
    status VARCHAR(20) DEFAULT 'Pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES Users(id)
);
```

PostgreSQL поддерживает сложные DEFAULT значения с функциями:

```sql
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW(),
    uuid_field UUID DEFAULT gen_random_uuid()
);
```

## Добавление и удаление ограничений

Ограничения можно добавлять при изменении таблицы:

### Добавление ограничений

```sql
ALTER TABLE Users
ADD PRIMARY KEY (id);

ALTER TABLE Orders
ADD CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES Users(id);

ALTER TABLE Users
ADD CONSTRAINT uq_email UNIQUE (email);

ALTER TABLE Products
ADD CONSTRAINT chk_price CHECK (price > 0);

ALTER TABLE Users
ALTER COLUMN username SET NOT NULL;

ALTER TABLE Orders
ALTER COLUMN status SET DEFAULT 'Pending';
```

### Удаление ограничений

```sql
ALTER TABLE Users
DROP CONSTRAINT users_pkey;

ALTER TABLE Orders
DROP CONSTRAINT fk_user;

ALTER TABLE Users
DROP CONSTRAINT uq_email;

ALTER TABLE Products
DROP CONSTRAINT chk_price;

ALTER TABLE Users
ALTER COLUMN username DROP NOT NULL;

ALTER TABLE Orders
ALTER COLUMN status DROP DEFAULT;
```

## Лучшие практики использования ограничений

Всегда определяйте первичный ключ:
- Для каждой таблицы
- Для однозначной идентификации каждой записи

Используйте внешние ключи:
- Для обеспечения ссылочной целостности между связанными таблицами

Применяйте NOT NULL:
- Для столбцов, которые должны содержать значения

Используйте UNIQUE:
- Для столбцов с уникальными значениями (email, номер телефона)

Добавляйте CHECK:
- Для столбцов, значения которых должны соответствовать бизнес-правилам

Устанавливайте DEFAULT:
- Для столбцов, которые часто принимают одно и то же значение

Указывайте имена для ограничений:
- Например: `CONSTRAINT pk_users PRIMARY KEY (id)`
- Облегчает идентификацию и управление

## Примеры использования

### Таблица пользователей с различными ограничениями

```sql
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    age INT CHECK (age >= 18),
    created_at TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20) DEFAULT 'active'
);
```

### Таблица заказов с внешними ключами

```sql
CREATE TABLE Orders (
    order_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    total_amount DECIMAL(10, 2) CHECK (total_amount >= 0),
    order_date DATE DEFAULT CURRENT_DATE,
    status VARCHAR(20) DEFAULT 'pending',
    FOREIGN KEY (user_id) REFERENCES Users(id)
        ON DELETE RESTRICT
        ON UPDATE CASCADE
);
```

### Таблица продуктов с комплексными ограничениями

```sql
CREATE TABLE Products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    discount_price DECIMAL(10, 2),
    quantity INT NOT NULL DEFAULT 0,
    category_id INT,
    CONSTRAINT chk_price_positive CHECK (price > 0),
    CONSTRAINT chk_quantity_non_negative CHECK (quantity >= 0),
    CONSTRAINT chk_discount_less_than_price CHECK (discount_price IS NULL OR discount_price < price),
    FOREIGN KEY (category_id) REFERENCES Categories(id)
        ON DELETE SET NULL
);
```

## Итоги

Ограничения (Constraints) — важный инструмент для обеспечения целостности данных:
- Предотвращают ввод некорректных данных
- Обеспечивают соответствие бизнес-правилам
- Поддерживают ссылочную целостность
- Автоматизируют проверку данных на уровне базы данных
- Упрощают разработку и поддержку приложений
