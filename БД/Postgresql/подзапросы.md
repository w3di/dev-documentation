## Подзапросы

Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.

Подзапросы можно использовать в любых видах запросов.

Типы результирующих наборов подзапроса:

Подзапрос возвращает результирующий набор, который может быть одним из следующих:
- одна строка и один столбец
- несколько строк с одним столбцом
- несколько строк с несколькими столбцами

В зависимости от типа результирующего набора подзапроса определяются операторы, которые могут использоваться в основном запросе.

```sql
SELECT * FROM Reservations
WHERE Reservations.room_id = (
    SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
)
```
Пример подзапроса: получает список всех бронирований самого дорогого жилого помещения

В данном случае запрос на получение самого дорогого жилого помещения выполняется в качестве подзапроса, а затем результат результирующего набора применяется в основном запросе.

## Подзапрос с одной строкой и одним столбцом (скалярный подзапрос)

Скалярный подзапрос возвращает одну строку и один столбец.

Может использоваться в различных частях основного SQL запроса, но чаще всего используется в условиях ограничений выборки с помощью операторов сравнения (=, <>, >, <).

```sql
SELECT (SELECT name FROM company LIMIT 1) AS company_name;
```
Пример скалярного подзапроса в SELECT

```sql
SELECT * FROM FamilyMembers
WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
```
Пример скалярного подзапроса в WHERE: получает самого младшего члена семьи

Подзапрос в данном случае необходим для получения максимальной даты рождения, которая затем используется в основном запросе для фильтрации строк.

Важно: при использовании результата подзапроса с операторами сравнения подзапрос должен возвращать именно скалярное значение (1 строка и 1 колонка). Если подзапрос вернёт несколько значений, СУБД вернёт ошибку.

## Подзапрос с несколькими строками и одним столбцом

Если подзапрос возвращает более одной строки, его нельзя использовать с операторами сравнения напрямую, как скалярные подзапросы.

С подзапросами, возвращающими несколько строк и один столбец, можно использовать операторы ALL, IN и ANY.

## Подзапрос и оператор ALL

ALL сравнивает отдельное значение с каждым значением в наборе, полученным подзапросом. Условие вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.

```sql
SELECT 200 > ALL(SELECT price FROM Rooms)
```
Проверяет, для всех ли жилых помещений выполняется условие, что оно дешевле чем 200

```sql
SELECT DISTINCT name FROM Users INNER JOIN Rooms
    ON Users.id = Rooms.owner_id
    WHERE Users.id <> ALL (
        SELECT DISTINCT user_id FROM Reservations
    )
```
Находит имена всех владельцев жилья, которые никогда не снимали жилье

## Подзапрос и оператор IN

IN проверяет, входит ли конкретное значение в набор значений. В качестве такого набора может использоваться подзапрос, возвращающий несколько строк с одним столбцом.

```sql
SELECT * FROM Users WHERE id IN (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
Получает всю информацию о владельцах жилья стоимостью больше 150

## Подзапрос и оператор ANY

ANY возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.

```sql
SELECT * FROM Users WHERE id = ANY (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
Находит пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150

## Разница между IN и ANY

IN и ANY работают по-разному:

IN:
- Работает только с оператором равенства (=)
- Проверяет, входит ли значение в набор значений
- Синтаксис: `поле IN (подзапрос)`
- Эквивалентно `поле = ANY (подзапрос)`

ANY:
- Работает с любыми операторами сравнения (=, <>, >, <, >=, <=)
- Проверяет, выполняется ли условие хотя бы для одного значения из набора
- Синтаксис: `поле оператор ANY (подзапрос)`
- Более гибкий оператор, позволяет использовать разные условия сравнения

```sql
SELECT * FROM Users WHERE id IN (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
Проверяет вхождение id в набор owner_id (эквивалентно = ANY)

```sql
SELECT * FROM Users WHERE id = ANY (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
То же самое через ANY с оператором равенства

```sql
SELECT * FROM Rooms WHERE price > ANY (
    SELECT price FROM Rooms WHERE home_type = 'Flat'
)
```
Выбирает помещения, цена которых больше хотя бы одной цены квартиры (с ANY можно использовать другие операторы)

В случае равенства (=) операторы IN и = ANY эквивалентны, но ANY более универсален, так как работает с другими операторами сравнения.

## Многостолбцовые подзапросы

Подзапросы могут возвращать несколько столбцов и несколько строк (производные таблицы).

SQL поддерживает сравнение не только по одной колонке, но позволяет попарно сравнивать значения в основном запросе со значениями в подзапросе.

```sql
SELECT * FROM Reservations
WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
```
Сравнение по нескольким столбцам: получает информацию о всех бронированиях, в которых цена жилья на момент брони соответствует текущей стоимости жилья

В данном примере подзапрос возвращает таблицу с идентификаторами жилых помещений и их текущей ценой, а затем ограничивает все бронирования только теми, в которых пара значений room_id и price найдётся в таблице подзапроса.

Количество столбцов в основном запросе и в подзапросе должно совпадать.

Альтернативное решение через JOIN:

```sql
SELECT Reservations.* FROM Reservations
INNER JOIN Rooms
ON Reservations.room_id = Rooms.id
WHERE Reservations.price = Rooms.price;
```
Тот же результат через JOIN, но решение более объёмное

## Коррелированные подзапросы

Все предыдущие подзапросы были некоррелированные (независимые). Они выполнялись автономно от основного запроса.

Коррелированные подзапросы ссылаются на один или несколько столбцов основного запроса.

Отличие от некоррелированных подзапросов:

Некоррелированный подзапрос:
- Выполняется один раз перед выполнением основного запроса
- Результат подзапроса используется в основном запросе

Коррелированный подзапрос:
- Выполняется для каждой строки основного запроса
- Ссылается на столбцы из основного запроса
- Не может быть выполнен автономно

```sql
SELECT FamilyMembers.member_name, (
    SELECT SUM(Payments.unit_price * Payments.amount)
    FROM Payments
    WHERE Payments.family_member = FamilyMembers.member_id
) AS total_spent
FROM FamilyMembers;
```
Пример коррелированного подзапроса: находит, кто и сколько потратил

В данном случае коррелированный подзапрос ссылается к столбцу member_id из основного запроса (FamilyMembers.member_id).

Для каждой строки таблицы FamilyMembers выполняется отдельный подзапрос, который суммирует траты соответствующего члена семьи.

## Влияние на производительность

Использование коррелированных подзапросов может вызвать проблемы с производительностью, особенно если основной запрос возвращает много строк, так как коррелированный подзапрос выполняется для каждой строки основного запроса отдельно.

Если основной запрос возвращает N строк, то коррелированный подзапрос выполнится N раз.

В таких случаях стоит рассмотреть альтернативные решения через JOIN или другие методы оптимизации.
