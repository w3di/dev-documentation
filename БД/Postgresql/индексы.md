## Индексы в SQL

Когда вы добавляете в таблицу новую строку, СУБД размещает эти данные не оптимально. Она просто помещает данные в следующее доступное место в файле.

Это приводит к тому, что для выполнения запроса серверу базы данных приходится проверять каждую строку таблицы, чтобы найти соответствия. Это подходит для маленьких таблиц, но становится чрезмерно времязатратным по мере роста объёма данных.

## Что такое индексы

Индексы функционируют как предметные указатели в книге, позволяя быстро находить информацию без прочтения всего текста.

Они представляют собой специальные таблицы, строки которых расположены в строго определённом порядке. Но вместо того, чтобы содержать все данные о некоторой записи, индекс содержит только столбец (или столбцы), используемый для поиска строк в таблице данных, вместе с информацией, описывающей, где физически расположена эта строка.

Роль индексов состоит в том, чтобы облегчить поиск подмножества строк и столбцов таблицы без необходимости сканировать каждую строку в таблице.

## Создание индекса

Для ускорения запросов, которые работают со значением столбца `email` в таблице `Users`, можно добавить индекс:

```sql
CREATE INDEX idx_email
    ON Users (email);
```

Эта инструкция создаёт индекс c именем `idx_email` для столбца `Users.email`.

При наличии индекса оптимизатор запросов может выбрать использование индекса, если сочтёт это полезным. Если в таблице имеется более одного индекса, оптимизатор должен решить, применение какого именно индекса наиболее выгодно для конкретной инструкции SQL.

## Просмотр существующих индексов

Для просмотра всех индексов для конкретной таблицы в PostgreSQL:

```sql
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'users';
```

Результат:

```
indexname     indexdef
users_pkey    CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id)
idx_email     CREATE INDEX idx_email ON public.users USING btree (email)
```

PostgreSQL автоматически создаёт индекс для столбца первичного ключа. Это особый тип индекса, используемый с ограничением первичного ключа, которое гарантирует, что каждое значение уникально и не может быть `NULL`.

## Типы индексов в PostgreSQL

PostgreSQL поддерживает различные типы индексов:

`B-tree` (по умолчанию):
- Для операций сравнения и сортировки
- Используется в большинстве случаев

`Hash`:
- Для операций равенства
- Эффективен для простых сравнений на равенство

`GIN`:
- Для составных значений (массивы, JSON)
- Полнотекстовый поиск

`GiST`:
- Для геометрических данных и полнотекстового поиска
- Поддержка пользовательских типов данных

`BRIN`:
- Для очень больших таблиц с естественной сортировкой
- Занимает мало места

## Удаление индекса

Если индекс больше не нужен, его можно удалить:

```sql
DROP INDEX idx_email;
```

## Уникальные (UNIQUE) индексы

При проектировании баз данных важно определить, для каких столбцов допускаются повторения значений, а для каких — нет.

Уникальный индекс выполняет две функции:
- Обеспечивает все преимущества стандартного индекса
- Предотвращает дублирование значений в индексируемом столбце

Создание уникального индекса:

```sql
CREATE UNIQUE INDEX idx_email
    ON Users (email);
```

При попытке добавить дублирующееся значение вы получите ошибку:

```
ERROR: duplicate key value violates unique constraint "idx_email"
DETAIL: Key (email)=(duplicate@gmail.com) already exists.
```

Важно: Создание уникальных индексов для столбцов первичного ключа излишне, так как СУБД автоматически обеспечивает уникальность значений первичного ключа.

## Многостолбцовые индексы

Существует возможность создавать индексы, включающие несколько столбцов:

```sql
CREATE INDEX idx_full_name
    ON Student (last_name, first_name);
```

Такой индекс полезен для запросов, где необходимы:
- И имя, и фамилия
- Только фамилия (первый столбец в индексе)

Однако для запросов, задающих только имя, он не принесёт пользы.

Это аналогично поиску номера телефона по телефонному справочнику: если известны и имя, и фамилия, поиск упрощается благодаря упорядоченности справочника по фамилии, а затем по имени. Если же известно только имя, придётся перебирать все записи.

При создании индексов с несколькими столбцами важно продумать порядок столбцов в индексе для максимальной эффективности.

## Как используются индексы

Индексы часто применяются СУБД для эффективного поиска нужных строк в таблице.

Пример запроса:

```sql
SELECT id, first_name, last_name
  FROM Student
  WHERE first_name LIKE 'A%' AND last_name LIKE 'L%'
```

СУБД может выбрать один из подходов:

1. Произвести полное сканирование всех строк таблицы
2. Воспользоваться индексом по столбцу `last_name` для поиска студентов с фамилией на «L»
3. Использовать составной индекс по `last_name` и `first_name` для непосредственного нахождения студентов

Последний метод наиболее эффективен, так как позволяет найти все необходимые строки за один проход.

## Анализ плана выполнения запроса

Для определения, какой метод выберет оптимизатор запросов, используется команда `EXPLAIN`:

```sql
EXPLAIN
  SELECT id, first_name, last_name
  FROM Student
  WHERE first_name LIKE 'A%'
  AND last_name LIKE 'L%';
```

Результат:

```
QUERY PLAN
Index Scan using idx_full_name on student (cost=0.42..8.44 rows=1 width=68)
Index Cond: ((last_name >= 'L'::text) AND (last_name < 'M'::text))
Filter: ((first_name ~~ 'A%'::text) AND (last_name ~~ 'L%'::text))
```

Для получения реальной статистики выполнения:

```sql
EXPLAIN ANALYZE
  SELECT id, first_name, last_name
  FROM Student
  WHERE first_name LIKE 'A%'
  AND last_name LIKE 'L%';
```

Результат:

```
QUERY PLAN
Index Scan using idx_full_name on student (cost=0.42..8.44 rows=1 width=68) (actual time=0.025..0.027 rows=1 loops=1)
Index Cond: ((last_name >= 'L'::text) AND (last_name < 'M'::text))
Filter: ((first_name ~~ 'A%'::text) AND (last_name ~~ 'L%'::text))
Planning Time: 0.156 ms
Execution Time: 0.048 ms
```

Анализируя результаты `EXPLAIN`, можно увидеть, какой метод доступа выбрал оптимизатор:
- `Seq Scan` — полное сканирование таблицы
- `Index Scan` — сканирование индекса

## Обратная сторона индексов

Почему бы просто не индексировать всё подряд?

Недостатки индексов:

Замедление операций записи:
- Каждый раз, когда строка добавляется или удаляется, все индексы должны быть изменены
- При обновлении строки любые индексы для затронутых столбцов также должны быть изменены
- Чем больше индексов, тем больше работы для СУБД

Дополнительное место на диске:
- Каждый индекс представляет собой таблицу
- Индексы занимают дополнительное место на диске

Требуют управления:
- Необходимо внимательное управление со стороны администраторов баз данных

## Рекомендации по использованию индексов

Создавайте индексы только тогда, когда это действительно необходимо:
- Для столбцов, часто используемых в условиях `WHERE`
- Для столбцов, используемых в `JOIN`
- Для столбцов, используемых в `ORDER BY`

Временные индексы:
- Можно создать индекс перед выполнением процедуры (например, месячного отчёта)
- Удалить после её завершения

Найдите баланс:
- Иметь достаточно индексов для эффективной работы
- Но не столько, чтобы это сказывалось на производительности

Если не уверены:
- Начните с минимального числа индексов
- Добавляйте по мере необходимости

## Примеры использования

### Индекс для поиска по email

```sql
CREATE INDEX idx_email ON Users (email);

SELECT * FROM Users WHERE email = 'user@example.com';
```

### Уникальный индекс для предотвращения дублей

```sql
CREATE UNIQUE INDEX idx_username ON Users (username);

INSERT INTO Users (username, email) VALUES ('john_doe', 'john@example.com');
```

### Составной индекс для сложных запросов

```sql
CREATE INDEX idx_status_date ON Orders (status, order_date);

SELECT * FROM Orders 
WHERE status = 'pending' 
ORDER BY order_date DESC;
```

### Частичный индекс (только для определённых строк)

```sql
CREATE INDEX idx_active_users ON Users (email) WHERE is_active = true;

SELECT * FROM Users WHERE email LIKE '%@gmail.com' AND is_active = true;
```

## Итоги

Индексы — мощный инструмент для оптимизации производительности запросов:
- Ускоряют операции чтения данных
- Обеспечивают уникальность значений
- Требуют баланса между скоростью чтения и записи
- Необходимо тщательно планировать их использование
