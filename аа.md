### JavaScript

13. Приведение типов (type coercion) и преобразование типов (type conversion)

Приведение типов - это автоматическое преобразование типов JavaScript при выполнении операций. Например:
Преобразование типов - это явное преобразование с помощью функций:


Number("5") // 5 (явное преобразование)

String(5) // "5" (явное преобразование)
 Способы объявления функций

15. Function Declaration:

16. Function Expression:

17. Arrow Function:


18. Named Function Expression:
    


Основные различия:

- Function Declaration поднимается (hoisting)

- Arrow functions не имеют своего this и arguments

- Function Expression может быть анонимной

15. Promises

Promise - это объект, представляющий асинхронную операцию. Состояния:

- Pending (ожидание)

- Fulfilled (выполнено успешно)

- Rejected (выполнено с ошибкой)

16. async/await

Это синтаксический сахар для работы с Promise:

javascript

Apply to enter-email....

async function getData() {

  try {

    const response = await fetch(url);

    const data = await response.json();

    return data;

  } catch (error) {

    console.error(error);

  }

}

17. forEach vs map

- forEach выполняет функцию для каждого элемента, не возвращает новый массив

- map создает новый массив с результатами вызова функции для каждого элемента

### TypeScript

18. interface vs type

typescript

Apply to enter-email....

interface User {

  name: string;

  age: number;

}

type User = {

  name: string;

  age: number;

}

interface лучше использовать когда:

- Определяем публичное API

- Нужно расширение через declaration merging

- Работаем с объектно-ориентированным кодом

type лучше когда:

- Определяем union/intersection типы

- Работаем с примитивами

- Нужна более гибкая типизация

19. any vs unknown

- any отключает проверку типов

- unknown требует явного приведения типов перед использованием

20. Union Type vs Intersection Type

typescript

Apply to enter-email....

type Union = string | number; // может быть строкой ИЛИ числом

type Intersection = { name: string } & { age: number }; // должен быть строкой И числом

### Хуки и управление состоянием

8. Хуки

Хуки - это функции для использования состояния и других возможностей React в функциональных компонентах. Основные:

- useState

- useEffect

- useContext

- useReducer

- useCallback

- useMemo

9. Глобальное состояние

В крупных приложениях React Native я использую:

- Redux Toolkit (как видно в package.json)

- Context API для локального состояния

- AsyncStorage для персистентного хранения

10. Стейт-менеджмент

В проекте используется Redux Toolkit, что видно из зависимостей:

json

Apply to enter-email....

"@reduxjs/toolkit": "^2.6.1",

"react-redux": "^9.2.0"

### Основы React Native

1. React Native

React Native - это фреймворк для создания нативных мобильных приложений с использованием React. Он компилирует JavaScript код в нативные компоненты.

2. Взаимодействие с нативным кодом

React Native использует мост (Bridge) для передачи данных между JavaScript и нативным кодом. Это происходит через сериализацию/десериализацию данных.

3. Мост (Bridge)

Bridge - это асинхронный канал связи между JavaScript и нативным кодом. Он используется для:

- Вызова нативных методов

- Передачи данных

- Обработки событий

### Работа с UI и стилями

4. StyleSheet.create()

javascript

Apply to enter-email....

const styles = StyleSheet.create({

  container: {

    flex: 1,

    backgroundColor: '#fff'

  }

});

Преимущества:

- Валидация стилей

- Оптимизация производительности

- Лучшая поддержка IDE

5. View vs SafeAreaView

- View - базовый контейнер

- SafeAreaView - учитывает безопасные зоны экрана (notch, нижняя панель)

6. FlatList vs SectionList

- FlatList - для простых списков

- SectionList - для группированных данных с заголовками

7. Обработка нажатий

javascript

Apply to enter-email....

<TouchableOpacity onPress={() => {}}>

  <Text>Нажми меня</Text>

</TouchableOpacity>

### Продвинутая разработка

22. Expo

Expo - это набор инструментов и сервисов для разработки React Native приложений. В проекте используется:

json

Apply to enter-email....

"expo": "~52.0.42",

"expo-router": "~4.0.20"

23. expo-dev-client

Это инструмент для разработки с нативными модулями. В проекте:

json

Apply to enter-email....

"expo-dev-client": "~5.0.18"

24. Expo Go vs Dev Build

- Expo Go - готовое приложение для тестирования

- Dev Build - кастомная сборка с нативными модулями

25. Ограничения Expo Go

- Нельзя использовать нативные модули

- Ограниченный доступ к API устройства

- Размер приложения

26. Нативные модули

Это мосты между JavaScript и нативным кодом. Используются когда нужен доступ к:

- Аппаратным функциям

- Нативным API

- Производительности

27. Сохранение данных

В проекте используется AsyncStorage:

json

Apply to enter-email....

"@react-native-async-storage/async-storage": "1.23.1"

28. expo-router

Это файловая система маршрутизации для Expo. В проекте:

json

Apply to enter-email....

"expo-router": "~4.0.20"

### Рабочие кейсы

Анимация

В проекте используются:

json

Apply to enter-email....

"react-native-reanimated": "~3.16.1",

"@shopify/react-native-skia": "1.5.0"

Интеграция бекенда

Судя по package.json, используется fetch API и, возможно, axios (хотя не указан в зависимостях)

Приватные роуты и авторизация

В проекте используется:

- expo-router для маршрутизации

- AsyncStorage для хранения токенов

- Redux для управления состоянием авторизации

Это основные моменты, которые можно определить из предоставленного package.json и общих знаний о React Native разработке.